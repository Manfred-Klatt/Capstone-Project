<!DOCTYPE html>
<html lang="en" class="font-loading">
  <head>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <script>
      // Set the backend API URL
      window.BACKEND_API = 'https://capstone-project-production-3cce.up.railway.app/api/v1';
    </script>
    <script>
      // Carousel functionality
      document.addEventListener('DOMContentLoaded', function() {
        const slides = document.querySelectorAll('.leaderboard-slide');
        const dots = document.querySelectorAll('.dot');
        const prevBtn = document.querySelector('.prev-btn');
        const nextBtn = document.querySelector('.next-btn');
        let currentSlide = 0;
        
        // Only initialize carousel if we have slides and controls
        if (slides.length > 0) {
          // Show initial slide
          showSlide(currentSlide);
          
          // Add event listeners if elements exist
          if (nextBtn) {
            nextBtn.addEventListener('click', nextSlide);
          }
          
          if (prevBtn) {
            prevBtn.addEventListener('click', prevSlide);
          }
          
          if (dots.length > 0) {
            dots.forEach((dot, index) => {
              if (dot) {
                dot.addEventListener('click', () => goToSlide(index));
              }
            });
          }
        }
        
        // Next/previous controls
        function nextSlide() {
          if (slides.length > 0) {
            currentSlide = (currentSlide + 1) % slides.length;
            showSlide(currentSlide);
          }
        }
        
        function prevSlide() {
          if (slides.length > 0) {
            currentSlide = (currentSlide - 1 + slides.length) % slides.length;
            showSlide(currentSlide);
          }
        }
        
        // Dot controls
        function goToSlide(index) {
          if (index >= 0 && index < slides.length) {
            currentSlide = index;
            showSlide(currentSlide);
          }
        }
        
        // Show current slide and update dots
        function showSlide(index) {
          // Hide all slides and remove active class from dots
          slides.forEach(slide => {
            if (slide && slide.classList) {
              slide.classList.remove('active');
            }
          });
          
          dots.forEach(dot => {
            if (dot && dot.classList) {
              dot.classList.remove('active');
            }
          });
          
          // Show current slide and update dot if they exist
          if (slides[index] && slides[index].classList) {
            slides[index].classList.add('active');
          }
          
          if (dots[index] && dots[index].classList) {
            dots[index].classList.add('active');
          }
        }
        
        // Update time in the status bar
        function updateTime() {
          const now = new Date();
          const timeString = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
          document.querySelector('.nook-time').textContent = timeString;
        }
        
        // Update time every minute if we have the time element
        if (document.querySelector('.nook-time')) {
          updateTime();
          setInterval(updateTime, 60000);
        }
      });
    </script>
    <script>
      // Font loading with proper font face definition
      function loadCustomFont() {
        try {
          // Use the correct font name that matches the @font-face declaration
          const font = new FontFace('CustomFont', 'url(./fonts/customfont.woff2) format("woff2"), url(./fonts/customfont.otf) format("opentype")');
          
          font.load().then(() => {
            document.fonts.add(font);
            // Add the font-loaded class to apply the font
            document.documentElement.classList.add('font-loaded');
            document.documentElement.classList.remove('font-loading');
            logger.debug('Custom font loaded successfully');
          }).catch(error => {
            logger.warn('Failed to load custom font');
            document.documentElement.classList.remove('font-loading');
          });
        } catch (e) {
          logger.warn('Error in font loading');
          document.documentElement.classList.remove('font-loading');
        }
      }
      
      // Load the font when the page loads
      document.addEventListener('DOMContentLoaded', () => {
        loadCustomFont();
        
        // Verify font loading after a delay
        setTimeout(() => {
          const fontLoaded = document.fonts.check('1em CustomFont');
          logger.debug(`Font loaded verification: ${fontLoaded ? 'Success' : 'Failed'}`);
          if (!fontLoaded) {
            logger.warn('Font verification failed, trying to load again');
            loadCustomFont();
            
            // Add a fallback class in case font loading fails
            setTimeout(() => {
              if (!document.fonts.check('1em CustomFont')) {
                document.documentElement.classList.add('font-fallback');
                logger.warn('Using system fallback fonts');
              }
            }, 2000);
          }
        }, 1000);
      });
      
      // Generate a random guest token if not exists
      if (!localStorage.getItem('guestToken')) {
        localStorage.setItem('guestToken', 'guest_' + Math.random().toString(36).substr(2, 9));
      }
      
      // Leaderboard data and functionality
      const LEADERBOARD_CONFIG = {
        categories: ['fish', 'bugs', 'sea', 'villagers'],
        icons: {
          fish: '<img src="images/Fish_Icon.png" alt="Fish" style="width: 24px; height: 24px; vertical-align: middle;">',
          bugs: '<img src="images/Bug_Icon.png" alt="Bugs" style="width: 24px; height: 24px; vertical-align: middle;">',
          sea: '<img src="images/Sea_Creature_Icon.png" alt="Sea Creatures" style="width: 24px; height: 24px; vertical-align: middle;">',
          villagers: '<img src="images/Cat_Silhouette.png" alt="Villagers" style="width: 24px; height: 24px; vertical-align: middle;">'
        },
        defaultData: {
          fish: [
            { name: 'Tom Nook', score: 1000 },
            { name: 'Isabelle', score: 900 },
            { name: 'Player', score: 800 }
          ],
          bugs: [
            { name: 'Flick', score: 1200 },
            { name: 'Player', score: 950 },
            { name: 'Tom Nook', score: 700 }
          ],
          sea: [
            { name: 'Pascal', score: 1100 },
            { name: 'Player', score: 850 },
            { name: 'Isabelle', score: 750 }
          ],
          villagers: [
            { name: 'Isabelle', score: 1500 },
            { name: 'Tom Nook', score: 1200 },
            { name: 'Player', score: 1000 }
          ]
        }
      };

      // Initialize leaderboard when DOM is ready
      document.addEventListener('DOMContentLoaded', function() {
        // First try to load from server
        initializeLeaderboard().catch(error => {
          logger.error('Failed to load leaderboard from server, using default data');
          // Fall back to default data
          LEADERBOARD_CONFIG.categories.forEach(category => {
            const defaultData = LEADERBOARD_CONFIG.defaultData[category];
            if (defaultData) {
              updateLeaderboardUI(category, defaultData);
            }
          });
        });
      });

      // Track loading states to prevent duplicate requests
      const loadingStates = new Map();
      
      // Function to update the leaderboard UI
      function updateLeaderboardUI(category, data) {
        // Handle case where category is an object
        const categoryName = typeof category === 'object' && category.name ? category.name : category;
        
        logger.debug(`Updating UI for ${categoryName}`);
        const element = document.getElementById(`${categoryName}-scores`);
        
        if (!element) {
          logger.error(`Element not found for category: ${categoryName}`);
          return;
        }
        
        // Handle different response formats
        let leaderboardData = [];
        
        if (data && data.data && Array.isArray(data.data)) {
          // Handle API response format: { status: 'success', data: [...] }
          leaderboardData = data.data;
        } else if (Array.isArray(data)) {
          // Handle direct array format
          leaderboardData = data;
        } else if (data && data.leaderboard && Array.isArray(data.leaderboard)) {
          // Handle alternative API format: { leaderboard: [...] }
          leaderboardData = data.leaderboard;
        }
        
        if (!leaderboardData || leaderboardData.length === 0) {
          logger.debug('No valid data provided, using default leaderboard');
          const defaultData = LEADERBOARD_CONFIG.defaultData[categoryName];
          if (defaultData && Array.isArray(defaultData) && defaultData.length > 0) {
            updateLeaderboardUI(categoryName, defaultData);
            return;
          } else {
            logger.debug('No default leaderboard data available');
            element.innerHTML = `
              <div class="no-data">
                <p>No ${categoryName} leaderboard data available</p>
                <button class="retry-button" onclick="loadLeaderboardData('${categoryName}')">
                  <i class="fas fa-sync-alt"></i> Try Again
                </button>
              </div>`;
            return;
          }
        }
        
        try {
          // Generate HTML for the leaderboard
          let html = '<ol class="leaderboard-list">';
          
          if (leaderboardData.length === 0) {
            html += '<li class="no-scores">No scores yet. Be the first to play!</li>';
          } else {
            leaderboardData.slice(0, 10).forEach((entry, index) => {
              const isCurrentUser = entry.isCurrentUser || false;
              const rank = index + 1;
              const score = entry.score || 0;
              const name = (entry.name || 'Anonymous').substring(0, 15); // Limit name length
              
              html += `
                <li class="leaderboard-item ${isCurrentUser ? 'current-user' : ''}">
                  <span class="name" title="${name}">${name}</span>
                  <span class="score">${score.toLocaleString()}</span>
                </li>
              `;
            });
          }
          
          html += '</ol>';
          element.innerHTML = html;
          logger.debug(`Updated ${categoryName} with ${leaderboardData.length} entries`);
          
        } catch (error) {
          logger.error(`Error updating UI for ${categoryName}`);
          element.innerHTML = `
            <div class="error-message">
              <p>Error loading leaderboard data</p>
              <button class="retry-button" onclick="loadLeaderboardData('${categoryName}')">
                <i class="fas fa-sync-alt"></i> Try Again
              </button>
            </div>`;
        }
      }
      
      async function initializeLeaderboard() {
        logger.debug('Initializing leaderboard');
        
        // Ensure we have valid categories
        if (!Array.isArray(LEADERBOARD_CONFIG?.categories)) {
          logger.error('Invalid or missing categories in config');
          return;
        }
        
        // Check if we're in offline mode first
        if (isStandaloneMode()) {
          logger.debug('In offline mode, using default data for all categories');
          // Use default data for all categories
          for (const category of LEADERBOARD_CONFIG.categories) {
            if (!category || typeof category !== 'string') continue;
            updateLeaderboardUI(category, LEADERBOARD_CONFIG.defaultData[category] || []);
          }
          return;
        }
        
        // Load data for each category sequentially to avoid rate limiting
        for (const category of LEADERBOARD_CONFIG.categories) {
          // Skip if already loading this category or invalid category
          if (!category || typeof category !== 'string') {
            logger.warn(`Skipping invalid category: ${category}`);
            continue;
          }
          
          if (loadingStates.get(category)) {
            logger.debug(`Already loading ${category}, skipping duplicate request`);
            continue;
          }
          
          try {
            loadingStates.set(category, true);
            logger.debug(`Loading data for category: ${category}`);
            await loadLeaderboardData(category);
          } catch (error) {
            logger.error(`Error initializing ${category}`);
            // Fall back to default data on error
            const defaultData = LEADERBOARD_CONFIG.defaultData?.[category];
            if (defaultData) {
              updateLeaderboardUI(category, defaultData);
            }
          } finally {
            loadingStates.set(category, false);
          }
          
          // Small delay between requests to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 200));
        }
      }

      async function loadLeaderboardData(category, retryCount = 0) {
        // Ensure category is a string
        const categoryName = typeof category === 'object' && category.name ? category.name : category;
        const apiUrl = `${window.BACKEND_API}/leaderboard/${categoryName}`;
        
        const element = document.getElementById(`${categoryName}-scores`);
        // Reduce max retries to 1 to avoid excessive API calls
        const maxRetries = 1;
        
        if (!element) {
          logger.error(`Element not found for category: ${categoryName}`);
          return;
        }
        
        // Show loading state with a subtle animation
        element.innerHTML = `
          <div class="loading">
            <div class="loading-spinner"></div>
            <div>Loading ${categoryName} leaderboard...</div>
          </div>`;
          
        // If we've retried too many times, use default data without additional API calls
        if (retryCount > maxRetries) {
          logger.warn(`Max retries reached for ${categoryName}, using default data`);
          updateLeaderboardUI(categoryName, LEADERBOARD_CONFIG.defaultData[categoryName] || []);
          return;
        }
        
        // Check if we're in offline mode or have recent failed auth attempts
        if (isStandaloneMode() || localStorage.getItem('leaderboard_auth_failed') === 'true') {
          logger.debug(`Using default data for ${categoryName} (offline mode or auth failed)`);
          updateLeaderboardUI(categoryName, LEADERBOARD_CONFIG.defaultData[categoryName] || []);
          return;
        }
        
        try {
          // Get guest token from localStorage or generate a new one
          let guestToken = localStorage.getItem('guestToken');
          if (!guestToken) {
            guestToken = 'guest_' + Math.random().toString(36).substring(2, 11);
            localStorage.setItem('guestToken', guestToken);
          }
          
          logger.debug(`Fetching data for ${categoryName}`);
          
          const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          };
          
          // Add authorization headers
          if (guestToken) {
            headers['Authorization'] = `Bearer ${guestToken}`;
            headers['X-Guest-Token'] = guestToken;
          }
          
          // Use AbortController to set a timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
          
          const response = await fetch(apiUrl, {
            method: 'GET',
            headers: headers,
            credentials: 'include',
            mode: 'cors',
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if (response.ok) {
            // Clear any auth failure flag
            localStorage.removeItem('leaderboard_auth_failed');
            
            const data = await response.json();
            logger.debug(`Successfully loaded ${categoryName} data`);
            updateLeaderboardUI(categoryName, data);
          } else if (response.status === 401) {
            // Handle unauthorized - generate a new guest token and retry once
            logger.warn(`Unauthorized for ${categoryName}`);
            
            if (retryCount === 0) {
              // Generate a new token and try once more
              const newGuestToken = 'guest_' + Math.random().toString(36).substring(2, 11);
              localStorage.setItem('guestToken', newGuestToken);
              return loadLeaderboardData(categoryName, 1);
            } else {
              // If we've already retried, mark auth as failed and use default data
              localStorage.setItem('leaderboard_auth_failed', 'true');
              // Set a timeout to clear the auth failed flag after 5 minutes
              setTimeout(() => localStorage.removeItem('leaderboard_auth_failed'), 5 * 60 * 1000);
              
              updateLeaderboardUI(categoryName, LEADERBOARD_CONFIG.defaultData[categoryName] || []);
            }
          } else {
            // For other errors, use default data
            logger.error(`Error loading ${categoryName}: ${response.status}`);
            updateLeaderboardUI(categoryName, LEADERBOARD_CONFIG.defaultData[categoryName] || []);
          }
        } catch (error) {
          logger.warn(`Error loading ${categoryName}`);
          
          // For network errors, use default data without retrying
          updateLeaderboardUI(categoryName, LEADERBOARD_CONFIG.defaultData[categoryName] || []);
        }
      }
      
      // Start loading the font
      if ('fonts' in document) {
        loadCustomFont();
      } else {
        // Fallback for browsers without Font Loading API
        document.documentElement.classList.remove('font-loading');
      }
    </script>
    <script type="module" src="game.js"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover" />
    <!-- Preload sound effects -->
    <audio id="correct-sound" preload="auto">
      <source src="sounds/correct.ogg" type="audio/ogg">
    </audio>
    <audio id="game-over-sound" preload="auto">
      <source src="sounds/game-over.ogg" type="audio/ogg">
    </audio>
    <audio id="start-game-sound" preload="auto">
      <source src="sounds/start-game.ogg" type="audio/ogg">
    </audio>
    <audio id="high-score-sound" preload="auto">
      <source src="sounds/high-score.ogg" type="audio/ogg">
    </audio>
    <title>Animal Crossing Quiz Game</title>
    <style>
      /* Custom font declarations */
      @font-face {
        font-family: 'CustomFont';
        src: url('./fonts/customfont.woff2') format('woff2'),
             url('./fonts/customfont.otf') format('opentype');
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }
      
      /* Font loading classes */
      .font-loading {
        visibility: hidden;
      }
      
      .font-loaded {
        font-family: 'CustomFont', 'Arial', sans-serif;
      }
      
      .font-fallback {
        font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
        letter-spacing: 0.5px;
      }

      :root {
        /* Light theme (default) */
        --background-color: #f8f9fa;
        --text-color: #2c3e50;
        --container-bg: #ffffff;
        --border-color: #8b4513;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --button-bg: #4a90e2;
        --button-hover: #357abd;
        --card-bg: #ffffff;
        --card-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        --input-bg: #ffffff;
        --input-text: #2c3e50;
      }

      body {
        font-family: "CustomFont", "Arial", sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        text-align: center;
        background-image: url("images/background.webp");
        background-size: cover;
        background-position: center;
        background-attachment: fixed;
        background-color: rgba(255, 255, 255, 0.15);
        background-blend-mode: soft-light;
        color: #2c3e50;
        box-sizing: border-box;
        line-height: 1.6;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      #imageDisplay {
        max-width: 100%;
        max-height: 400px;
        margin: 10px auto;
        display: block;
        border: none;
        box-shadow: none;
        /* Hide broken image icon */
        font-size: 0;
        color: transparent;
        /* Smooth transition for loading */
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
      }
      
      #imageDisplay.loaded {
        opacity: 1;
      }
      
      .image-placeholder {
        width: 100%;
        max-width: 400px;
        height: 200px;
        margin: 10px auto;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f8f8f8;
        border: 2px dashed #ccc;
        border-radius: 10px;
        color: #666;
        font-size: 18px;
        text-align: center;
      }
      
      .loading-leaf {
        width: 80px;
        height: 80px;
        margin: 10px auto;
        display: none;
        background-image: url('images/leaf.png');
        background-size: contain;
        background-repeat: no-repeat;
        animation: spin 2s linear infinite;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      input, button {
        padding: 10px;
        font-size: 14px;
        border-radius: 6px;
        margin-right: 8px;
      }

      #guess-input {
        width: 100%;
        max-width: 280px;
        border: 1px solid var(--border-color);
        background-color: #fffdf8;
        margin: 5px 0;
      }

      button {
        background-color: #6b8e23;
        color: white;
        border: none;
        cursor: pointer;
        transition: background-color 0.3s;
      }
            
      #start-round:hover {
        background-color: #a0522d;
      }
      button:hover {
        background-color: #556b2f;
      }
      
      #try-again-btn {
        background-color: #ff8c00;
      }
      
      #try-again-btn:hover {
        background-color: #e67e00;
      }
      #feedback {
        margin: 20px 15px;
        padding: 15px 20px;
        font-size: 1.2em;
        min-height: 24px;
        font-weight: 600;
        border-radius: 8px;
        line-height: 1.4;
        max-width: 90%;
        margin-left: auto;
        margin-right: auto;
        transition: all 0.3s ease;
      }
      
      #feedback.wrong {
        background-color: rgba(220, 53, 69, 0.15);
        color: #dc3545;
        border-left: 4px solid #dc3545;
      }
      
      #feedback.correct {
        background-color: rgba(40, 167, 69, 0.15);
        color: #28a745;
        border-left: 4px solid #28a745;
      }
      #score {
        font-weight: bold;
        font-size: 18px;
        color: #8b4513;
      }
      #category-selector {
        margin: 15px 0;
      }
      select {
        padding: 6px;
        border-radius: 4px;
        border: 1px solid #5a3d2b;
        background-color: #fffdf8;
        font-family: 'CustomFont', Arial, sans-serif;
      }
      option {
        font-family: 'CustomFont', Arial, sans-serif;
      }
      .correct {
        color: #2e8b57;
      }
      .incorrect {
        color: #cd5c5c;
      }
      .logout-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background-color: #ff6b6b;
      }
      .logout-btn:hover {
        background-color: #ff5252;
      }
      #leaderboard-section {
        width: 200px;
        float: right;
        margin-right: 20px;
        background-color: rgba(45, 40, 35, 0.8);
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        border: 2px solid #8b5a2b;
        backdrop-filter: blur(5px);
      }
      #leaderboard-section h2 {
        margin-bottom: 10px;
        border-bottom: 2px solid #8b4513;
        padding-bottom: 5px;
        color: #5a3d2b;
        font-size: 1.4em;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
      }
      
      #admin-tools-container {
        width: 90%;
        max-width: 800px;
        margin: 10px auto;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        z-index: 100;
        border: 2px solid #8b4513;
      }
      
      #admin-tools-container h2 {
        margin-bottom: 10px;
        border-bottom: 2px solid #8b4513;
        padding-bottom: 5px;
        color: #5a3d2b;
      }
      
      #admin-tools-container button {
        padding: 10px 15px;
        background-color: #6b8e23;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
        white-space: nowrap;
        transition: background-color 0.2s;
      }
      
      #admin-tools-container button:hover {
        background-color: #5a7c1f;
      }
      
      #game-container {
        width: 100%;
        max-width: 1100px;
        margin: 0 auto 30px;
        padding: 15px;
        background-color: #fff9e6;
        border-radius: 10px;
        border: 2px solid var(--border-color, #8b4513);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        box-sizing: border-box;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
        transform-origin: top center;
        will-change: transform;
      }

        #leaderboard {
          font-size: 16px;
          font-weight: bold;
          background-color: #f5f5dc;
          border: 2px solid #8b7355;
          border-radius: 10px;
          padding: 15px;
          max-width: 100%;
          margin: 15px auto;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
          overflow: hidden;
        }
        
        .leaderboard-message {
          text-align: center;
          padding: 20px;
          color: #5a3d2b;
          font-size: 1.1em;
          line-height: 1.5;
        }
        
        .leaderboard-message p {
          margin: 10px 0;
        }
        
        /* Leaderboard Carousel */
      .leaderboard-carousel {
        height: 100%;
        display: flex;
        flex-direction: column;
        position: relative;
        overflow: hidden;
        flex-grow: 1;
      }
      
      .carousel-container {
        display: flex;
        transition: transform 0.3s ease-in-out;
        height: 100%;
        width: 100%;
        position: relative;
      }
      
      .leaderboard-slide {
        position: absolute;
        width: 100%;
        height: 100%;
        transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        padding: 10px;
        box-sizing: border-box;
        top: 0;
        left: 0;
        opacity: 0;
        pointer-events: none;
      }
      
      .leaderboard-slide.active {
        position: relative;
        opacity: 1;
        pointer-events: auto;
      }
      
      .leaderboard-scores {
        max-height: 300px;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #8b7355 #f5f5dc;
        padding: 8px;
        background-color: #f8f9fa;
        border-radius: 8px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      
      .leaderboard-scores::-webkit-scrollbar {
        width: 6px;
      }
      
      .leaderboard-scores::-webkit-scrollbar-track {
        background: #f5f5dc;
      }
      
      .leaderboard-scores::-webkit-scrollbar-thumb {
        background-color: #8b7355;
        border-radius: 3px;
      }
      
      .leaderboard-category {
        text-align: center;
        margin: 10px 0 20px;
        color: #000000;
        font-size: 1.6rem;
        font-weight: 700;
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        letter-spacing: 0.5px;
        padding: 8px 0;
        border-bottom: 2px solid rgba(0, 0, 0, 0.2);
        position: relative;
        background-color: rgba(255, 255, 255, 0.7);
        border-radius: 8px 8px 0 0;
      }
      
      .leaderboard-category::after {
        content: '';
        position: absolute;
        bottom: -2px;
        left: 25%;
        width: 50%;
        height: 2px;
        background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.3), transparent);
      }
      
      .carousel-nav {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 20px;
        position: absolute;
        bottom: 10px;
        left: 0;
        right: 0;
      }
      
      .nav-btn {
        background: #4a90e2;
        border: none;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 1.2rem;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
      }
      
      .nav-btn:hover {
        background: #357abd;
        transform: scale(1.1);
      }
      
      .nav-dots {
        display: flex;
        justify-content: center;
        margin: 15px 0;
        gap: 10px;
      }
      
      .dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background-color: #e0e0e0;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: 2px solid transparent;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      
      .dot:hover {
        transform: scale(1.2);
      }
      
      .dot.active {
        transform: scale(1.3);
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.2);
        border-color: rgba(255, 255, 255, 0.8);
      }
      
      /* Nook Phone Container */
      .nook-phone {
        width: 300px;  /* Fixed width */
        aspect-ratio: 4/9; /* 4:9 aspect ratio */
        min-height: 675px; /* Minimum height */
        margin: 30px auto;
        background: #f8f8f8;
        border-radius: 40px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        border: 10px solid #333;
        display: flex;
        flex-direction: column;
        position: relative;
        overflow: hidden;
      }
        
        .nook-phone-screen {
          background: #f8f8f8;
          border-radius: 30px;
          overflow: hidden;
          height: 100%;
          display: flex;
          flex-direction: column;
        }
        
        .nook-nav {
          display: flex;
          justify-content: space-between;
          padding: 10px 20px;
          font-size: 0.9rem;
          color: #333;
          font-weight: 600;
        }
        
        .nook-header {
          text-align: center;
          padding: 10px 0 20px;
          position: relative;
        }
        
        .nook-notch {
          width: 40%;
          height: 20px;
          background: #333;
          margin: 0 auto 10px;
          border-bottom-left-radius: 10px;
          border-bottom-right-radius: 10px;
        }
        
        .nook-title {
          color: #333;
          margin: 0;
          font-size: 1.5rem;
        }
        
        /* Leaderboard container */
        .leaderboards-container {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 15px;
          padding: 0 15px 60px;
          flex-grow: 1;
          overflow-y: auto;
          max-height: 500px;
        }
        
        .nook-app {
          background: white;
          border-radius: 15px;
          padding: 15px;
          text-align: center;
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
          transition: transform 0.2s, box-shadow 0.2s;
          cursor: pointer;
          position: relative;
          overflow: hidden;
        }
        
        .nook-app:hover {
          transform: translateY(-3px);
          box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        }
        
        .app-icon {
          font-size: 2rem;
          margin-bottom: 5px;
        }
        
        .app-title {
          font-weight: 600;
          margin-bottom: 10px;
          color: #333;
        }
        
        .nook-home-indicator {
          width: 30%;
          height: 5px;
          background: #333;
          border-radius: 10px;
          margin: 15px auto 5px;
        }
        
        /* Scrollbar styling */
        .leaderboards-container::-webkit-scrollbar {
          width: 6px;
        }
        
        .leaderboards-container::-webkit-scrollbar-track {
          background: #f1f1f1;
        }
        
        .leaderboards-container::-webkit-scrollbar-thumb {
          background: #888;
          border-radius: 10px;
        }
        
        .leaderboards-container::-webkit-scrollbar-thumb:hover {
          background: #555;
        }
        
        .leaderboards-container {
          padding: 0 15px;
          box-sizing: border-box;
          align-items: start; /* Align items to the top */
          justify-content: center;
        }

        .category-leaderboard {
          background-color: #fff9f0;
          padding: 15px;
          border-radius: 12px;
          box-shadow: 0 0 12px rgba(0, 0, 0, 0.1);
          border: 2px solid #8b4513;
          width: 100%;
          box-sizing: border-box;
          display: flex;
          flex-direction: column;
          align-items: center;
          height: auto; /* Let content determine height */
          margin: 0 auto;
        }
      .category-leaderboard {
        background-color: #fff9f0;
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 0 12px rgba(0, 0, 0, 0.1);
        border: 2px solid #8b4513;
        width: 100%;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: auto; /* Let content determine height */
        margin: 0 auto;
      }

      .category-leaderboard h3 {
        margin: 0 0 15px 0;
        padding: 12px 0;
        border-bottom: 2px solid rgba(0, 0, 0, 0.2);
        font-size: 1.2rem;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 1px;
        border-radius: 8px 8px 0 0;
        font-weight: 600;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .category-leaderboard > div {
        display: flex;
        flex-direction: column;
        min-height: 0; /* Prevents flex item from growing */
      }

      .category-leaderboard span {
        display: block;
        padding: 6px 0;
        border-bottom: 1px solid #e8e8e8;
        line-height: 1.3;
      }

      .category-leaderboard span:last-child {
        border-bottom: none;
      }
      #leaderboard-container {
        width: 100%;
        max-width: 1140px;
        margin: 20px auto;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        flex-wrap: wrap;
        gap: 10px;
        padding: 15px;
        background-color: #fff9f0;
        border-radius: 12px;
        box-shadow: 0 0 12px rgba(0, 0, 0, 0.1);
        border: 2px solid #8b4513;
        box-sizing: border-box;
      }
      .category-leaderboard h3 {
        margin-bottom: 5px;
        border-bottom: 2px solid #8b4513;
        padding-bottom: 2.5px;
      }
      .high-score-container {
        margin: 10px 0;
        padding: 0;
        background-color: transparent;
        font-size: 1.3em;
        font-weight: 600;
        letter-spacing: 0.5px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }
      
        #high-score {
        font-family: 'CustomFont', 'Arial', sans-serif;
        color: #2c3e50;
        margin-bottom: 8px;
        font-size: 1.1em;
      }
      
      .score-container {
        text-align: center;
      }
      .category-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
      }
      select {
        padding: 8px 12px;
        margin: 8px 0 15px;
        border-radius: 6px;
        border: 2px solid #8b4513;
        font-size: 1em;
        font-family: 'CustomFont', 'Arial', sans-serif;
        background-color: #ffffff;
        color: #2c3e50;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }
      
      select:hover {
        border-color: #a0522d;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      
      select:focus {
        outline: none;
        border-color: #6b8e23;
        box-shadow: 0 0 0 3px rgba(107, 142, 35, 0.2);
      }
      
      label {
        font-size: 1.2em;
        margin: 12px 0 8px;
        display: block;
        font-weight: 600;
        color: #2c3e50;
        letter-spacing: 0.5px;
        text-transform: uppercase;
        font-family: 'CustomFont', 'Arial', sans-serif;
      }
      
      .timer-container {
        display: block;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px 20px;
        border-radius: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin: 10px auto;
        text-align: center;
        width: fit-content;
      }

      .loading-leaf {
        width: 40px;
        height: 40px;
        background: url('images/loading.png') no-repeat center;
        background-size: contain;
        animation: spin 1s linear infinite;
        margin: 20px auto;
        display: none;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .timer {
        font-size: 24px;
        font-weight: bold;
        color: #333;
        transition: color 0.3s ease;
      }

      .timer.running {
        color: #4CAF50;
      }

      .timer.warning {
        color: #FFA500;
      }

      .timer.expired {
        color: #FF4444;
      }
      
      /* High Score Modal Styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
      }
      
      .modal-content {
        background-color: #f8f8f8;
        margin: 15% auto;
        padding: 20px;
        border: 2px solid #4CAF50;
        border-radius: 10px;
        width: 300px;
        text-align: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        animation: modalAppear 0.4s;
      }
      
      @keyframes modalAppear {
        from {transform: scale(0.8); opacity: 0;}
        to {transform: scale(1); opacity: 1;}
      }
      
      .modal h2 {
        color: #4CAF50;
        margin-top: 0;
      }
      
      .modal input {
        width: 90%;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 16px;
        font-family: Arial, sans-serif;
        color: #333;
      }
      
      .logout-btn {
        background-color: #4a90e2;
        color: white;
        padding: 8px 15px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.3s ease !important;
      }

      .logout-btn:hover {
        background-color: #357abd !important;
      }

      /* Reset All Button Hover Effect */
      #reset-all-btn {
        transition: background-color 0.3s ease !important;
      }

      #reset-all-btn:hover {
        background-color: #d93025 !important; /* Darker shade of red */
      }

      /* Reset to Defaults Button Hover Effect */
      #reset-to-defaults-btn {
        transition: background-color 0.3s ease !important;
      }

      #reset-to-defaults-btn:hover {
        background-color: #357abd !important; /* Darker shade of blue */
      }

      /* Reset Personal Best Button Hover Effect */
      #reset-high-score {
        transition: background-color 0.3s ease !important;
      }

      #reset-high-score:hover {
        background-color: #e69138 !important; /* Darker shade of orange */
      }
      
      /* Mobile Navigation Bar */
      .mobile-nav-bar {
        display: none;
      }
      
      /* Leaderboard styles */
      .leaderboard-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      
      /* Loading and error states */
      .loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        color: #666;
        text-align: center;
      }
      
      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top-color: #3498db;
        animation: spin 1s ease-in-out infinite;
        margin-bottom: 1rem;
      }
      
      .error-message {
        padding: 1.5rem;
        background-color: #f8d7da;
        color: #721c24;
        border-radius: 4px;
        text-align: center;
        margin: 1rem 0;
      }
      
      .error-message p {
        margin: 0 0 1rem 0;
      }
      
      .retry-button {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
        border-radius: 4px;
        padding: 0.5rem 1rem;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        transition: background-color 0.2s;
      }
      
      .retry-button:hover {
        background-color: #f1b0b7;
      }
      
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      
      .category-leaderboard {
        width: 100%;
        margin-bottom: 20px;
        box-sizing: border-box;
      }
      
      #fish-scores,
      #bugs-scores,
      #sea-scores,
      #villagers-scores {
        width: 100%;
        display: flex;
        flex-direction: column;
      }
      
      .category-leaderboard h3 {
        width: 100%;
        max-width: 800px;
        margin: 20px auto;
        padding: 0 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      
      .category-leaderboard {
        border-radius: 10px;
        border: 2px solid var(--border-color);
        padding: 15px;
        margin-bottom: 20px;
      }

      /* Unique background colors and header styles for each category */
      #fish-leaderboard {
        background: linear-gradient(to top, #87CEEB, #B0E0E6); /* Gradient from light blue to very light blue */
      }
      #fish-leaderboard h3 {
        color: #1a4b8c; /* Darker blue for better contrast */
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.5);
      }

      #bugs-leaderboard {
        background: linear-gradient(to top, #32CD32, #98FB98); /* Gradient from light green to very light green */
      }
      #bugs-leaderboard h3 {
        color: #1a5c1a; /* Darker green for better contrast */
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.5);
      }
      
      #sea-leaderboard {
        background: linear-gradient(to top, #00BFFF, #1E90FF); /* Gradient from darker blue to medium blue */
      }
      #sea-leaderboard h3 {
        color: #0a3d6b; /* Darker blue for better contrast */
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.5);
      }

      #villagers-leaderboard {
        background: linear-gradient(to top, #FFD700, #FFB6C1); /* Gradient from gold to light pink */
      }
      #villagers-leaderboard h3 {
        color: #8b4513; /* Brownish-gold for better contrast */
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.5);
      }
      
      .category-leaderboard:last-child {
        margin-bottom: 0;
      }
      
      .leaderboard-score {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background-color: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 6px;
        margin-bottom: 6px;
        padding: 10px 16px;
        margin: 4px 0;
        background-color: #ffffff;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
        font-size: 0.95rem;
        color: #2a1e13;
        transition: all 0.2s ease;
        position: relative;
        overflow: hidden;
        border-left: 4px solid transparent;
      }
      
      /* Animation for top 3 scores */
      @keyframes rainbowGlow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      
      .first-place {
        position: relative;
        z-index: 3;
        background: linear-gradient(
          90deg, 
          #ff9a9e, #fad0c4, #fad0c4, 
          #ffd1ff, #ffd1ff, #a8edea, 
          #c4e0e5, #d4fc79, #96e6a1
        ) !important;
        background-size: 300% 300% !important;
        animation: rainbowGlow 8s ease infinite;
        transform: scale(1.02);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }
      
      .second-place {
        position: relative;
        z-index: 2;
        background: linear-gradient(
          90deg, 
          #a1c4fd, #c2e9fb, #f6d365, 
          #fda085, #f6d365, #c2e9fb
        ) !important;
        background-size: 200% 200% !important;
        animation: rainbowGlow 10s ease infinite;
        transform: scale(1.01);
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
      }
      
      .third-place {
        position: relative;
        z-index: 1;
        background: linear-gradient(
          90deg, 
          #f6d365, #fda085, #f6d365, 
          #ffefba, #ffffff, #ffefba
        ) !important;
        background-size: 200% 200% !important;
        animation: rainbowGlow 12s ease infinite;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      
      /* Fish category */
      .fish-score {
        border-left-color: #4a90e2;
        background: linear-gradient(90deg, rgba(234, 244, 255, 0.3) 0%, #ffffff 20%);
      }
      .fish-score .leaderboard-rank::before {
        content: 'ðŸŸ ';
      }
      
      /* Bugs category */
      .bugs-score {
        border-left-color: #8bc34a;
        background: linear-gradient(90deg, rgba(235, 248, 225, 0.3) 0%, #ffffff 20%);
      }
      .bugs-score .leaderboard-rank::before {
        content: 'ðŸž ';
      }
      
      /* Sea creatures category */
      .sea-score {
        border-left-color: #00bcd4;
        background: linear-gradient(90deg, rgba(224, 247, 250, 0.3) 0%, #ffffff 20%);
      }
      .sea-score .leaderboard-rank::before {
        content: 'ðŸš ';
      }
      
      /* Villagers category */
      .villagers-score {
        border-left-color: #ff9800;
        background: linear-gradient(90deg, rgba(255, 243, 224, 0.3) 0%, #ffffff 20%);
      }
      .villagers-score .leaderboard-rank::before {
        content: 'ðŸ¡ ';
      }
      
      .leaderboard-score > div {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .leaderboard-score:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        z-index: 1;
      }
      
      .leaderboard-score .name {
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding: 8px 12px;
        text-align: left;
        font-size: 1.2rem;
        font-weight: 700;
        color: #000000;
        letter-spacing: 0.3px;
        background: transparent;
        margin-right: auto;
        position: relative;
        padding-left: 15px;
        transition: all 0.2s ease;
        text-shadow: none;
      }
      
      .leaderboard-score .name::before {
        content: '';
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 4px;
        height: 60%;
        background: #8b5a2b;
        border-radius: 0 2px 2px 0;
        opacity: 0.6;
        transition: all 0.2s ease;
      }
      
      .leaderboard-score:hover .name {
        background: rgba(255, 255, 255, 0.5);
      }
      
      .leaderboard-score:hover .name::before {
        opacity: 0.9;
        height: 80%;
      }
      
      .leaderboard-rank {
        font-weight: 800;
        color: #000000;
        min-width: 30px;
        text-align: center;
        font-size: 1.1rem;
        flex-shrink: 0;
        background: #f8f9fa;
        padding: 8px 6px;
        border-radius: 6px 0 0 6px;
        margin-right: 8px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-right: none;
      }
      
      
      .leaderboard-score .score {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        min-width: 80px;
        padding: 8px 12px;
        background: #f8f9fa;
        border-radius: 6px;
        font-weight: 800;
        font-size: 1.2rem;
        color: #000000;
        white-space: nowrap;
        border: 1px solid rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
        position: relative;
        overflow: hidden;
        margin-right: 8px;
        text-shadow: none;
      }
      
      .leaderboard-score .score::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent 0%, rgba(0,0,0,0.03) 100%);
        pointer-events: none;
      }
      
      .leaderboard-score.is-new {
        background-color: rgba(76, 175, 80, 0.1);
      }
      
      .leaderboard-score:nth-child(4),
      .leaderboard-score:nth-child(5),
      .leaderboard-score:nth-child(6),
      .leaderboard-score:nth-child(7),
      .leaderboard-score:nth-child(8),
      .leaderboard-score:nth-child(9),
      .leaderboard-score:nth-child(10) {
        background-color: #f0f0f0;
        color: #2a1e13;
        font-weight: 500;
        border-left: 4px solid #8b5a2b;
      }
      
      /* Responsive adjustments */
      @media (max-width: 1100px) {
        #game-container {
          width: 95%;
          margin: 0 auto 20px;
          padding: 10px;
        }
      }
      
      @media (max-width: 768px) {
        #game-container {
          width: 98%;
          margin: 0 auto 15px;
          padding: 8px;
          border-radius: 8px;
        }
        
        .category-leaderboard h3 {
          font-size: 1.1rem;
        }
        
        .leaderboard-score {
          font-size: 0.9rem;
          padding: 6px 10px;
        }
        
        .leaderboard-score .score {
          min-width: 45px;
          padding: 3px 8px;
          font-size: 0.95rem;
        }
      }
      
      @media (max-width: 480px) {
        .category-leaderboard h3 {
          font-size: 1rem;
        }
        
        .leaderboard-score {
          font-size: 0.8rem;
        }
        
        .leaderboard-score .score {
          min-width: 45px;
        }

        /* Make guess input field fit mobile screen */
        #guess-input {
          width: 100%;
          max-width: 100%;
          box-sizing: border-box;
          padding: 8px;
          margin: 8px 0;
        }

        /* Fix admin container overlap on mobile */
        #admin-tools-container {
          position: absolute;
          top: 50px;
          left: 0;
          right: 0;
          background-color: var(--container-bg);
          border-radius: 10px;
          padding: 15px;
          margin: 10px;
          z-index: 1000;
        }

        /* Adjust admin toggle button position on mobile */
        #admin-toggle-btn {
          top: 10px;
          left: 10px;
          z-index: 2000;
        }
      }
      
      /* Special styling for top 3 positions */
      .leaderboard-score:nth-child(-n+3) .name::before {
        content: counter(rank);
        color: var(--text-color);
        font-weight: bold;
        margin-right: 5px;
        padding: 2px 5px;
        border-radius: 3px;
        background-color: var(--container-bg);
        text-shadow: 0 0 1px rgba(0, 0, 0, 0.8); /* Thin black outline */
      }
      
      /* Media Queries for Mobile Responsiveness */
      /* Common container styles for mobile */
      .mobile-container {
        width: 95%;
        margin-left: auto;
        margin-right: auto;
        box-sizing: border-box;
        border-radius: 10px;
        border: 2px solid var(--border-color);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        background-color: #e8f5e9; /* Soft mint green that complements the theme */
      }
      
      /* Ensure all containers have the same styling on mobile */
      @media (max-width: 768px) {
        #category-selector {
          flex-direction: row;
          justify-content: center;
          flex-wrap: wrap;
          gap: 10px;
        }
        
        #category-selector > div {
          flex: 0 1 auto;
          min-width: 150px;
          max-width: 180px;
        }
        
        #category, #difficulty {
          font-size: 0.85rem !important;
          padding: 5px !important;
        }
        
        .mobile-container {
          width: 95% !important;
          max-width: 600px !important;
          margin: 5px auto !important;
          padding: 10px !important;
          background-image: url("images/background.webp") !important;
          background-color: rgba(26, 32, 44, 0.9) !important;
          background-blend-mode: overlay !important;
          color: var(--dark-text) !important;
          border: 2px solid var(--border-color) !important;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.1) !important;
          box-sizing: border-box !important;
          text-align: center !important;
        }
        
        /* Reduce spacing in game elements */
        h1 {
          font-size: 1rem !important;
          margin: 5px 0 !important;
          line-height: 1.2;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          background: linear-gradient(90deg, 
            #ff0000 0%,
            #ff7e00 10%,
            #ffff00 20%,
            #00ff00 30%,
            #00ffff 40%,
            #0000ff 50%,
            #8b00ff 60%,
            #ff00ff 70%,
            #ff0000 80%
          );
          -webkit-background-clip: text;
          background-clip: text;
          color: transparent;
          animation: rainbow 2s linear infinite;
        }

        @keyframes rainbow {
          0% {
            background-position: 0% 50%;
          }
          100% {
            background-position: 100% 50%;
          }
        }
        
        .high-score-container {
          margin-bottom: 10px !important;
        }
        
        #category-selector {
          margin: 5px 0 !important;
        }
        
        .score-container {
          margin: 5px 0 !important;
          display: flex !important;
          justify-content: center !important;
          gap: 5px !important;
          align-items: center !important;
          font-size: 0.9rem !important;
        }
        
        .mobile-timer-wrapper {
          display: flex !important;
          flex-direction: column !important;
          align-items: center !important;
          gap: 5px !important;
        }
        
        .timer-container {
          margin: 0 !important;
          padding: 3px 6px !important;
          border-radius: 12px !important;
          font-size: 0.85rem !important;
          background-color: rgba(255, 255, 255, 0.9) !important;
          order: -1 !important; /* Ensures timer is above score */
        }
        
        .timer {
          font-size: 0.9rem !important;
          padding: 2px 4px !important;
          margin: 0 !important;
        }
        
        #score {
          margin-top: 2px !important;
        }
        
        #imageDisplay {
          max-height: 250px !important;
          margin: 5px auto !important;
        }
        
        #feedback {
          margin: 5px !important;
          min-height: 20px !important;
        }
        
        #guess-input {
          margin: 5px 0 !important;
        }
        
        button {
          margin: 5px 2px !important;
          padding: 8px 10px !important;
        }
        
        /* Special handling for mobile nav bar to maintain flex layout */
        .mobile-nav-bar.mobile-container {
          display: flex !important;
          justify-content: space-between !important;
          text-align: left !important;
        }
      }
      
      /* Responsive styles for leaderboards */
      @media (max-width: 1000px) {
        .leaderboards-container {
          max-width: 700px;
        }
      }
      
      @media (max-width: 768px) {
        .leaderboards-container {
          grid-template-columns: 1fr 1fr;
          max-width: 600px;
          gap: 15px;
        }
      }
      
      @media (max-width: 600px) {
        .leaderboards-container {
          grid-template-columns: 1fr;
          max-width: 350px;
          gap: 10px; /* Reduced from 15px to 10px to match the game container spacing */
          margin-top: 10px; /* Add top margin to match spacing below game container */
        }
        
        .category-leaderboard {
          margin-bottom: 10px; /* Ensure consistent spacing between leaderboards */
        }
      }
      
      @media (max-width: 768px) {
        body {
          padding: 10px;
          display: flex;
          flex-direction: column;
          align-items: center;
        }
        
        /* Create space above game container for buttons */
        .mobile-nav-bar {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 10px 5px;
          margin-bottom: 15px;
          background-color: rgba(255, 249, 240, 0.9);
          border: 2px solid var(--border-color);
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        /* Style mobile buttons */
        .mobile-btn {
          background-color: #4a90e2;
          color: white;
          border: none;
          border-radius: 6px;
          padding: 8px 12px;
          font-size: 12px;
          font-weight: bold;
          cursor: pointer;
        }
        
        /* Hide desktop buttons on mobile */
        #admin-toggle-btn, 
        #logoutBtn, 
        button[onclick*="leaderboards.html"] {
          display: none;
        }
        
        #game-container {
          padding: 15px 10px;
          margin-top: 10px;
        }
        
        .category-container {
          flex-direction: column;
          align-items: center;
        }
        
        .timer-container {
          margin-left: 0;
          margin-top: 10px;
        }
        
        input, button {
          margin: 5px 2px;
          padding: 8px;
          font-size: 14px;
        }
        
        #leaderboard-container {
          width: 95%;
          margin-left: auto;
          margin-right: auto;
          background-color: #e8f5e9; /* Soft mint green that complements the theme */
        }
        
        /* Ensure modal is properly sized on mobile */
        .modal-content {
          width: 90%;
          max-width: 300px;
          padding: 15px;
        }
      }
      
      /* Small mobile devices */
      @media (max-width: 480px) {
        h1 {
          font-size: 1.5rem;
        }
        
        .category-leaderboard {
          min-width: 150px;
        }
        
        #guess-input {
          max-width: 100%;
        }
        
        #leaderboard-container {
          width: 95%;
          margin-left: auto;
          margin-right: auto;
          background-color: #e8f5e9;
        }
      }
    </style>
    <style>
      /* Style for welcome message on mobile */
      @media (max-width: 768px) {
        #welcome-message {
          font-size: 0.9rem !important;
          max-width: 150px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
      }
      
      /* Style for passcode input */
      #passcode-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 10000;
        justify-content: center;
        align-items: center;
      }
      
      #passcode-container {
        background: white;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        max-width: 300px;
        width: 80%;
      }
      
      #passcode-input {
        width: 100%;
        padding: 10px;
        margin: 15px 0;
        font-size: 16px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      
      #passcode-submit {
        background-color: #4a90e2;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
      }
      
      #passcode-submit:hover {
        background-color: #357abd;
      }
    </style>
    <script>
      // Helper function to show notifications
      function showNotification(message) {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.position = 'fixed';
        notification.style.top = '50px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.backgroundColor = '#4a90e2';
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '5px';
        notification.style.zIndex = '9999';
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.3s ease';
        document.body.appendChild(notification);
        
        // Show and then fade out the notification
        setTimeout(() => {
          notification.style.opacity = '1';
          setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
              document.body.removeChild(notification);
            }, 300);
          }, 2000);
        }, 10);
      }
    </script>
  </head>
  <body>
    <!-- Passcode Modal -->
    <div id="passcode-modal">
      <div id="passcode-container">
        <h3 style="color: #2c3e50; margin-top: 0;">Enter Passcode</h3>
        <form id="passcode-form" onsubmit="return false;" autocomplete="off">
          <!-- Hidden username field for accessibility -->
          <div style="position: absolute; left: -9999px; width: 1px; height: 1px; overflow: hidden;">
            <label for="hidden-username">Username</label>
            <input type="text" id="hidden-username" name="username" autocomplete="username" tabindex="-1">
          </div>
          <input type="password" id="passcode-input" name="passcode" placeholder="Enter passcode" autocomplete="new-password">
          <button type="button" id="passcode-submit">Submit</button>
        </form>
      </div>
    </div>
    <!-- Fixed Top Navigation Bar -->
    <div id="fixed-nav-bar" style="position:fixed; top:0; left:0; width:100vw; height:85px; background:rgba(255,255,255,0.5); z-index:999; display:flex; justify-content:space-between; align-items:center; box-shadow:0 2px 12px rgba(0,0,0,0.07); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px); padding: 0 30px 0 20px;">
      <!-- Left Side: Admin Button and Welcome Message -->
      <div style="display: flex; align-items: center; gap: 20px;">
        <button id="admin-toggle-btn-mobile" class="mobile-btn" style="background:transparent; border:none; cursor:pointer; width:60px; height:60px; display:flex; align-items:center; justify-content:center; padding:0;">
          <img src="images/admin.png" alt="Nook" style="width:60px; height:60px;">
        </button>
        <!-- Welcome Message Speech Bubble -->
        <div id="welcome-message" class="speech-bubble" style="font-family: 'CustomFont', sans-serif; font-size: 1rem; color: #5a3d2b; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); background-color: #ffffff; padding: 4px 10px; position: absolute; left: 85px; top: 50%; transform: translateY(-50%); z-index: 1000; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border-radius: 8px;">
          Welcome, <span id="username-display">Guest</span>!
        </div>
        <!-- Separate tail element for better control -->
        <div class="speech-bubble-tail" style="position: absolute; left: 79px; top: 50%; transform: translateY(-50%); width: 0; height: 0; border: 8px solid transparent; border-right-color: #ffffff; border-left: 0; border-bottom: 0; z-index: 1001;"></div>
      </div>
      
      <!-- Center: Offline Mode Indicator -->
      <div id="standalone-indicator-container" style="position: absolute; left: 50%; transform: translateX(-50%); top: 15px; display: none;">
        <button id="standalone-mode-btn" style="background: #ff9800; color: white; border: none; border-radius: 20px; padding: 8px 16px; font-family: 'CustomFont', sans-serif; font-size: 0.9rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer;">
          Offline Mode
        </button>
      </div>
      
      <!-- Speech Bubble Styles -->
      <style>
        @keyframes pulse {
          0% { opacity: 0.4; }
          50% { opacity: 1; }
          100% { opacity: 0.4; }
        }
        
        .speech-bubble {
          position: relative;
          background: #ffffff;
          border-radius: 0.3em;
          line-height: 1.2;
        }
        
        .speech-bubble:after {
          content: '';
          position: absolute;
          left: -6px;
          top: 50%;
          width: 0;
          height: 0;
          border: 8px solid transparent;
          border-right-color: #ffffff;
          border-left: 0;
          border-bottom: 0;
          transform: translateY(-50%);
          z-index: 1001;
        }
        
        /* Mobile styles for welcome message */
        @media (max-width: 768px) {
          #welcome-message {
            font-size: 0.85rem !important;
            max-width: 140px;
            padding: 5px 12px;
            left: 75px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            border-radius: 8px;
          }
          
          .speech-bubble-tail {
            left: 69px;
            top: 50%;
            transform: translateY(-50%);
            display: block !important;
          }
          
          /* Hide offline mode button on mobile */
          #standalone-indicator-container {
            display: none !important;
          }
        }
      </style>
      
      <!-- Right Side: Sound and Home Buttons -->
      <div style="position: absolute; right: 60px; top: 15px; display: flex; gap: 8px; align-items: center;">
        <button id="sound-toggle-mobile" class="mobile-btn" style="background:rgba(255,255,255,0.9); box-shadow:0 4px 16px rgba(0,0,0,0.18); border:none; cursor:pointer; width:48px; height:48px; border-radius:50%; display:flex; align-items:center; justify-content:center; transition:all 0.3s ease;" aria-label="Toggle sound">
          <img src="images/speaker.png" alt="Sound" style="width:28px; height:28px; transition:all 0.3s ease;">
        </button>
        <button id="logoutBtn-mobile" class="mobile-btn" style="background:rgba(255,255,255,0.9); box-shadow:0 4px 16px rgba(0,0,0,0.18); border:none; cursor:pointer; width:48px; height:48px; border-radius:50%; display:flex; align-items:center; justify-content:center; transition:all 0.3s ease;">
          <img src="images/home.png" alt="Home" style="width:28px; height:28px; transition:all 0.3s ease;">
        </button>
      </div>
    </div>
    <div style="width:100%; height:85px;" id="header-spacer"></div>
    
    <script>
      // Global debug flag - set to false to disable most console logs
      const DEBUG = false;
      
      // Custom logger that respects the DEBUG flag
      const logger = {
        info: function(message, ...args) {
          if (DEBUG) console.info(message, ...args);
        },
        warn: function(message, ...args) {
          console.warn(message, ...args); // Always show warnings
        },
        error: function(message, ...args) {
          console.error(message, ...args); // Always show errors
        },
        debug: function(message, ...args) {
          if (DEBUG) console.debug(message, ...args);
        }
      };
      
      // Define API URLs
      const API_URL = 'https://capstone-project-production-3cce.up.railway.app';
      const BACKEND_API = API_URL;
      
      // Function to detect if we're running in offline mode (without a server)
      function isStandaloneMode() {
        // If we have a valid backend API URL and no explicit force_standalone flag
        if (window.BACKEND_API) {
          // Check if we have a recent successful health check
          const healthCheck = localStorage.getItem('backendHealth');
          if (healthCheck) {
            try {
              const { status, timestamp } = JSON.parse(healthCheck);
              const lastCheck = new Date(timestamp);
              const now = new Date();
              const minutesSinceLastCheck = (now - lastCheck) / (1000 * 60);
              
              // If we have a recent successful health check, we're not in standalone mode
              if (status === 'available' && minutesSinceLastCheck < 5) {
                return false;
              }
            } catch (e) {
              console.error('Error parsing health check data:', e);
            }
          }
        }
        
        // Check if force_standalone is set in localStorage
        return localStorage.getItem('force_standalone') === 'true' || 
               window.location.search.includes('standalone=1');
      }

      // Function to check if the server is available
      async function checkServerAvailable() {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
        
        try {
          logger.debug('Checking server availability');
          
          // Get guest token from localStorage or generate a new one
          let guestToken = localStorage.getItem('guestToken');
          if (!guestToken) {
            guestToken = 'guest_' + Math.random().toString(36).substring(2, 11);
            localStorage.setItem('guestToken', guestToken);
          }
          
          // Prepare headers with guest token
          const headers = {
            'Accept': 'application/json',
            'Content-Type': 'application/json'
          };
          
          // Add guest token to headers
          if (guestToken) {
            headers['Authorization'] = `Bearer ${guestToken}`;
            headers['X-Guest-Token'] = guestToken;
          }
          
          // Try direct health check first
          try {
            const response = await fetch(`${API_URL}/health`, {
              method: 'GET',
              signal: controller.signal,
              mode: 'cors',
              credentials: 'include',
              headers: headers
            });
            
            clearTimeout(timeoutId);
            if (response.ok) {
              logger.debug('Server health check: available');
              // Store health status in localStorage
              localStorage.setItem('backendHealth', JSON.stringify({
                status: 'available',
                timestamp: new Date().toISOString()
              }));
              return true;
            }
          } catch (healthError) {
            logger.debug('Health endpoint failed, trying root endpoint');
          }
          
          // If health check fails, try root endpoint
          const baseUrl = API_URL.split('/api')[0];
          const rootResponse = await fetch(baseUrl, {
            method: 'GET',
            signal: controller.signal,
            mode: 'cors',
            credentials: 'include',
            headers: headers
          });
          
          clearTimeout(timeoutId);
          
          // Store health status in localStorage
          localStorage.setItem('backendHealth', JSON.stringify({
            status: rootResponse.ok ? 'available' : 'unavailable',
            timestamp: new Date().toISOString()
          }));
          
          return rootResponse.ok;
        } catch (error) {
          logger.error('Server availability check failed');
          
          // Store health status in localStorage
          localStorage.setItem('backendHealth', JSON.stringify({
            status: 'unavailable',
            timestamp: new Date().toISOString()
          }));
          
          return false;
        }
      }
      
      // Function to show or hide the offline mode indicator
      function updateStandaloneModeIndicator() {
        const standaloneContainer = document.getElementById('standalone-indicator-container');
        const standaloneBtn = document.getElementById('standalone-mode-btn');
        
        if (isStandaloneMode()) {
          standaloneContainer.style.display = 'block';
          
          // Add click handler to show explanation when clicked
          standaloneBtn.onclick = function() {
            alert('You are playing in offline mode. Your scores are saved locally and not shared online.');
          };
        } else {
          standaloneContainer.style.display = 'none';
        }
      }
      
      // Function to update the welcome message with the username
      function updateWelcomeMessage() {
        const username = localStorage.getItem('username') || sessionStorage.getItem('username') || 'Guest';
        const usernameDisplay = document.getElementById('username-display');
        if (usernameDisplay) {
          usernameDisplay.textContent = username;
        }
      }
      
      // Check server health on page load
      async function initServerCheck() {
        logger.debug('Initializing server health check');
        
        try {
          // Get or generate guest token
          let guestToken = localStorage.getItem('guestToken');
          if (!guestToken) {
            guestToken = 'guest_' + Math.random().toString(36).substring(2, 11);
            localStorage.setItem('guestToken', guestToken);
            logger.debug('Generated new guest token');
          }
          
          // Check if we have a recent health check
          const healthCheck = localStorage.getItem('backendHealth');
          let skipHealthCheck = false;
          
          if (healthCheck) {
            try {
              const { status, timestamp } = JSON.parse(healthCheck);
              const lastCheck = new Date(timestamp);
              const now = new Date();
              const minutesSinceLastCheck = (now - lastCheck) / (1000 * 60);
              
              // If we have a recent health check (less than 1 minute ago), skip the check
              if (minutesSinceLastCheck < 1) {
                logger.debug('Using recent health check result');
                skipHealthCheck = true;
                
                // If the last check showed server was unavailable, prompt for offline mode
                if (status === 'unavailable' && !localStorage.getItem('standalone_confirmed_this_session')) {
                  handleOfflineMode();
                }
              }
            } catch (e) {
              logger.error('Error parsing health check data');
            }
          }
          
          // If we don't have a recent health check, perform one now
          if (!skipHealthCheck) {
            logger.debug('Performing fresh health check');
            const serverAvailable = await checkServerAvailable();
            
            if (!serverAvailable && !localStorage.getItem('standalone_confirmed_this_session')) {
              handleOfflineMode();
            }
          }
          
          // Update the offline mode indicator
          updateStandaloneModeIndicator();
          
        } catch (error) {
          logger.error('Error checking server health');
          // Update offline mode indicator in case of error
          updateStandaloneModeIndicator();
        }
      }
      
      // Helper function to handle offline mode prompt
      function handleOfflineMode() {
        // Server is not available, offer offline mode
        if (confirm("Server connection unavailable. Your scores will be saved locally but not shared online. Continue in offline mode?")) {
          localStorage.setItem('force_standalone', 'true');
          localStorage.setItem('standalone_confirmed_this_session', 'true');
          logger.info('User confirmed offline mode');
        } else {
          // If they don't want to continue, redirect to home page
          logger.info('User declined offline mode, redirecting to home');
          window.location.href = 'index.html';
        }
      }
      
      // Run the server check
      initServerCheck();
      
      // Admin toggle button for mobile with secret activation pattern
        const adminToggleBtnMobile = document.getElementById('admin-toggle-btn-mobile');
        if (adminToggleBtnMobile) {
          let mobileClickCount = 0;
          let mobileClickTimer = null;
          const mobileRequiredClicks = 5;
          const mobileTimeWindow = 3000; // 3 seconds in milliseconds
          
          adminToggleBtnMobile.addEventListener('click', function() {
            // Increment click counter
            mobileClickCount++;
            
            // Add a small animation effect on click
            adminToggleBtnMobile.style.transform = 'scale(0.9)';
            setTimeout(() => {
              adminToggleBtnMobile.style.transform = 'scale(1)';
            }, 100);
            
            // Clear existing timer if it exists
            if (mobileClickTimer) {
              clearTimeout(mobileClickTimer);
            }
            
            // Set new timer to reset counter after timeWindow
            mobileClickTimer = setTimeout(() => {
              mobileClickCount = 0;
            }, mobileTimeWindow);
            
            // Check if we've reached the required number of clicks within the time window
            if (mobileClickCount >= mobileRequiredClicks) {
              // Reset counter
              mobileClickCount = 0;
              
              // Check if already in admin mode
              const adminToolsContainer = document.getElementById('admin-tools-container');
              const isHidden = adminToolsContainer.style.display === 'none';
              
              // If trying to activate admin mode, show passcode modal
              if (isHidden) {
                const passcodeModal = document.getElementById('passcode-modal');
                const passcodeInput = document.getElementById('passcode-input');
                const passcodeSubmit = document.getElementById('passcode-submit');
                
                // Show the modal
                passcodeModal.style.display = 'flex';
                setTimeout(() => passcodeInput.focus(), 100); // Delay focus to ensure modal is visible
                
                // Handle passcode submission with debounce to prevent multiple rapid submissions
                let isProcessing = false;
                const checkPasscode = () => {
                  if (isProcessing) return; // Prevent multiple submissions
                  isProcessing = true;
                  
                  // Get the stored passcode or use default
                  const storedPasscode = localStorage.getItem('adminPasscode') || 'blathers'; // Default passcode
                  const enteredPasscode = passcodeInput.value;
                  
                  // Simple validation
                  if (!enteredPasscode) {
                    isProcessing = false;
                    return;
                  }
                  
                  // Check passcode
                  if (enteredPasscode === storedPasscode) {
                    adminToolsContainer.style.display = 'block';
                    passcodeModal.style.display = 'none';
                    passcodeInput.value = ''; // Clear the input
                    showNotification('Admin Mode Activated');
                  } else {
                    alert('Incorrect passcode');
                    passcodeInput.value = ''; // Clear the input
                    setTimeout(() => passcodeInput.focus(), 100);
                  }
                  
                  // Reset processing flag after a short delay
                  setTimeout(() => {
                    isProcessing = false;
                  }, 300);
                };
                
                // Handle Enter key
                passcodeInput.onkeydown = (e) => {
                  if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent form submission
                    checkPasscode();
                  } else if (e.key === 'Escape') {
                    passcodeModal.style.display = 'none';
                    passcodeInput.value = '';
                  }
                };
                
                // Handle button click
                passcodeSubmit.onclick = checkPasscode;
                
                // Handle clicking outside the modal to close
                passcodeModal.onclick = (e) => {
                  if (e.target === passcodeModal) {
                    passcodeModal.style.display = 'none';
                    passcodeInput.value = '';
                  }
                };
                
                return; // Don't proceed with the rest of the click handler
              } else {
                // Deactivating admin mode - no passcode needed
                adminToolsContainer.style.display = 'none';
              }
              
              // Show notification for admin mode activation
              showNotification('Admin Mode Deactivated');
            }
          });
        }
        
        // Home button for mobile
        const logoutBtnMobile = document.getElementById('logoutBtn-mobile');
        if (logoutBtnMobile) {
          logoutBtnMobile.addEventListener('click', function() {
            localStorage.removeItem('acnh_current_score');
            localStorage.removeItem('acnh_last_category');
            window.location.href = 'index.html';
          });
        }
        
        // Sound toggle button for mobile
        const soundToggleBtnMobile = document.getElementById('sound-toggle-mobile');
        if (soundToggleBtnMobile) {
          // Initialize sound state (off by default)
          soundEnabled = false;
          
          // Set initial image to muted
          const soundImg = soundToggleBtnMobile.querySelector('img');
          if (soundImg) {
            soundImg.src = 'images/speaker-mute.png';
            soundImg.alt = 'Sound Off';
          }
          
          soundToggleBtnMobile.addEventListener('click', function() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('acnh_sound_enabled', soundEnabled);
            
            // Add a small animation effect on click
            soundToggleBtnMobile.style.transform = 'scale(0.9)';
            setTimeout(() => {
              soundToggleBtnMobile.style.transform = 'scale(1)';
            }, 100);
            
            // Update the image based on sound state
            if (soundImg) {
              soundImg.src = soundEnabled ? 'images/speaker.png' : 'images/speaker-mute.png';
              soundImg.alt = soundEnabled ? 'Sound On' : 'Sound Off';
            }
          });
        }
    </script>
    
    <!-- Desktop Buttons (hidden on mobile) -->
    <div class="nav-container" style="
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      z-index: 1000;
      background-color: #4a90e2;
      padding: 8px 12px;
      border-radius: 6px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease !important;
      display: none; /* Hide on mobile */">
      <button id="admin-toggle-btn" style="
        background-color: #4a90e2;
        color: white;
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-family: 'CustomFont', Arial, sans-serif;
        transition: background-color 0.3s ease;
        display: none; /* Hide on mobile */">
        Show Admin Tools
      </button>
      <button id="logoutBtn" style="
        background-color: #4a90e2;
        color: white;
        padding: 8px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-family: 'CustomFont', Arial, sans-serif;
        transition: background-color 0.3s ease;
        display: none; /* Hide on mobile */">Home</button>
    </div>

    <style>
      #admin-toggle-btn:hover {
        background-color: #357abd !important;
      }

      /* Start Game Button Hover Effect */
      #start-game-btn {
        transition: background-color 0.3s ease !important;
      }

      #start-game-btn:hover {
        background-color: #45a049 !important;
      }

      /* Back to Home Button Hover Effect */
      .logout-btn {
        transition: background-color 0.3s ease !important;
      }

      .logout-btn:hover {
        background-color: #357abd !important;
      }
    </style>

    <div
      id="greeting"
      style="position: absolute; top: 10px; left: 10px; font-weight: bold"
    ></div>
    

    
    <!-- Main Content Wrapper -->
    <div id="admin-tools-container" style="display: none; margin: 10px auto; max-width: 300px; padding: 20px; background: rgba(255, 255, 255, 0.95); border-radius: 8px; box-shadow: 0 2px 15px rgba(0,0,0,0.15);">
      <h2 style="margin: 0 0 15px 0; text-align: center; color: #5a3d2b; font-size: 1.5em;">Admin Tools</h2>
      <div style="display: flex; flex-direction: column; gap: 12px;">
        <button id="simulate-score-btn" style="width: 100%; padding: 10px; margin: 0;">Simulate High Score</button>
        <button id="reset-fish-btn" style="width: 100%; padding: 10px; margin: 0;">Reset Fish</button>
        <button id="reset-bugs-btn" style="width: 100%; padding: 10px; margin: 0;">Reset Bugs</button>
        <button id="reset-sea-btn" style="width: 100%; padding: 10px; margin: 0;">Reset Sea</button>
        <button id="reset-villagers-btn" style="width: 100%; padding: 10px; margin: 0;">Reset Villagers</button>
        <button id="reset-to-defaults-btn" style="width: 100%; padding: 10px; margin: 0; background-color: #4a90e2; color: white;">Reset All Leaderboards</button>
        <button id="reset-high-score" style="width: 100%; padding: 10px; margin: 0; background-color: #ffa500; color: white;">Reset Personal Best</button>
      </div>
    </div>

    <div style="width: 100%; display: flex; flex-direction: column; align-items: center;">
      <!-- Game Container -->
      <div id="game-container" class="mobile-container">
      <div class="nav-container" style="
        position: absolute;
        top: 10px;
        left: 10px;
        display: flex;
        gap: 10px;
        align-items: center;
        z-index: 1000;
        background-color: #4a90e2;
        padding: 8px 12px;
        border-radius: 6px;
        color: white;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.3s ease !important;
        display: none; /* Hide on mobile */">
        <button id="admin-toggle-btn" style="
          background: none;
          border: none;
          cursor: pointer;
          padding: 0;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background-color: transparent;
          transition: transform 0.2s ease;
          position: absolute;
          z-index: 1000;
          display: none; /* Hide on mobile */">
          <img src="images/admin.png" alt="Nook" style="width: 40px; height: 40px; border-radius: 50%;">
        </button>
        <button id="sound-toggle" style="
          background: none;
          border: none;
          cursor: pointer;
          padding: 0;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background-color: rgba(255, 255, 255, 0.3);
          transition: all 0.2s ease;
          position: relative;
          margin: 0 auto;
          display: none; /* Hide on mobile */
          display: flex;
          align-items: center;
          justify-content: center;">
          <img src="images/speaker.png" alt="Sound" style="width: 28px; height: 28px; transition: all 0.2s ease;">
        </button>
        <button id="logoutBtn" style="
          background: none;
          border: none;
          border-radius: 50%;
          cursor: pointer;
          width: 40px;
          height: 40px;
          padding: 0;
          background-color: rgba(255, 255, 255, 0.3);
          transition: all 0.2s ease;
          display: none; /* Hide on mobile */
          align-items: center;
          justify-content: center;
          margin-left: 10px;">
          <img src="images/home.png" alt="Home" style="width: 28px; height: 28px; transition: all 0.2s ease;">
        </button>
      </div>
      
      <h1 style="
        font-size: 1.8rem;
        margin: 10px 0 20px;
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        background: linear-gradient(90deg, 
          #ff0000 0%,
          #ff7e00 10%,
          #ffff00 20%,
          #00ff00 30%,
          #00ffff 40%,
          #0000ff 50%,
          #8b00ff 60%,
          #ff00ff 70%,
          #ff0000 80%
        );
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: rainbow 2s linear infinite;
      ">Animal Crossing: New Horizons<br>Identifier Game</h1>
      <div id="category-selector" class="category-container" style="display: flex; flex-direction: column; align-items: center; gap: 10px; margin: 10px 0; width: 100%;">
        <div style="display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 200px;">
          <label for="category" style="margin-bottom: 5px; font-size: 0.9rem; width: 100%; text-align: center;">Category</label>
          <select id="category" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #8b4513; font-size: 0.9rem; min-width: 0;">
            <option value="fish">Fish</option>
            <option value="bugs">Bugs</option>
            <option value="sea">Sea Creatures</option>
            <option value="villagers">Villagers</option>
          </select>
        </div>
        
        <div style="display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 200px;">
          <label for="difficulty" style="margin-bottom: 5px; font-size: 0.9rem; width: 100%; text-align: center;">Difficulty</label>
          <select id="difficulty" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #8b4513; font-size: 0.9rem; min-width: 0;">
            <option value="15000">Easy (15s)</option>
            <option value="10000">Medium (10s)</option>
            <option value="5000">Hard (5s)</option>
          </select>
        </div>
      </div>
      <div class="high-score-container">
        <div id="high-score">Personal Best: 0</div>
        <button id="start-game-btn" style="background-color: #4CAF50;">Start Game</button>
      </div>
      
      <div class="sound-settings" style="margin-top: 10px; display: flex; justify-content: center; align-items: center;">
      </div>
      <div class="score-container">
        <div class="mobile-timer-wrapper">
          <div class="timer-container">
            <div id="timer" class="timer">Time: 15</div>
          </div>
          <div id="score">Score: 0</div>
        </div>
      </div>
      <div class="loading-leaf"></div>
      <img id="imageDisplay" src="" alt="Loading..." />

      <div id="feedback" aria-live="polite"></div>

      <input
        type="text"
        id="guess-input"
        placeholder="Enter your guess..."
        autocomplete="off"
        disabled
        style="display: none"
      />
      <button id="submit-guess" style="display: none">Submit</button>
      <button id="next-btn" style="display: none">Next Item</button>
      <button id="try-again-btn" style="display: none">Try Again</button>
      <button id="end-game-btn" style="background-color: #ff6b6b; margin-top: 20px; display: none">End Game</button>
    </div>

    </div>
    
    <!-- Leaderboards Container -->
    <div id="leaderboards-container" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 25px; margin: 20px auto; max-width: 1400px; padding: 10px;">
      <!-- Fish Leaderboard -->
      <div class="leaderboard-card fish-leaderboard">
        <div class="leaderboard-header">
          <span class="category-icon"><img src="images/Fish_Icon.png" alt="Fish" style="width: 48px; height: 48px; vertical-align: middle; margin-right: 5px;"></span>
          <h3 class="leaderboard-category"></h3>
        </div>
        <div id="fish-scores" class="leaderboard-scores"></div>
      </div>
      
      <!-- Bugs Leaderboard -->
      <div class="leaderboard-card bugs-leaderboard">
        <div class="leaderboard-header">
          <span class="category-icon"><img src="images/Bug_Icon.png" alt="Bugs" style="width: 48px; height: 48px; vertical-align: middle; margin-right: 5px;"></span>
          <h3 class="leaderboard-category"></h3>
        </div>
        <div id="bugs-scores" class="leaderboard-scores"></div>
      </div>
      
      <!-- Sea Creatures Leaderboard -->
      <div class="leaderboard-card sea-leaderboard">
        <div class="leaderboard-header">
          <span class="category-icon"><img src="images/Sea_Creature_Icon.png" alt="Sea Creatures" style="width: 48px; height: 48px; vertical-align: middle; margin-right: 5px;"></span>
          <h3 class="leaderboard-category"></h3>
        </div>
        <div id="sea-scores" class="leaderboard-scores"></div>
      </div>
      
      <!-- Villagers Leaderboard -->
      <div class="leaderboard-card villagers-leaderboard">
        <div class="leaderboard-header">
          <span class="category-icon"><img src="images/Cat_Silhouette.png" alt="Villagers" style="width: 36px; height: 36px; vertical-align: middle; margin-right: 5px; filter: invert(1);"></span>
          <h3 class="leaderboard-category"></h3>
        </div>
        <div id="villagers-scores" class="leaderboard-scores">
          <ul class="leaderboard-list">
            <!-- leaderboard items will be generated here -->
          </ul>
        </div>
      </div>
    </div>

    <style>
      /* Leaderboard Styles */
      .leaderboard-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      
      .leaderboard-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid rgba(0,0,0,0.05);
      }
      
      .name {
        flex-grow: 1;
        text-align: left;
        padding-right: 10px;
        color: #2c3e50;
        font-weight: 500;
      }
      
      .score {
        text-align: right;
        font-weight: bold;
        color: #2c3e50;
        min-width: 50px;
      }
      
      .leaderboard-card {
        flex: 1;
        min-width: 280px;
        max-width: 320px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 16px;
        padding: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        position: relative;
        overflow: hidden;
        border: 3px solid;
      }

      .leaderboard-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 8px;
        background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.7) 50%, transparent 100%);
      }

      .leaderboard-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      }

      .leaderboard-header {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px dashed;
      }

      .category-icon {
        font-size: 28px;
        margin-right: 12px;
        filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2));
      }

      .leaderboard-category {
        margin: 0;
        font-size: 20px;
        font-weight: bold;
        color: #2c3e50;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
      }

      .leaderboard-scores {
        max-height: 400px;
        overflow-y: auto;
        padding-right: 5px;
      }

      /* Custom styles for each category */
      .fish-leaderboard {
        border-color: #4a90e2;
        background: linear-gradient(145deg, #f0f8ff, #e1f0ff);
      }
      .fish-leaderboard .leaderboard-header {
        border-color: #4a90e2;
      }

      .bugs-leaderboard {
        border-color: #8bc34a;
        background: linear-gradient(145deg, #f1f8e9, #e8f5e9);
      }
      .bugs-leaderboard .leaderboard-header {
        border-color: #8bc34a;
      }

      .sea-leaderboard {
        border-color: #00bcd4;
        background: linear-gradient(145deg, #e0f7fa, #b2ebf2);
      }
      .sea-leaderboard .leaderboard-header {
        border-color: #00bcd4;
      }

      .villagers-leaderboard {
        border-color: #ff9800;
        background: linear-gradient(145deg, #fff3e0, #ffe0b2);
      }
      .villagers-leaderboard .leaderboard-header {
        border-color: #ff9800;
      }

      /* Custom scrollbar */
      .leaderboard-scores::-webkit-scrollbar {
        width: 6px;
      }

      .leaderboard-scores::-webkit-scrollbar-track {
        background: rgba(0,0,0,0.05);
        border-radius: 3px;
      }

      .leaderboard-scores::-webkit-scrollbar-thumb {
        background: rgba(0,0,0,0.2);
        border-radius: 3px;
      }

      .leaderboard-scores::-webkit-scrollbar-thumb:hover {
        background: rgba(0,0,0,0.3);
      }

      /* Responsive adjustments */
      @media (max-width: 1200px) {
        .leaderboard-card {
          min-width: calc(50% - 30px);
        }
      }

      @media (max-width: 768px) {
        .leaderboard-card {
          min-width: 100%;
          max-width: 100%;
        }
      }
    </style>
    <!-- High Score Modal -->
    <div id="highScoreModal" class="modal">
      <div class="modal-content">
        <h2 style="color: #2c3e50;">New High Score!</h2>
        <p style="color: #34495e;">ðŸŽ‰ Congratulations! You scored <span id="finalScore" style="font-weight: bold; color: #2c3e50;"></span> points! ðŸŽ‰</p>
        <div id="placementMessage"></div>
        <p style="color: #2c3e50; font-weight: 500; margin-top: 15px;">ðŸ† Enter your name for the leaderboard:</p>
        <input type="text" id="playerName" placeholder="Your name" maxlength="10" style="width: 150px; padding: 8px; font-size: 14px;" />
        <div class="modal-buttons">
          <button id="submitScore" class="modal-btn submit-btn">Submit</button>
          <button id="skipSubmit" class="modal-btn skip-btn">Skip</button>
        </div>
      </div>
    </div>

    <script>
      const NOOKIPEDIA_API_KEY = "8a10f688-39d6-40b8-8426-744f30542e94"; // API key
      const apiEndpoint = "https://api.nookipedia.com";
      const apiVersion = "1.0.0";
      const imageDisplay = document.getElementById("imageDisplay");
      const guessInput = document.getElementById("guess-input");
      const submitButton = document.getElementById("submit-guess");
      const nextButton = document.getElementById("next-btn");
      const scoreElement = document.getElementById("score");
      const highScoreElement = document.getElementById("high-score");
      const difficultySelector = document.getElementById("difficulty");
      const logoutBtn = document.getElementById("logoutBtn");
      const adminToggleBtn = document.getElementById("admin-toggle-btn");
      const adminToolsContainer = document.getElementById("admin-tools-container");
      
      // Sound elements
      const correctSound = document.getElementById("correct-sound");
      const wrongSound = document.getElementById("wrong-sound");
      const gameOverSound = document.getElementById("game-over-sound");
      const startGameSound = document.getElementById("start-game-sound");
      const highScoreSound = document.getElementById("high-score-sound");
      
      // Sound settings
      let soundEnabled = false; // Default sound is off
      
      // Sound manager function
      function playSound(sound) {
        if (soundEnabled && sound) {
          // Reset the sound to the beginning if it's already playing
          sound.pause();
          sound.currentTime = 0;
          // Play the sound
          sound.play().catch(error => {
            logger.error('Error playing sound');
          });
        }
      }

    // Admin tools toggle with secret activation pattern
    const requiredClicks = 5;
    const timeWindow = 3000; // 3 seconds in milliseconds
    let clickCount = 0;
    
    adminToggleBtn.addEventListener("click", () => {
      // Increment click counter
      clickCount++;
      
      // Add a small animation effect on click
      adminToggleBtn.style.transform = 'scale(0.9)';
      setTimeout(() => {
        adminToggleBtn.style.transform = 'scale(1)';
      }, 100);
      
      // Clear existing timer if it exists
      if (clickTimer) {
        clearTimeout(clickTimer);
      }
      
      // Set new timer to reset counter after timeWindow
      clickTimer = setTimeout(() => {
        clickCount = 0;
      }, timeWindow);
      
      // Check if we've reached the required number of clicks within the time window
      if (clickCount >= requiredClicks) {
        // Reset counter
        clickCount = 0;
        
        // Toggle admin tools
        const isHidden = adminToolsContainer.style.display === "none";
        adminToolsContainer.style.display = isHidden ? "block" : "none";
        
        // Add a subtle notification that admin mode is activated/deactivated
        const notification = document.createElement('div');
        notification.textContent = isHidden ? 'Admin Mode Activated' : 'Admin Mode Deactivated';
        notification.style.position = 'fixed';
        notification.style.top = '50px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.backgroundColor = '#4a90e2';
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '5px';
        notification.style.zIndex = '9999';
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.3s ease';
        document.body.appendChild(notification);
        
        // Show and then fade out the notification
        setTimeout(() => {
          notification.style.opacity = '1';
          setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
              document.body.removeChild(notification);
            }, 300);
          }, 2000);
        }, 10);
      }
    });

    // Add event listener for sound toggle button
    const soundToggleBtn = document.getElementById('sound-toggle');
    soundToggleBtn.addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      soundToggleBtn.innerHTML = soundEnabled ? 'ðŸ”Š Sound: ON' : 'ðŸ”‡ Sound: OFF';
      soundToggleBtn.style.backgroundColor = soundEnabled ? '#4a90e2' : '#cccccc';
      
      // Save sound preference to localStorage
      localStorage.setItem('acnh_sound_enabled', soundEnabled.toString());
    });
    
    // Load sound preference from localStorage
    const savedSoundPreference = localStorage.getItem('acnh_sound_enabled');
    if (savedSoundPreference !== null) {
      soundEnabled = savedSoundPreference === 'true';
      soundToggleBtn.innerHTML = soundEnabled ? 'ðŸ”Š Sound: ON' : 'ðŸ”‡ Sound: OFF';
      soundToggleBtn.style.backgroundColor = soundEnabled ? '#4a90e2' : '#cccccc';
    }

      // Prevent right-click and dragging on image
      imageDisplay.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        return false;
      });

      // Prevent image dragging
      imageDisplay.addEventListener('dragstart', (e) => {
        e.preventDefault();
        return false;
      });
      imageDisplay.addEventListener('drag', (e) => {
        e.preventDefault();
        return false;
      });

      const leaderboardElement = document.getElementById("leaderboard");

      const urlParams = new URLSearchParams(window.location.search);
      const isGuest = urlParams.get("guest") === "true";

      if (isGuest) {
        logoutBtn.textContent = "Back to Home";
      }

      logoutBtn.addEventListener("click", () => {
        localStorage.removeItem("acnh_current_score");
        localStorage.removeItem("acnh_last_category");
        window.location.href = "index.html";
      });

      let score = 0;
      let highScore = localStorage.getItem("acnh_high_score") || 0;
      let currentItem = null;
      let currentCategory = null;
      let shownItems = {}; // Object to track shown items for each category
      let allItems = {}; // Store all items for each category
      let availableItems = []; // Current available items for the category
      let timerInterval = null;
      let timeLeft = 15; // Default to easy mode (15s)
      let maxTime = 15; // Will be updated based on difficulty
      let isLoadingItems = false; // Track if we're currently loading items
      let lastLoadedCategory = null; // Track the last loaded category
      let gameOver = false; // Flag to track if the game is over
      let currentlyDisplayingItem = null; // Track which item is being displayed
      let isTryingFallback = false; // Flag to prevent recursive fallback calls
      const timerDisplay = document.getElementById('timer');

      async function loadCategoryItems(category) {
        // If we've already loaded this category and have items, use them
        if (allItems[category]?.length > 0) {
          logger.debug(`Using cached items for ${category}`);
          return allItems[category];
        }
        
        // If we're already loading this category, wait for it to complete
        if (isLoadingItems) {
          logger.debug(`Already loading ${category}, waiting...`);
          // Wait with multiple retries before timing out
          for (let i = 0; i < 10; i++) { // Try up to 10 times (1 second total)
            await new Promise(resolve => setTimeout(resolve, 100));
            if (allItems[category]?.length > 0) {
              return allItems[category];
            }
          }
          // If we still don't have items after waiting, use fallback data
          logger.debug(`Timeout waiting for ${category} to load, using fallback data`);
          return getFallbackData(category);
        }
        
        // Set loading flag
        isLoadingItems = true;
        
        // Define the API endpoint based on the category
        let endpoint = "";
        switch (category) {
          case "fish":
            endpoint = "/nh/fish";
            break;
          case "bugs":
            endpoint = "/nh/bugs";
            break;
          case "sea":
            endpoint = "/nh/sea";
            break;
          case "villagers":
            endpoint = "/villagers";
            break;
          default:
            logger.error(`Invalid category: ${category}`);
            isLoadingItems = false;
            return [];
        }
        
        // Use the Nookipedia API to get the items
        const apiKey = NOOKIPEDIA_API_KEY;
        const apiUrl = `${apiEndpoint}${endpoint}`;
        
        try {
          // Show loading leaf indicator
          const loadingLeaf = document.querySelector('.loading-leaf');
          if (loadingLeaf) loadingLeaf.style.display = 'block';
          
          // Attempt to fetch from API with a timeout to prevent long waits
          try {
            const response = await fetchWithTimeout(apiUrl, {
              headers: {
                "X-API-KEY": apiKey,
                "Accept-Version": apiVersion
              }
            });
            
            if (!response || !response.length) {
              logger.debug(`API returned empty data for ${category}, using fallback data`);
              throw new Error(`API request failed or returned empty data`);
            }
            
            logger.debug(`Loaded ${response.length} items for ${category} from API`);
            
            // Update last loaded category and clear loading flag
            lastLoadedCategory = category;
            isLoadingItems = false;
            
            // Process the data to ensure consistent format
            const processedItems = response.map(item => {
              return {
                name: item.name,
                image_url: item.image_url || null,
                // Add fallback image in case the API image fails to load
                fallback_image_url: `images/${category}/placeholder.svg`
              };
            });
            
            // Store the items in our global object
            allItems[category] = processedItems;
            
            // Initialize shown items for this category if it doesn't exist
            if (!shownItems[category]) {
              shownItems[category] = [];
            }
            
            // Hide loading indicators
            if (loadingLeaf) loadingLeaf.style.display = 'none';
            feedbackElement.textContent = "";
            
            return processedItems;
          } catch (error) {
            logger.error("Error fetching from API");
            throw error; // Let the outer catch block handle it
          }
          
        } catch (error) {
          logger.error("Error loading items from API");
          isLoadingItems = false; // Clear loading flag on error
          
          // Fallback to previously cached data if available
          if (allItems[category] && allItems[category].length > 0) {
            logger.debug(`Using cached items for ${category} due to API error`);
            return allItems[category];
          }
          
          // Hide loading indicators
          const loadingLeaf = document.querySelector('.loading-leaf');
          if (loadingLeaf) loadingLeaf.style.display = 'none';
          
          // Show error message
          feedbackElement.textContent = "Could not load items from API. Using local data.";
          
          // Use fallback data
          return getFallbackData(category);
        }
      }
      
      // Function to provide fallback data when API fails
      function getFallbackData(category) {
        logger.debug(`Using fallback data for ${category}`);
        // Store the fallback data in our global object so we don't try to fetch again
        if (!allItems[category]) {
          // Fallback to local data if API fails
          const mockData = {
          fish: [
            { name: "Sea Bass", image_url: "https://dodo.ac/np/images/d/d5/Sea_Bass_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Koi", image_url: "https://dodo.ac/np/images/7/7c/Koi_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Goldfish", image_url: "https://dodo.ac/np/images/a/a5/Goldfish_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Tuna", image_url: "https://dodo.ac/np/images/8/8c/Tuna_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Coelacanth", image_url: "https://dodo.ac/np/images/4/45/Coelacanth_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" }
            ],
            bugs: [
              { name: "Common Butterfly", image_url: "https://dodo.ac/np/images/8/8f/Common_Butterfly_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Monarch Butterfly", image_url: "https://dodo.ac/np/images/a/a9/Monarch_Butterfly_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Scorpion", image_url: "https://dodo.ac/np/images/6/6f/Scorpion_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Tarantula", image_url: "https://dodo.ac/np/images/0/0e/Tarantula_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Stinkbug", image_url: "https://dodo.ac/np/images/b/b4/Stinkbug_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" }
            ],
            sea: [
              { name: "Sea Star", image_url: "https://dodo.ac/np/images/1/1d/Sea_Star_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Sea Urchin", image_url: "https://dodo.ac/np/images/b/b9/Sea_Urchin_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Seaweed", image_url: "https://dodo.ac/np/images/5/53/Seaweed_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Pearl Oyster", image_url: "https://dodo.ac/np/images/1/11/Pearl_Oyster_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Scallop", image_url: "https://dodo.ac/np/images/d/d5/Scallop_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" }
            ],
            villagers: [
              { name: "Tom Nook", image_url: "https://dodo.ac/np/images/4/4f/Tom_Nook_NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "Isabelle", image_url: "https://dodo.ac/np/images/8/8e/Isabelle_NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "K.K. Slider", image_url: "https://dodo.ac/np/images/e/e0/K.K._NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "Blathers", image_url: "https://dodo.ac/np/images/b/b3/Blathers_NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "Celeste", image_url: "https://dodo.ac/np/images/9/93/Celeste_NH.png", fallback_image_url: "images/villagers/placeholder.svg" }
            ]
          };
          
          // Store the mock data for the selected category
          allItems[category] = mockData[category] || [];
          
          // Initialize shown items for this category if it doesn't exist
          if (!shownItems[category]) {
            shownItems[category] = [];
          }
          
          return allItems[category];
        }
      }

      function getAvailableItems(category) {
        if (!allItems[category]) {
          return [];
        }
        
        const shown = shownItems[category] || [];
        return allItems[category].filter(item => !shown.includes(item.name));
      }

      async function getRandomItem(category) {
        if (!category || typeof category !== 'string') {
          logger.error('Invalid category');
          return null;
        }

        try {
          // If we don't have items for this category, try to load them first
          if (!allItems[category] || !Array.isArray(allItems[category])) {
            logger.debug(`Loading items for category: ${category}`);
            await loadCategoryItems(category);
            
            // If still no items after loading, use fallback data
            if (!allItems[category] || !Array.isArray(allItems[category])) {
              logger.error(`Failed to load items for category: ${category}`);
              return null;
            }
          }

          // Get available items that haven't been shown yet
          const available = getAvailableItems(category);
          
          // If no items available, reset the shown items and try again
          if (available.length === 0) {
            logger.debug(`No available items for ${category}, resetting shown items`);
            shownItems[category] = [];
            localStorage.setItem(`shown_items_${category}`, JSON.stringify([]));
            
            // Get fresh available items after reset
            const freshAvailable = getAvailableItems(category);
            if (freshAvailable.length === 0) {
              logger.error('No items available even after reset');
              return null;
            }
            return freshAvailable[0]; // Return the first available item
          }

          // Get a random item from the available items
          const randomIndex = Math.floor(Math.random() * available.length);
          const item = available[randomIndex];

          if (!item) {
            logger.error('No valid item found in available items');
            return null;
          }

          // Add this item to the shown items list
          if (!shownItems[category]) {
            shownItems[category] = [];
          }
          shownItems[category].push(item.name);
          localStorage.setItem(`shown_items_${category}`, JSON.stringify(shownItems[category]));
          
          return item;
        } catch (error) {
          logger.error('Error in getRandomItem');
          return null;
        }

        try {
          // First try to use the image URL from the item object if it exists
          if (item.image_url) {
            return {
              name: item.name,
              image_url: item.image_url
            };
          }
          
          // Otherwise try to fetch from API
          const imageUrl = `${apiEndpoint}/nh/${category}/${item.name}?api_key=${NOOKIPEDIA_API_KEY}`;
          const imageData = await fetchWithTimeout(imageUrl);
          
          if (imageData && imageData.data && imageData.data.image_url) {
            return {
              name: item.name,
              image_url: imageData.data.image_url
            };
          }
          
          // If API fetch fails, use fallback image
          return {
            name: item.name,
            image_url: item.fallback_image_url || `images/${category}/placeholder.svg`
          };
        } catch (error) {
          console.error('Error fetching image for item:', item.name, error);
          // Return the item with fallback image
          return {
            name: item.name,
            image_url: item.fallback_image_url || `images/${category}/placeholder.svg`
          };
        }
      }

      function showHighScoreModal(finalScore, category) {
        // Play high score sound if available
        const highScoreSound = document.getElementById('high-score-sound');
        if (highScoreSound) {
          highScoreSound.currentTime = 0;
          highScoreSound.play().catch(e => logger.warn('Could not play high score sound'));
        }
        
        // Set the final score in the modal
        const finalScoreElement = document.getElementById('finalScore');
        if (finalScoreElement) {
          finalScoreElement.textContent = finalScore;
        }
        
        // Show the modal
        const modal = document.getElementById('highScoreModal');
        if (modal) {
          modal.style.display = 'block';
          
          // Store category for later use
          modal.dataset.category = category;
          
          // Focus on the name input
          const playerNameInput = document.getElementById('playerName');
          if (playerNameInput) {
            playerNameInput.value = '';
            playerNameInput.focus();
            
            // Allow Enter key to submit
            playerNameInput.onkeypress = function(e) {
              if (e.key === 'Enter') {
                submitHighScore(finalScore, category);
              }
            };
          }
          
          // Add event listeners for the buttons
          const submitButton = document.getElementById('submitScore');
          if (submitButton) {
            submitButton.onclick = function() {
              submitHighScore(finalScore, category);
            };
          }
          
          const skipButton = document.getElementById('skipSubmit');
          if (skipButton) {
            skipButton.onclick = closeHighScoreModal;
          }
        }
      }
      
      function closeHighScoreModal() {
        document.getElementById('highScoreModal').style.display = 'none';
      }
      
      async function submitHighScore(playerName, finalScore, category) {
        // Validate inputs
        if (!playerName || typeof playerName !== 'string' || playerName.trim() === '') {
          // Try to get a name from the input field
          const nameInput = document.getElementById('playerName');
          if (nameInput && nameInput.value && nameInput.value.trim() !== '') {
            playerName = nameInput.value.trim();
          } else {
            // If no input field is found, use a default name
            playerName = 'Player';
          }
        }
        
        // Get the current username from localStorage or sessionStorage
        const username = localStorage.getItem('username') || sessionStorage.getItem('username') || playerName;
        
        // Check if we're in offline mode
        if (isStandaloneMode()) {
          // Always confirm before switching to standalone mode
          if (!localStorage.getItem('standalone_confirmed_this_session')) {
            if (confirm("Server connection unavailable. Your scores will be saved locally but not shared online. Continue in offline mode?")) {
              // Set a session flag to avoid multiple prompts in the same session
              localStorage.setItem('standalone_confirmed_this_session', 'true');
              localStorage.setItem('force_standalone', 'true');
            } else {
              // User declined standalone mode, redirect to index
              window.location.href = 'index.html';
              return;
            }
          }
          console.log('Running in offline mode, saving score to local storage only');
          saveScoreToLocalStorage(playerName, finalScore, category);
          return;
        }
        
        try {
          // Get the JWT token for authentication
          const token = localStorage.getItem('token') || sessionStorage.getItem('token');
          
          // Get guest token from localStorage or generate a new one
          let guestToken = localStorage.getItem('guestToken');
          if (!guestToken) {
            guestToken = 'guest_' + Math.random().toString(36).substring(2, 11);
            localStorage.setItem('guestToken', guestToken);
          }
          
          console.log(`Submitting score for ${category} with guest token: ${guestToken.substring(0, 5)}...`);
          
          // Prepare headers
          const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          };
          
          // Add authorization if available
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
          } else if (guestToken) {
            headers['Authorization'] = `Bearer ${guestToken}`;
            headers['X-Guest-Token'] = guestToken;
          }
          
          // Prepare the request body
          const requestBody = {
            name: playerName,
            score: finalScore,
            category: category
          };
          
          // Submit the score
          const response = await fetch(`${window.BACKEND_API}/submit-guest-score`, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody),
            credentials: 'include',
            mode: 'cors'
          });
          
          if (response.ok) {
            const data = await response.json();
            console.log('Score submitted successfully:', data);
            
            // Update the leaderboard
            loadLeaderboardData(category);
            
            // Close the modal
            closeHighScoreModal();
            
            return data;
          } else if (response.status === 401) {
            // Handle unauthorized - generate a new guest token and retry once
            console.warn('Unauthorized when submitting score, generating new guest token');
            const newGuestToken = 'guest_' + Math.random().toString(36).substring(2, 11);
            localStorage.setItem('guestToken', newGuestToken);
            
            // Try one more time with the new token
            console.log(`Retrying score submission with new token: ${newGuestToken.substring(0, 5)}...`);
            
            headers['Authorization'] = `Bearer ${newGuestToken}`;
            headers['X-Guest-Token'] = newGuestToken;
            
            const retryResponse = await fetch(`${window.BACKEND_API}/submit-guest-score`, {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(requestBody),
              credentials: 'include',
              mode: 'cors'
            });
            
            if (retryResponse.ok) {
              const retryData = await retryResponse.json();
              console.log('Score submitted successfully on retry:', retryData);
              
              // Update the leaderboard
              loadLeaderboardData(category);
              
              // Close the modal
              closeHighScoreModal();
              
              return retryData;
            } else {
              // If retry fails, save locally
              console.warn('Retry failed, saving score to local storage');
              saveScoreToLocalStorage(playerName, finalScore, category);
              
              // Close the modal
              closeHighScoreModal();
            }
          } else {
            // Handle other error responses
            const errorText = await response.text();
            console.error('Error submitting score:', response.status, errorText);
            
            // Save locally for any other errors
            console.warn('API error, saving score to local storage');
            saveScoreToLocalStorage(playerName, finalScore, category);
            
            // Close the modal
            closeHighScoreModal();
          }
        } catch (error) {
          console.error('Error submitting score:', error);
          
          // Fall back to local storage
          console.log('Falling back to local storage for score');
          saveScoreToLocalStorage(playerName, finalScore, category);
          
          // Close the modal
          closeHighScoreModal();
        }
      }
      
      // Helper function to save score to localStorage and show placement
      function saveScoreToLocalStorage(playerName, finalScore, category) {
        // Get existing leaderboard data
        const savedLeaderboard = localStorage.getItem('acnh_leaderboard');
        let leaderboardData = {};
        
        if (savedLeaderboard) {
          try {
            leaderboardData = JSON.parse(savedLeaderboard);
          } catch (e) {
            console.error('Error parsing saved leaderboard:', e);
            leaderboardData = { ...DEFAULT_LEADERBOARD };
          }
        } else {
          leaderboardData = { ...DEFAULT_LEADERBOARD };
        }
        
        // Add the new score
        const newScore = {
            name: playerName,
            score: finalScore,
            date: new Date().toISOString().split('T')[0], // Format: YYYY-MM-DD
            isNew: true // Mark this as a new score for highlighting
        };
        
        // Add to the appropriate category
        if (!leaderboardData[category]) {
            leaderboardData[category] = [];
        }
        
        leaderboardData[category].push(newScore);
        
        // Sort scores in descending order
        leaderboardData[category].sort((a, b) => b.score - a.score);
        
        // Keep only top 10 scores
        leaderboardData[category] = leaderboardData[category].slice(0, 10);
        
        // Save the updated leaderboard to localStorage
        localStorage.setItem('acnh_leaderboard', JSON.stringify(leaderboardData));
        
        // Find the placement of the new score
        const placement = leaderboardData[category].findIndex(score => score.name === playerName && score.score === finalScore) + 1;
        
        // Show placement message
        showPlacementMessage(placement);
        
        // Close the modal
        closeHighScoreModal();
        
        // Update the displayed leaderboard
        updateLeaderboardUI(leaderboardData);
      }
      
      // Helper function to show placement message
      function showPlacementMessage(placement) {
        const placementMessage = document.getElementById('placementMessage');
        if (!placementMessage) return;
        
        if (placement === 1) {
          placementMessage.innerHTML = '<p style="color: #ffd700; font-weight: bold;">You achieved 1st place! ðŸ†</p>';
        } else if (placement === 2) {
          placementMessage.innerHTML = '<p style="color: #c0c0c0; font-weight: bold;">You achieved 2nd place! ðŸ¥ˆ</p>';
        } else if (placement === 3) {
          placementMessage.innerHTML = '<p style="color: #cd7f32; font-weight: bold;">You achieved 3rd place! ðŸ¥‰</p>';
        } else if (placement <= 10) {
          placementMessage.innerHTML = `<p>You made it to the top 10! (${placement}${getOrdinalSuffix(placement)})</p>`;
        } else {
          placementMessage.innerHTML = `<p>Your rank: ${placement}${getOrdinalSuffix(placement)}</p>`;
        }
      }
      
      // Helper function to get ordinal suffix (1st, 2nd, 3rd, etc.)
      function getOrdinalSuffix(num) {
        const j = num % 10, k = num % 100;
        if (j === 1 && k !== 11) return 'st';
        if (j === 2 && k !== 12) return 'nd';
        if (j === 3 && k !== 13) return 'rd';
        return 'th';
      }
      
      // Default leaderboard data
      const DEFAULT_LEADERBOARD = {
        fish: [
          { name: "Kapp'n", score: 10 },
          { name: "Leif", score: 9 },
          { name: "Cyrus", score: 8 },
          { name: "Kicks", score: 7 },
          { name: "Redd", score: 6 },
          { name: "Mabel", score: 5 },
          { name: "Saharah", score: 4 },
          { name: "Gulliver", score: 3 },
          { name: "Wisp", score: 2 },
          { name: "Harvey", score: 1 }
        ],
        bugs: [
          { name: "Flick", score: 10 },
          { name: "Cube", score: 9 },
          { name: "Kapp'n", score: 8 },
          { name: "Kiki", score: 7 },
          { name: "Cyrus", score: 6 },
          { name: "Kicks", score: 5 },
          { name: "Redd", score: 4 },
          { name: "Mabel", score: 3 },
          { name: "Saharah", score: 2 },
          { name: "Gulliver", score: 1 }
        ],
        sea: [
          { name: "Pascal", score: 10 },
          { name: "Kapp'n", score: 9 },
          { name: "Leif", score: 8 },
          { name: "Cyrus", score: 7 },
          { name: "Kicks", score: 6 },
          { name: "Redd", score: 5 },
          { name: "Mabel", score: 4 },
          { name: "Saharah", score: 3 },
          { name: "Gulliver", score: 2 },
          { name: "Wisp", score: 1 }
        ],
        villagers: [
          { name: "Tom Nook", score: 10 },
          { name: "Isabelle", score: 9 },
          { name: "Blathers", score: 8 },
          { name: "Celeste", score: 7 },
          { name: "Brewster", score: 6 },
          { name: "K.K. Slider", score: 5 },
          { name: "Sable", score: 4 },
          { name: "Label", score: 3 },
          { name: "Reese", score: 2 },
          { name: "Cyrus", score: 1 }
        ]
      };
      
      // Make it globally available
      window.DEFAULT_LEADERBOARD = DEFAULT_LEADERBOARD;
      
      // Initialize leaderboard with default data
      updateLeaderboardUI(DEFAULT_LEADERBOARD);


      async function initGame(category, isInitialLoad = false) {
        logger.debug(`Initializing game for category: ${category}`);
        let lastLoadTimestamp = 0; // Initialize lastLoadTimestamp
        
        try {
          // Prevent multiple initializations
          if (isLoadingItem) {
            return;
          }
          
          // Update current category
          currentCategory = category;
          localStorage.setItem("acnh_last_category", category);
          
          // Only show loading message if not the initial page load
          if (!isInitialLoad) {
            feedbackElement.textContent = "Loading...";
            feedbackElement.className = "";
          }
          
          // Disable input during initialization
          guessInput.disabled = true;
          submitButton.disabled = true;

          // If setupNewRound has been called recently, don't load a new item
          if (Date.now() - lastLoadTimestamp < 500 && currentItem && currentItem.name) {
            logger.debug(`Using recently loaded item: ${currentItem.name}`);
            // Just update the UI with the current item
            displayItem(currentItem);
            return;
          }
          
          // Load a new item
          const item = await getRandomItem(category);
          if (item) {
            // Set the current item and display it
            currentItem = item;
            displayItem(item);
            feedbackElement.textContent = '';
            scoreElement.textContent = `Score: ${score}`;
          } else {
            throw new Error('No item returned from getRandomItem');
          }
          
        } catch (error) {
          logger.error('Error in initGame');
          feedbackElement.textContent = 'Failed to load game items. Please try again.';
          feedbackElement.className = 'error';
          
          // Try to recover by resetting the category
          try {
            const recoveryCategory = categorySelector?.value || 'fish'; // Default to fish if selector not available
            if (recoveryCategory && allItems[recoveryCategory]) {
              logger.debug('Attempting to reset category data');
              delete allItems[recoveryCategory];
              await loadCategoryItems(recoveryCategory);
              await initGame(recoveryCategory, true);
            }
          } catch (recoveryError) {
            logger.error('Recovery failed');
          }
        } finally {
          // Re-enable input
          guessInput.disabled = false;
          submitButton.disabled = false;
        }
      }

      function updateHighScore() {
        const category = categorySelector.value;
        if (!category) return;

        // Get the current high score for this category
        const categoryKey = `acnh_high_score_${category}`;
        const currentHighScore = parseInt(localStorage.getItem(categoryKey) || '0', 10);

        let isNewPersonalBest = false;
        
        // Update category high score if new high
        if (score > currentHighScore) {
          localStorage.setItem(categoryKey, score);
          isNewPersonalBest = true;
          highScoreElement.textContent = `Personal Best: ${score}`;
        }

        // Update overall high score
        const overallHighScore = parseInt(localStorage.getItem('acnh_high_score') || '0', 10);
        if (score > overallHighScore) {
          localStorage.setItem('acnh_high_score', score);
        }
      }

      function updateScore(newScore) {
        score = newScore;
        localStorage.setItem('acnh_current_score', score);
        scoreElement.textContent = `Score: ${score}`;
      }

      async function fetchWithTimeout(resource, options = {}, timeout = 10000) { // Increased timeout to 10 seconds
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);

        try {
          const response = await fetch(resource, {
            ...options,
            signal: controller.signal,
          });
          clearTimeout(id);
          if (!response.ok) {
            logger.error(`Fetch failed with status: ${response.status}`);
            throw new Error(`Fetch failed with status: ${response.status}`);
          }
          return await response.json();
        } catch (error) {
          clearTimeout(id);
          logger.error(`Fetch error: ${error.message}`);
          return null;
        }
      }


      function startTimer() {
        // Don't start the timer if the game is over
        if (gameOver) {
          return;
        }
        
        // Clear any existing timer
        stopTimer();
        
        // Double-check game over state after stopping timer
        if (gameOver) {
          return;
        }
        
        // Get selected difficulty
        const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
        timeLeft = difficulty;
        maxTime = difficulty;
        
        timerDisplay.textContent = `Time: ${timeLeft}`;
        timerDisplay.classList.add('running');
        timerDisplay.classList.remove('warning', 'expired');
        
        // Store the start time for more accurate timing
        const startTime = Date.now();
        const endTime = startTime + (timeLeft * 1000);
        
        // Update timer immediately to avoid initial delay
        updateTimer();
        
        // Set up the timer with requestAnimationFrame for smoother updates
        function updateTimer() {
          // First check if game is over or timer should be stopped
          if (gameOver || timerInterval === null) {
            cancelAnimationFrame(timerInterval);
            timerInterval = null;
            return;
          }
          
          const now = Date.now();
          timeLeft = Math.max(0, Math.ceil((endTime - now) / 1000));
          
          timerDisplay.textContent = `Time: ${timeLeft}`;
          
          // Change color based on time remaining (warning at 30% of max time)
          const warningThreshold = Math.ceil(maxTime * 0.3);
          if (timeLeft <= warningThreshold) {
            timerDisplay.classList.add('warning');
            timerDisplay.classList.remove('running');
          }
          
          if (timeLeft <= 0) {
            // Properly stop the timer
            cancelAnimationFrame(timerInterval);
            timerInterval = null;
            
            // Update timer display
            timerDisplay.classList.add('expired');
            timerDisplay.classList.remove('warning', 'running');
            
            // Set game over flag
            gameOver = true;
            
            // Check if the score is a leaderboard high score
            const category = categorySelector.value;
            
            // Check for high scores regardless of the score value
            isHighScore(score, category).then(isHighEnough => {
              if (isHighEnough) {
                // Play high score sound first
                playSound(highScoreSound);
                showHighScoreModal(score, category);
              } else {
                // Play game over sound if not a high score
                playSound(gameOverSound);
              }
            });
            
            // Show game over message
            feedbackElement.textContent = `Game Over! Time's up! The answer was ${currentItem.name}. Final Score: ${score}`;
            feedbackElement.className = 'wrong';
            scoreElement.textContent = `Score: ${score}`;
            
            // Disable input and show try again button
            guessInput.disabled = true;
            submitButton.disabled = true;
            document.getElementById('try-again-btn').style.display = 'inline-block';
            
            // Update personal best scores in localStorage
            updateHighScore();
            
            return; // Exit the update loop
          }
          
          // Double-check game over state before scheduling next update
          if (!gameOver) {
            // Schedule the next update only if game is not over
            timerInterval = requestAnimationFrame(updateTimer);
          } else {
            timerInterval = null;
          }
        }
        
        // Start the timer loop
        timerInterval = requestAnimationFrame(updateTimer);
      }

      function stopTimer() {
        // Force cancel any existing animation frame
        if (timerInterval) {
          cancelAnimationFrame(timerInterval);
          timerInterval = null;
        }
        
        // Double check - use a direct global variable reference to ensure we're truly stopping all timers
        window.cancelAnimationFrame(timerInterval);
        timerInterval = null;
        
        // Reset timer display classes
        timerDisplay.classList.remove('running', 'warning');
        
        // Don't remove 'expired' class if the timer ran out or game is over (to keep the red color)
        if (timeLeft > 0 && !gameOver) {
          timerDisplay.classList.remove('expired');
        }
        
        // If game is over, make sure the timer stays stopped and update visual state
        if (gameOver) {
          timerInterval = null;
          timerDisplay.classList.add('expired');
        }
      }

      // Track the current loading state to prevent multiple simultaneous operations
      let isLoadingItem = false;
      
      async function displayItem(item) {
        // Validate input parameters
        if (!item || !item.name) {
          logger.error('Invalid item data');
          showPlaceholder('Invalid item data');
          return false;
        }
        
        // Check if we're already displaying this item to prevent duplicate calls
        if (currentlyDisplayingItem === item.name) {
          logger.debug(`Already displaying ${item.name}, skipping duplicate load`);
          return true;
        }
        
        // Set the currently displaying item to prevent race conditions
        currentlyDisplayingItem = item.name;
        
        // Get UI elements
        const imageDisplay = document.getElementById('imageDisplay');
        const loadingLeaf = document.querySelector('.loading-leaf');
        
        if (!imageDisplay) {
          logger.error('Image display element not found');
          return false;
        }
        
        // Show loading indicator
        if (loadingLeaf) loadingLeaf.style.display = 'block';
        imageDisplay.style.display = 'none';
        
        // Helper function to try loading an image
        const tryLoadImage = (url) => {
          return new Promise((resolve) => {
            if (!url) return resolve(false);
            
            const img = new Image();
            const timeout = setTimeout(() => {
              img.onload = img.onerror = null;
              resolve(false);
            }, 5000); // 5 second timeout
            
            img.onload = () => {
              clearTimeout(timeout);
              // Verify the image loaded correctly
              if (img.complete && img.naturalWidth > 0) {
                resolve(true);
              } else {
                resolve(false);
              }
            };
            
            img.onerror = () => {
              clearTimeout(timeout);
              resolve(false);
            };
            
            img.src = url;
          });
        };
        
        // Helper function to get fallback image path
        const getFallbackPath = () => {
          if (!item.name) return null;
          const safeName = item.name.toLowerCase().replace(/[^a-z0-9]/g, '');
          return `images/${currentCategory}/${safeName}.png`;
        };
            
        try {
          let success = false;
          
          // Try primary image URL first if available
          if (item.image_url) {
            logger.debug(`Loading primary image for ${item.name}`);
            success = await tryLoadImage(item.image_url);
            
            if (success) {
              imageDisplay.src = item.image_url;
            }
          }
          
          // If primary image failed, try fallback
          if (!success) {
            const fallbackPath = getFallbackPath();
            if (fallbackPath) {
              logger.debug(`Trying fallback image for ${item.name}`);
              success = await tryLoadImage(fallbackPath);
              
              if (success) {
                imageDisplay.src = fallbackPath;
              }
            }
          }
          
          // If we successfully loaded an image
          if (success) {
            imageDisplay.style.display = 'block';
            imageDisplay.alt = item.name;
            imageDisplay.title = item.name;
            imageDisplay.classList.add('loaded');
            
            // Start the timer now that the image is successfully loaded
            if (!gameOver) {
              const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
              timeLeft = difficulty;
              maxTime = difficulty;
              timerDisplay.textContent = `Time: ${timeLeft}`;
              timerDisplay.classList.remove('warning', 'expired');
              startTimer();
            }
            
            return true;
          }
          
          // If we get here, all image loading attempts failed
          logger.error(`Failed to load any image for: ${item.name}`);
          showPlaceholder(`${item.name} (Image unavailable)`);
          return false;
          
        } catch (error) {
          logger.error('Error in displayItem');
          showPlaceholder('Error loading image');
          return false;
          
        } finally {
          // Always hide loading indicator
          if (loadingLeaf) loadingLeaf.style.display = 'none';
          
          // If we're no longer displaying this item, clear the flag
          if (currentlyDisplayingItem === item.name) {
            currentlyDisplayingItem = null;
          }
        }
      }

      function showPlaceholder(text) {
        // Hide the image display
        imageDisplay.style.display = "none";
        
        // Create or find the placeholder element
        let placeholder = document.querySelector(".image-placeholder");
        if (!placeholder) {
          placeholder = document.createElement("div");
          placeholder.className = "image-placeholder";
          // Insert the placeholder before the image display
          imageDisplay.parentNode.insertBefore(placeholder, imageDisplay);
        }
        
        // Set the placeholder text and display it
        placeholder.textContent = text || "Image not available";
        placeholder.style.display = "block";
        
        logger.debug(`Showing placeholder: ${text}`);
      }

      async function setupNewRound() {
        // Reduced delay to 50ms to make next image load faster
        await new Promise(resolve => setTimeout(resolve, 50));
        
        // Check if we're already loading an item to prevent race conditions
        if (isLoadingItem) {
          // Force reset loading state if it's been stuck for too long (over 2 seconds)
          if (Date.now() - lastLoadTimestamp > 2000) {
            isLoadingItem = false;
          } else {
            return;
          }
        }
        
        try {
          // Set the loading flag to prevent concurrent operations
          isLoadingItem = true;
          
          // Disable input while loading to prevent race conditions
          guessInput.disabled = true;
          submitButton.disabled = true;
          
          // Clear previous state
          guessInput.value = "";
          feedbackElement.textContent = "Loading...";
          feedbackElement.className = "";
          nextButton.style.display = "none";
          
          // First, remove any existing event handlers from the image display to prevent stale events
          imageDisplay.onload = null;
          imageDisplay.onerror = null;
          
          // Reset the image display
          imageDisplay.src = '';
          imageDisplay.style.display = 'none';
          imageDisplay.classList.remove('loaded');
          
          // Reset the currently displaying item
          currentlyDisplayingItem = null;
          
          // Reset the trying fallback flag
          isTryingFallback = false;
          
          // Hide any existing placeholder
          const placeholder = document.querySelector(".image-placeholder");
          if (placeholder) {
            placeholder.style.display = "none";
          }
          
          // Show loading indicator
          const loadingLeaf = document.querySelector('.loading-leaf');
          if (loadingLeaf) {
            loadingLeaf.style.display = 'block';
          }

          // Get the current category
          const category = categorySelector.value;
          if (!category) {
            logger.error('No category selected');
            feedbackElement.textContent = 'Error: No category selected';
            isLoadingItem = false; // Release the lock
            return;
          }
          
          logger.debug(`Setting up new round for category: ${category}`);
          
          try {
            // Get a random item from the current category - await to ensure synchronization
            const item = await getRandomItem(category);
            
            if (item && item.name) {
              logger.debug(`Got item for display: ${item.name}`);
              
              // Set the current item BEFORE displaying it to ensure consistency
              currentItem = item;
              currentCategory = category;
              
              // Wait for the item to be displayed before enabling input
              await displayItem(item);
              
              // Update UI
              feedbackElement.textContent = '';
              scoreElement.textContent = `Score: ${score}`;
              
              // Re-enable input after everything is loaded
              guessInput.disabled = false;
              submitButton.disabled = false;
              guessInput.focus();
              
              logger.debug(`Ready for guessing. Current item is: ${currentItem.name}`);
            } else {
              logger.error('Invalid or missing item data');
              feedbackElement.textContent = 'Error loading item. Please try again.';
            }
          } catch (error) {
            logger.error('Error getting or displaying item');
            feedbackElement.textContent = 'Error loading item. Please try again.';
          } finally {
            // Hide loading indicator
            if (loadingLeaf) {
              loadingLeaf.style.display = 'none';
            }
            
            // Always release the lock
            isLoadingItem = false;
          }

          // Timer will be started after image is successfully loaded - see displayItem function

        } catch (error) {
          logger.error('Error setting up new round');
          feedbackElement.textContent = 'Error setting up new round. Please try again.';
        }
      }

      // Reset function for when categories are changed or Try Again is pressed
      async function resetGame() {
        logger.debug('Resetting game');
        
        // Stop any current timer
        stopTimer();
        
        // Reset timer display based on current difficulty setting
        const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
        timeLeft = difficulty;
        maxTime = difficulty;
        timerDisplay.textContent = `Time: ${timeLeft}`;
        timerDisplay.className = 'timer';
        
        // Reset score
        score = 0;
        scoreElement.textContent = `Score: ${score}`;
        
        // Reset image display state
        imageDisplay.onload = null;
        imageDisplay.onerror = null;
        imageDisplay.src = '';
        imageDisplay.style.display = 'none';
        imageDisplay.classList.remove('loaded');
        
        // Reset state variables
        currentlyDisplayingItem = null;
        isTryingFallback = false;
        gameOver = false;
        
        // Reset loading state - IMPORTANT to prevent the game from getting stuck
        isLoadingItem = false;
        
        // Hide any existing placeholder
        const placeholder = document.querySelector(".image-placeholder");
        if (placeholder) {
          placeholder.style.display = "none";
        }
        
        // Show loading indicator
        const loadingLeaf = document.querySelector('.loading-leaf');
        if (loadingLeaf) {
          loadingLeaf.style.display = 'block';
        }
        
        // Hide next button if visible
        nextButton.style.display = 'none';
        
        // Reset feedback
        feedbackElement.textContent = "Loading...";
        feedbackElement.className = "";
        
        // Enable input and buttons
        guessInput.disabled = false;
        submitButton.disabled = false;
        guessInput.value = "";
        
        // Load a new item
        try {
          // Initialize the game with a new item
          await initGame();
          
          // Timer will be started after the image is successfully loaded in displayItem
          
          // Make sure the timer display shows the correct class
          timerDisplay.classList.remove('warning', 'expired');
          timerDisplay.classList.add('running');
        } catch (error) {
          logger.error('Error resetting game');
          feedbackElement.textContent = 'Error resetting game. Please try again.';
        }
      }

      function checkGuess() {
        if (submitButton.disabled) return; // Prevent multiple submissions
        
        // Stop the timer when an answer is submitted
        stopTimer();
        
        const guess = guessInput.value.trim().toLowerCase();
        const correctAnswer = currentItem.name.toLowerCase();
        
        // Initialize points earned for this guess
        let pointsEarned = 10; // Base points for correct answer

        if (guess === correctAnswer) {
          // Update score
          score += 10;
          scoreElement.textContent = score;
          
          // Play correct sound
          const correctSound = document.getElementById('correct-sound');
          if (correctSound) {
            correctSound.currentTime = 0;
            correctSound.play().catch(e => logger.warn('Could not play sound'));
            multiplier = 3;
          }
          
          // Calculate final points with multiplier
          const totalPoints = pointsEarned * multiplier;
          score += totalPoints;
          
          scoreElement.textContent = `Score: ${score}`;
          const multiplierText = multiplier > 1 ? ` x${multiplier}!` : '';
          feedbackElement.textContent = `Correct! +${totalPoints} points${multiplierText}`;
          feedbackElement.className = "correct";
          
          // Update personal best score after each correct answer
          updateHighScore();
          
          // Stop the timer after a correct guess
          stopTimer();
          
          // Reset image display state to prepare for the next round
          // First, remove any existing event handlers from the image display to prevent stale events
          imageDisplay.onload = null;
          imageDisplay.onerror = null;
          
          // Reset state variables
          currentlyDisplayingItem = null;
          isTryingFallback = false;
          
          // Show next button
          nextButton.style.display = 'block';
          
          // Disable input until next round
          guessInput.disabled = true;
          submitButton.disabled = true;
          
          // Make sure we release any loading locks before setting up a new round
          isLoadingItem = false;
          logger.debug('Setting isLoadingItem to false before timeout');
          
          // Automatically load next item with reduced delay for faster image loading
          // Reduced from 1000ms to 500ms for faster transitions between rounds
          setTimeout(async () => {
            // Make sure we're not in a loading state before setting up a new round
            if (isLoadingItem) {
              logger.debug('Resetting isLoadingItem flag before setting up new round');
              isLoadingItem = false;
            }
            
            // Reduced delay to 50ms to make next image load faster
            await new Promise(resolve => setTimeout(resolve, 50));
            
            // Double-check we're not in a loading state
            if (isLoadingItem) {
              logger.warn('Still in loading state after delay, forcing reset');
              isLoadingItem = false;
            }
            
            // Set up new round (this will reset the timer values)
            setupNewRound();
            
            // Don't start the timer here - it will be started after the image loads in displayItem
            
            // Re-enable input for the next round
            guessInput.disabled = false;
            submitButton.disabled = false;
            submitButton.style.display = 'inline-block';
          }, 500); // Reduced from 1000ms to 500ms for faster transitions
        } else {
          // Stop the timer
          stopTimer();
          
          // Play wrong answer sound
          playSound(gameOverSound);
          
          // Incorrect guess - game over
          feedbackElement.textContent = `Game Over! The answer was ${currentItem.name}. Final Score: ${score}`;
          feedbackElement.className = "wrong";
          scoreElement.textContent = `Score: ${score}`;
          
          // Set game over flag BEFORE stopping timer
          gameOver = true;
          console.log('Game over set to true');
          
          // Make sure timer is completely stopped - call this AFTER setting gameOver flag
          stopTimer();
          
          // Force timer display to stop and cancel any pending animation frames
          if (timerInterval) {
            cancelAnimationFrame(timerInterval);
            timerInterval = null;
          }
          
          // Freeze the timer display to show the final time
          timerDisplay.classList.remove('running', 'warning');
          timerDisplay.classList.add('expired');
          
          // Disable input and replace submit button with try again button
          guessInput.disabled = true;
          submitButton.style.display = 'none';
          const tryAgainButton = document.getElementById('try-again-btn');
          tryAgainButton.style.display = 'inline-block';
          guessInput.focus(); // Keep focus on input for keyboard users
          
          // Update personal best scores in localStorage
          updateHighScore();
          
          // Check if the score is a leaderboard high score
          const category = categorySelector.value;
          
          // Only check for high scores if the score is at least 3
          if (score >= 3) {
            isHighScore(score, category).then(isHighEnough => {
              if (isHighEnough) {
                showHighScoreModal(score, category);
              }
            });
          }
          
          // Reset shown items when game is over
          shownItems = {};
        }
        guessInput.value = '';
      }
      
      function resetLeaderboardCategory(category) {
        if (!confirm(`Are you sure you want to reset the ${category} leaderboard? This cannot be undone.`)) {
          return; // User canceled
        }
        
        // Get current leaderboard data or create empty if not exists
        let leaderboardData = JSON.parse(localStorage.getItem('acnh_leaderboard') || '{}');
        
        // If leaderboard exists, reset the selected category
        if (leaderboardData) {
          try {
            // Reset the category to an empty array
            leaderboardData[category] = [];
            
            // Save updated leaderboard to localStorage
            localStorage.setItem('acnh_leaderboard', JSON.stringify(leaderboardData));
            
            // Update UI
            updateLeaderboardUI(leaderboardData);
            alert(`${category.charAt(0).toUpperCase() + category.slice(1)} leaderboard has been reset.`);
          } catch (e) {
            console.error('Error resetting leaderboard category:', e);
            alert('An error occurred while resetting the leaderboard.');
          }
        } else {
          // If no leaderboard exists yet, create an empty one
          leaderboardData = { fish: [], bugs: [], sea: [], villagers: [] };
          localStorage.setItem('acnh_leaderboard', JSON.stringify(leaderboardData));
          updateLeaderboardUI(leaderboardData);
          alert(`${category.charAt(0).toUpperCase() + category.slice(1)} leaderboard has been reset.`);
        }
      }

      function resetAllLeaderboards() {
        if (!confirm('Are you sure you want to reset ALL leaderboards? This cannot be undone.')) {
          return; // User canceled
        }
        
        // Create empty leaderboard data
        const emptyLeaderboard = { fish: [], bugs: [], sea: [], villagers: [] };
        
        // Save to localStorage
        localStorage.setItem('acnh_leaderboard', JSON.stringify(emptyLeaderboard));
        
        // Update the UI
        updateLeaderboardUI(emptyLeaderboard);
        
        alert('All leaderboards have been reset.');
      }
      
      function resetToDefaults() {
        if (!confirm('Are you sure you want to reset the leaderboards to default values from leaderboard.json?')) {
          return; // User canceled
        }
        
        // Fetch the default leaderboard data from leaderboard.json
        fetch('leaderboard.json')
          .then(response => {
            if (!response.ok) {
              throw new Error('Failed to load default leaderboard data');
            }
            return response.json();
          })
          .then(defaultData => {
            // Save the default data to localStorage
            localStorage.setItem('acnh_leaderboard', JSON.stringify(defaultData));
            
            // Update the UI
            updateLeaderboardUI(defaultData);
            
            alert('Leaderboards have been reset to default values.');
          })
          .catch(error => {
            console.error('Error loading default leaderboard data:', error);
            alert('Error loading default leaderboard data. Please try again.');
          });
      }

      async function isHighScore(score, category) {
        try {
          // First check local storage for any existing scores
          const savedLeaderboard = localStorage.getItem('acnh_leaderboard');
          if (savedLeaderboard) {
            const data = JSON.parse(savedLeaderboard);
            const scores = data[category] || [];
            
            // If there are fewer than 10 scores, any score is a high score
            if (scores.length < 10) return true;
            
            // Find the lowest score in the top 10
            const lowestScore = scores.reduce((min, entry) => 
              entry.score < min ? entry.score : min, scores[0].score);
            
            return score > lowestScore;
          }
          
          // If no local data, check the server
          const response = await fetch('leaderboard.json');
          const data = await response.json();
          const scores = data[category] || [];
          
          // If there are fewer than 10 scores, any score is a high score
          if (scores.length < 10) return true;
          
          // Find the lowest score in the top 10
          const lowestScore = scores.reduce((min, entry) => 
            entry.score < min ? entry.score : min, scores[0].score);
          
          return score > lowestScore;
          
        } catch (error) {
          console.error('Error checking high score:', error);
          // Default to true if there's an error (to be safe)
          return true;
        }
      }

      window.addEventListener("DOMContentLoaded", () => {
        // Add reset button event listener
        const resetButton = document.getElementById('reset-high-score');
        if (resetButton) {
          resetButton.addEventListener('click', () => {
            // Reset all high scores
            localStorage.removeItem('acnh_high_score');
            const category = categorySelector.value;
            localStorage.removeItem(`acnh_high_score_${category}`);
            
            // Reset shown items
            localStorage.removeItem(`shown_items_${category}`);
            
            // Reset current score
            score = 0;
            scoreElement.textContent = `Score: ${score}`;
            
            // Update high score display
            highScoreElement.textContent = `Personal Best: 0`;
            
            // Don't load a new image when resetting high score
            // Show the Start Game button instead
            const startGameButton = document.getElementById('start-game-btn');
            if (startGameButton) {
              startGameButton.style.display = 'inline-block';
            }
          });
        }

        // Category change handling is now in the other event listener
        
        // Event listener for difficulty change
        difficultySelector.addEventListener('change', function() {
          // Stop the current timer when difficulty changes
          stopTimer();
          
          // Update timer values based on the new difficulty
          const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
          timeLeft = difficulty;
          maxTime = difficulty;
          timerDisplay.textContent = `Time: ${timeLeft}`;
          timerDisplay.classList.remove('warning', 'expired');
          
          // Don't load a new image when difficulty changes, only update the timer values
          // setupNewRound will be called when Start Game is pressed
        });

        // Restore score and category from previous session
        const savedScore = localStorage.getItem("acnh_current_score");
        if (savedScore) {
          score = parseInt(savedScore, 10);
          scoreElement.textContent = `Score: ${score}`;
        }

        const savedCategory = localStorage.getItem("acnh_last_category");
        if (savedCategory) {
          categorySelector.value = savedCategory;
          
          // Update high score for the selected category
          const categoryKey = `acnh_high_score_${savedCategory}`;
          const currentHighScore = parseInt(localStorage.getItem(categoryKey) || '0', 10);
          highScoreElement.textContent = `Personal Best: ${currentHighScore}`;
        }

        // Update the leaderboard UI with the current category
        updateLeaderboardUI(categorySelector.value);
        
        // Don't load any images until the game starts
        
        // Add event listener for the Start Game button
        const startGameButton = document.getElementById('start-game-btn');
        if (startGameButton) {
          startGameButton.addEventListener('click', function() {
            // Hide the start game button
            startGameButton.style.display = 'none';
            
            // Enable the input field and focus it
            guessInput.disabled = false;
            guessInput.style.display = 'inline-block';
            guessInput.focus();
            
            // Show the submit button
            submitButton.style.display = 'inline-block';
            
            // Initialize the game (this will load the first image)
            initGame(true);
            
            // Start the game round - the timer will be started after the image loads
            setupNewRound();
            
            // Play new round sound
            playSound(startGameSound);
          });
        }
        
        // Add event listener for the sound toggle button
        const soundToggleBtn = document.getElementById('sound-toggle');
        if (soundToggleBtn) {
          soundToggleBtn.addEventListener('click', function() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('acnh_sound_enabled', soundEnabled);
            
            // Update button text
            soundToggleBtn.innerHTML = soundEnabled ? 'ðŸ”Š Sound: ON' : 'ðŸ”‡ Sound: OFF';
            
            // Add a small animation effect on click
            soundToggleBtn.style.transform = 'scale(0.9)';
            setTimeout(() => {
              soundToggleBtn.style.transform = 'scale(1)';
            }, 100);
          });
        }
        
        // Add event listeners for the reset buttons - safely with null checks
        const resetFishBtn = document.getElementById('reset-fish-btn');
        if (resetFishBtn) resetFishBtn.addEventListener('click', () => resetLeaderboardCategory('fish'));
        
        // Add event listeners for admin buttons
        document.getElementById('simulate-score-btn').addEventListener('click', () => {
          const categories = ['fish', 'bugs', 'sea', 'villagers'];
          const randomCategory = categories[Math.floor(Math.random() * categories.length)];
          const testScore = Math.floor(Math.random() * 371) + 130; // Random score between 130-500
          
          // Directly show the high score modal for the test score
          showHighScoreModal(testScore, randomCategory);
        });
        
        const resetBugsBtn = document.getElementById('reset-bugs-btn');
        if (resetBugsBtn) resetBugsBtn.addEventListener('click', () => resetLeaderboardCategory('bugs'));
        
        const resetSeaBtn = document.getElementById('reset-sea-btn');
        if (resetSeaBtn) resetSeaBtn.addEventListener('click', () => resetLeaderboardCategory('sea'));
        
        const resetVillagersBtn = document.getElementById('reset-villagers-btn');
        if (resetVillagersBtn) resetVillagersBtn.addEventListener('click', () => resetLeaderboardCategory('villagers'));
        
        const resetAllBtn = document.getElementById('reset-all-btn');
        if (resetAllBtn) resetAllBtn.addEventListener('click', resetAllLeaderboards);
        
        const resetToDefaultsBtn = document.getElementById('reset-to-defaults-btn');
        if (resetToDefaultsBtn) resetToDefaultsBtn.addEventListener('click', resetToDefaults);

        submitButton.addEventListener("click", checkGuess);
        guessInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            e.preventDefault(); // Prevent form submission if any
            const tryAgainButton = document.getElementById("try-again-btn");
            if (tryAgainButton && window.getComputedStyle(tryAgainButton).display !== 'none') {
              // If Try Again button is visible, trigger it
              tryAgainButton.click();
            } else {
              // Otherwise, check the guess as normal
              checkGuess();
            }
          }
        });

        // Handle keyboard visibility on mobile devices
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
          // Set fixed position for game container to prevent automatic scrolling
          const gameContainer = document.getElementById('game-container');
          if (gameContainer) {
            // Add CSS to allow manual scrolling but prevent automatic repositioning
            gameContainer.style.position = 'relative';
            gameContainer.style.overflowY = 'auto';
            gameContainer.style.maxHeight = '90vh'; // Set maximum height to allow scrolling
          }
          
          // Prevent default focus behavior that would scroll the screen
          guessInput.addEventListener('focus', function(e) {
            // Prevent automatic scrolling
            e.preventDefault();
            // Keep focus on input field
            setTimeout(function() {
              guessInput.focus();
            }, 50);
          });

          // Handle orientation changes without repositioning
          window.addEventListener('resize', function() {
            // No automatic scrolling on resize
          });
        }
        // Custom handler for next button to avoid playing start-game sound
        nextButton.addEventListener("click", () => {
          // Hide the next button
          nextButton.style.display = 'none';
          
          // Set up a new round without playing the start-game sound
          setupNewRound();
          
          // Re-enable input
          guessInput.disabled = false;
          submitButton.disabled = false;
          submitButton.style.display = 'inline-block';
          guessInput.focus();
        });
        const tryAgainButton = document.getElementById("try-again-btn");
        tryAgainButton.addEventListener("click", async () => {
          // Reset game state
          gameOver = false;
          
          // Hide the try again button
          tryAgainButton.style.display = 'none';
          
          // Show the submit button
          submitButton.style.display = 'inline-block';
          
          // Play new round sound
          playSound(startGameSound);
          
          // Use our improved resetGame function to properly reset everything
          await resetGame();
          
          // Focus the input field
          guessInput.focus();
        });
        
        // Add event listener for the End Game button
        const endGameButton = document.getElementById("end-game-btn");
        endGameButton.addEventListener("click", () => {
          // Stop the timer
          stopTimer();
          
          // Disable game controls
          guessInput.disabled = true;
          submitButton.disabled = true;
          
          // Set game over flag
          gameOver = true;
          
          // Show feedback and Try Again button
          feedbackElement.textContent = `Game Over! Final Score: ${score}`;
          feedbackElement.className = "";
          
          // Show the Try Again button
          const tryAgainButton = document.getElementById("try-again-btn");
          tryAgainButton.style.display = 'inline-block';
          
          // Hide the End Game button
          endGameButton.style.display = 'none';
          
          // Update personal best scores in localStorage
          updateHighScore();
          
          // Check if the score is a leaderboard high score
          const category = categorySelector.value;
          
          // Check for high scores regardless of the score value
          isHighScore(score, category).then(isHighEnough => {
            if (isHighEnough) {
              showHighScoreModal(score, category);
            } else {
              playSound(gameOverSound);
            }
          });
        });
        
        // Category initialization is now handled after the function definition
      }); // Close the DOMContentLoaded event listener
      
      // Store the current category change promise to prevent race conditions
      let categoryChangePromise = null;
      let isCategoryLoading = false;
      
      // Get DOM elements
      const categorySelector = document.getElementById('category');
      const feedbackElement = document.getElementById('feedback');
    </script>
    
    <script>
      // Function to handle category changes
      const handleCategoryChange = async (category) => {
        console.log('Category changed to:', category);
        
        // Ensure category is a valid string
        if (typeof category !== 'string' || !['fish', 'bugs', 'sea', 'villagers'].includes(category)) {
          console.warn('Invalid category, defaulting to fish:', category);
          category = 'fish';
          if (categorySelector) categorySelector.value = category;
        }
        
        // Store the last selected category
        localStorage.setItem('acnh_last_category', category);
        
        // Validate the category
        if (typeof category !== 'string' || !['fish', 'bugs', 'sea', 'villagers'].includes(category)) {
          console.error('Invalid category selected:', category);
          feedbackElement.textContent = 'Invalid category selected. Please try again.';
          feedbackElement.className = 'wrong';
          return;
        }
        
        // If we're already changing categories, wait for that to complete
        if (isCategoryLoading) {
          console.log('Category change already in progress, waiting...');
          return;
        }
        
        isCategoryLoading = true;
        feedbackElement.textContent = "Loading...";
        feedbackElement.className = "";
        
        try {
          // Stop the current timer if it's running
          stopTimer();
          
          // Reset timer variables
          const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
          timeLeft = difficulty;
          maxTime = difficulty;
          timerDisplay.textContent = `Time: ${timeLeft}`;
          timerDisplay.className = 'timer';
          
          console.log(`Loading category: ${category}`);
          
          // Always load items for the category to ensure we have fresh data
          await loadCategoryItems(category);
          
          // Only update the category and score, but don't load images yet
          if (currentCategory !== category) {
            console.log(`Category changed from ${currentCategory} to ${category}, resetting score`);
            score = 0;
            currentCategory = category;
            
            // Save selected category to localStorage
            localStorage.setItem("acnh_last_category", category);
            
            // Show the Start Game button
            const startGameBtn = document.getElementById('start-game-btn');
            if (startGameBtn) {
              startGameBtn.style.display = 'inline-block';
            }
          }
          
          // Update high score when category changes
          const categoryKey = `acnh_high_score_${category}`;
          const currentHighScore = parseInt(localStorage.getItem(categoryKey) || '0', 10);
          highScoreElement.textContent = `Personal Best: ${currentHighScore}`;
          
        } catch (error) {
          console.error('Error changing category:', error);
          feedbackElement.textContent = 'Error changing category. Please try again.';
          feedbackElement.className = 'wrong';
        } finally {
          isCategoryLoading = false;
          feedbackElement.textContent = '';
        }
      };
      
      // Set up the event listener for category changes
      if (categorySelector) {
        categorySelector.addEventListener("change", (e) => {
          const newCategory = e.target.value;
          console.log('Category selector changed to:', newCategory);
          handleCategoryChange(newCategory);
        });
        
        // Initialize with saved category or default
        const savedCategory = localStorage.getItem('acnh_last_category');
        const initialCategory = savedCategory || 'fish';
        categorySelector.value = initialCategory;
        
        // Initialize the game with the selected category
        console.log('Initializing with category:', initialCategory);
        handleCategoryChange(initialCategory);
      }
    </script>
    
    <!-- Game Scripts -->
    <script>
      // Add any additional game scripts here
    </script>
  </body>
</html>