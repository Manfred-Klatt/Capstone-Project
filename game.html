<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fontfaceobserver/2.3.0/fontfaceobserver.standalone.js"></script>
    <script src="/js/fontInstaller.js"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Preload essential sound effects with optimized OGG files -->
    <!-- Critical sounds preloaded for immediate use -->
    <audio id="correct-sound" preload="auto">
      <source src="/sounds/correct.ogg" type="audio/ogg">
      <source src="/sounds/correct.wav" type="audio/wav">
      Your browser does not support the audio element.
    </audio>
    <audio id="game-over-sound" preload="auto">
      <source src="/sounds/game-over.ogg" type="audio/ogg">
      <source src="/sounds/game-over.wav" type="audio/wav">
      Your browser does not support the audio element.
    </audio>
    <!-- Non-critical sounds loaded on demand -->
    <audio id="start-game-sound" preload="none">
      <source src="/sounds/start-game.ogg" type="audio/ogg">
      <source src="/sounds/start-game.wav" type="audio/wav">
      Your browser does not support the audio element.
    </audio>
    <audio id="high-score-sound" preload="none">
      <source src="/sounds/high-score.ogg" type="audio/ogg">
      <source src="/sounds/high-score.wav" type="audio/wav">
      Your browser does not support the audio element.
    </audio>
    <audio id="toggle-on-sound" preload="none">
      <source src="/sounds/toggle-on.ogg" type="audio/ogg">
      <source src="/sounds/toggle-on.wav" type="audio/wav">
      Your browser does not support the audio element.
    </audio>
    <audio id="toggle-off-sound" preload="none">
      <source src="/sounds/toggle-off.ogg" type="audio/ogg">
      <source src="/sounds/toggle-off.wav" type="audio/wav">
      Your browser does not support the audio element.
    </audio>
    <title>AC:NH ID Game</title>
    <style>
      @font-face {
        font-family: 'ACfont';
        src: url('/fonts/ACfont.otf') format('opentype');
        font-display: swap;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* Blathers character under scoreboards */
      #blathers-character {
        width: 60px;
        height: auto;
        margin: 20px auto 0;
        display: block;
        opacity: 0.9;
      }
      
      /* Leaderboards container */
      .leaderboards-container {
        position: relative;
        margin-bottom: 40px; /* Add space for Blathers */
      }

      /* Initial state - hide text while fonts load */
      html.font-loading body {
        visibility: hidden;
      }
      
      /* Fallback font */
      html.font-fallback * {
        font-family: 'Quicksand', Arial, sans-serif;
      }
      
      /* Custom font loaded */
      html.font-loaded * {
        font-family: 'ACfont', 'Quicksand', Arial, sans-serif;
      }

      :root {
        --background-color: #f0f8ff;
        --text-color: #5a3d2b;
        --container-bg: #fff9f0;
        --border-color: #8b4513;
        --shadow-color: rgba(0, 0, 0, 0.1);
      }

      body {
        font-family: "ACfont", "Arial", sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        text-align: center;
        background-color: var(--background-color);
        color: var(--text-color);
        background-image: url("images/background.jpg");
        background-size: cover;
        background-position: center;
        box-sizing: border-box;
      }
      #game-container {
        background-color: var(--container-bg);
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 0 15px var(--shadow-color);
        border: 3px solid var(--border-color);
        width: 100%;
        max-width: 1200px;
        margin: 0 auto;
        box-sizing: border-box;
      }
      #imageDisplay {
        max-width: 100%;
        max-height: 400px;
        margin: 10px auto;
        display: block;
        border: none;
        box-shadow: none;
        /* Hide broken image icon */
        font-size: 0;
        color: transparent;
        /* Smooth transition for loading */
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
      }
      
      #imageDisplay.loaded {
        opacity: 1;
      }
      
      .image-placeholder {
        width: 100%;
        max-width: 400px;
        height: 200px;
        margin: 10px auto;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f8f8f8;
        border: 2px dashed #ccc;
        border-radius: 10px;
        color: #666;
        font-size: 18px;
        text-align: center;
      }
      
      .loading-leaf {
        width: 80px;
        height: 80px;
        margin: 10px auto;
        display: none;
        background-image: url('images/leaf.png');
        background-size: contain;
        background-repeat: no-repeat;
        animation: spin 2s linear infinite;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      input, button {
        padding: 10px;
        font-size: 14px;
        border-radius: 6px;
        margin-right: 8px;
      }

      #guess-input {
        width: 100%;
        max-width: 280px;
        border: 1px solid var(--border-color);
        background-color: #fffdf8;
        margin: 5px 0;
      }

      button {
        background-color: #6b8e23;
        color: white;
        border: none;
        cursor: pointer;
        transition: background-color 0.3s;
      }
            
      #start-round:hover {
        background-color: #a0522d;
      }
      button:hover {
        background-color: #556b2f;
      }
      
      #try-again-btn {
        background-color: #ff8c00;
      }
      
      #try-again-btn:hover {
        background-color: #e67e00;
      }
      #feedback {
        margin: 15px;
        font-size: 16px;
        min-height: 24px;
        font-weight: bold;
      }
      #score {
        font-weight: bold;
        font-size: 18px;
        color: #8b4513;
      }
      #category-selector {
        margin: 15px 0;
      }
      select {
        padding: 6px;
        border-radius: 4px;
        border: 1px solid #5a3d2b;
        background-color: #fffdf8;
        font-family: 'ACfont', Arial, sans-serif;
      }
      option {
        font-family: 'ACfont', Arial, sans-serif;
      }
      .correct {
        color: #2e8b57;
      }
      .incorrect {
        color: #cd5c5c;
      }
      .logout-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background-color: #ff6b6b;
      }
      .logout-btn:hover {
        background-color: #ff5252;
      }
      #leaderboard-section {
        width: 200px;
        float: right;
        margin-right: 20px;
        background-color: #fff9f0;
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        border: 2px solid #8b4513;
      }
      #leaderboard-section h2 {
        margin-bottom: 10px;
        border-bottom: 2px solid #8b4513;
        padding-bottom: 5px;
      }
      #admin-tools-container {
        width: 200px;
        position: absolute;
        top: 50px;
        left: 10px;
        background-color: #fff9f0;
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        z-index: 100;
        border: 2px solid #8b4513;
        z-index: 100;
      }
      
      #admin-tools-container h2 {
        margin-bottom: 10px;
        border-bottom: 2px solid #8b4513;
        padding-bottom: 5px;
        color: #5a3d2b;
      }
      
      #admin-tools-container button {
        display: block;
        width: 100%;
        margin-bottom: 10px;
        padding: 8px;
        background-color: #6b8e23;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      
      #admin-tools-container button:hover {
        background-color: #556b2f;
      }
      
      #game-container {
        width: 95%;
        max-width: 1100px;
        margin: 0 auto 30px;
        padding: 15px;
        background-color: #fff9e6; /* Warm yellow that complements the Animal Crossing theme */
        border-radius: 10px;
        border: 2px solid var(--border-color, #8b4513);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        box-sizing: border-box;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      #leaderboard {
        font-size: 16px;
        font-weight: bold;
      }
      
      /* Leaderboard container */
      .leaderboards-container {
        display: grid;
        grid-template-columns: repeat(2, minmax(250px, 1fr));
        gap: 20px;
        margin: 0 auto 40px;
        width: 100%;
        max-width: 900px;
        padding: 0 15px;
        box-sizing: border-box;
        align-items: start; /* Align items to the top */
        justify-content: center;
      }

      .category-leaderboard {
        background-color: #fff9f0;
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 0 12px rgba(0, 0, 0, 0.1);
        border: 2px solid #8b4513;
        width: 100%;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: auto; /* Let content determine height */
        margin: 0 auto;
      }

      .category-leaderboard h3 {
        margin: 0 0 12px 0;
        padding-bottom: 8px;
        border-bottom: 1px solid #8b4513;
        text-align: center;
        white-space: nowrap;
      }

      .category-leaderboard > div {
        display: flex;
        flex-direction: column;
        min-height: 0; /* Prevents flex item from growing */
      }

      .category-leaderboard span {
        display: block;
        padding: 6px 0;
        border-bottom: 1px solid #e8e8e8;
        line-height: 1.3;
      }

      .category-leaderboard span:last-child {
        border-bottom: none;
      }
      #leaderboard-container {
        width: 100%;
        max-width: 1140px;
        margin: 20px auto;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        flex-wrap: wrap;
        gap: 10px;
        padding: 15px;
        background-color: #fff9f0;
        border-radius: 12px;
        box-shadow: 0 0 12px rgba(0, 0, 0, 0.1);
        border: 2px solid #8b4513;
        box-sizing: border-box;
      }
      .category-leaderboard h3 {
        margin-bottom: 5px;
        border-bottom: 2px solid #8b4513;
        padding-bottom: 2.5px;
      }
      .high-score-container {
        text-align: center;
        font-size: 1.2em;
        font-weight: bold;
        margin-bottom: 60px;
      }

      .score-container {
        text-align: center;
      }

      .category-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
      }

      .timer-container {
        display: block;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px 20px;
        border-radius: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin: 10px auto;
        text-align: center;
        width: fit-content;
      }

      .loading-leaf {
        width: 40px;
        height: 40px;
        background: url('images/loading.png') no-repeat center;
        background-size: contain;
        animation: spin 1s linear infinite;
        margin: 20px auto;
        display: none;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .timer {
        font-size: 24px;
        font-weight: bold;
        color: #333;
        transition: color 0.3s ease;
      }

      .timer.running {
        color: #4CAF50;
      }

      .timer.warning {
        color: #FFA500;
      }

      .timer.expired {
        color: #FF4444;
      }
      
      /* High Score Modal Styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
      }
      
      .modal-content {
        background-color: #f8f8f8;
        margin: 15% auto;
        padding: 20px;
        border: 2px solid #4CAF50;
        border-radius: 10px;
        width: 300px;
        text-align: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        animation: modalAppear 0.4s;
      }
      
      @keyframes modalAppear {
        from {transform: scale(0.8); opacity: 0;}
        to {transform: scale(1); opacity: 1;}
      }
      
      .modal h2 {
        color: #4CAF50;
        margin-top: 0;
      }
      
      .modal input {
        width: 90%;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 16px;
      }
      
      .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 15px;
      }
      
      .modal-btn {
        padding: 8px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
      }
      
      .submit-btn {
        background-color: #4CAF50;
        color: white;
      }
      
      .submit-btn:hover {
        background-color: #45a049;
      }
      
      .skip-btn {
        background-color: #f1f1f1;
        color: #333;
      }
      
      .skip-btn:hover {
        background-color: #ddd;
      }

      .logout-btn {
        background-color: #4a90e2;
        color: white;
        padding: 8px 15px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.3s ease !important;
      }

      .logout-btn:hover {
        background-color: #357abd !important;
      }

      /* Reset All Button Hover Effect */
      #reset-all-btn {
        transition: background-color 0.3s ease !important;
      }

      #reset-all-btn:hover {
        background-color: #d93025 !important; /* Darker shade of red */
      }

      /* Reset to Defaults Button Hover Effect */
      #reset-to-defaults-btn {
        transition: background-color 0.3s ease !important;
      }

      #reset-to-defaults-btn:hover {
        background-color: #357abd !important; /* Darker shade of blue */
      }

      /* Reset Personal Best Button Hover Effect */
      #reset-high-score {
        transition: background-color 0.3s ease !important;
      }

      #reset-high-score:hover {
        background-color: #e69138 !important; /* Darker shade of orange */
      }
      
      /* Mobile Navigation Bar */
      .mobile-nav-bar {
        display: none;
      }
      
      /* Leaderboard Styles */
      .leaderboards-container {
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        padding: 0 20px;
        box-sizing: border-box;
      }
      
      .category-leaderboard {
        width: 100%;
        margin-bottom: 20px;
        box-sizing: border-box;
      }
      
      #fish-scores,
      #bugs-scores,
      #sea-scores,
      #villagers-scores {
        width: 100%;
        display: flex;
        flex-direction: column;
      }
      
      .category-leaderboard h3 {
        width: 100%;
        max-width: 800px;
        margin: 20px auto;
        padding: 0 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      
      .category-leaderboard {
        border-radius: 10px;
        border: 2px solid var(--border-color);
        padding: 15px;
        margin-bottom: 20px;
      }

      /* Unique background colors for each category */
      #fish-leaderboard {
        background: linear-gradient(to top, #87CEEB, #B0E0E6); /* Gradient from light blue to very light blue */
      }

      #bugs-leaderboard {
        background: linear-gradient(to top, #32CD32, #98FB98); /* Gradient from light green to very light green */
      }
      
      #sea-leaderboard {
        background: linear-gradient(to top, #00BFFF, #1E90FF); /* Gradient from darker blue to medium blue */
      }

      #villagers-leaderboard {
        background: linear-gradient(to top, #FFD700, #FFB6C1); /* Gradient from gold to light pink */
      }
      
      .category-leaderboard:last-child {
        margin-bottom: 0;
      }
      
      .leaderboard-score {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 15px;
        border-bottom: 1px solid rgba(139, 69, 19, 0.2);
        font-size: 1rem;
        color: #000000;
        text-shadow: 0 0 1px rgba(0, 0, 0, 0.8);
        width: 100%;
        box-sizing: border-box;
        margin: 0;
      }
      
      .leaderboard-score:last-child {
        border-bottom: none;
      }
      
      .leaderboard-score .name {
        flex: 1;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-weight: 500;
        padding: 0 20px 0 0;
        text-align: left;
        font-size: 1.05rem;
      }
      
      .leaderboard-score .score {
        flex: 0 0 auto;
        min-width: 80px;
        text-align: right;
        font-weight: bold;
        color: #2c3e50;
        white-space: nowrap;
        padding: 4px 8px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        font-size: 1.05rem;
      }
      
      .leaderboard-score.is-new {
        background-color: rgba(76, 175, 80, 0.1);
      }
      
      /* Responsive adjustments */
      @media (max-width: 768px) {
        .category-leaderboard h3 {
          font-size: 1.1rem;
        }
        
        .leaderboard-score {
          font-size: 0.9rem;
        }
        
        .leaderboard-score .score {
          min-width: 50px;
        }
      }
      
      @media (max-width: 480px) {
        .category-leaderboard h3 {
          font-size: 1rem;
        }
        
        .leaderboard-score {
          font-size: 0.8rem;
        }
        
        .leaderboard-score .score {
          min-width: 45px;
        }

        /* Make guess input field fit mobile screen */
        #guess-input {
          width: 100%;
          max-width: 100%;
          box-sizing: border-box;
          padding: 8px;
          margin: 8px 0;
        }

        /* Fix admin container overlap on mobile */
        #admin-tools-container {
          position: absolute;
          top: 50px;
          left: 0;
          right: 0;
          background-color: var(--container-bg);
          border-radius: 10px;
          padding: 15px;
          margin: 10px;
          z-index: 1000;
        }

        /* Adjust admin toggle button position on mobile */
        #admin-toggle-btn {
          top: 10px;
          left: 10px;
          z-index: 2000;
        }
      }
      
      /* Special styling for top 3 positions */
      .leaderboard-score:nth-child(-n+3) .name::before {
        content: counter(rank);
        color: var(--text-color);
        font-weight: bold;
        margin-right: 5px;
        padding: 2px 5px;
        border-radius: 3px;
        background-color: var(--container-bg);
        text-shadow: 0 0 1px rgba(0, 0, 0, 0.8); /* Thin black outline */
      }
      
      /* Media Queries for Mobile Responsiveness */
      /* Common container styles for mobile */
      .mobile-container {
        width: 95%;
        margin-left: auto;
        margin-right: auto;
        box-sizing: border-box;
        border-radius: 10px;
        border: 2px solid var(--border-color);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        background-color: #e8f5e9; /* Soft mint green that complements the theme */
      }
      
      /* Ensure all containers have the same styling on mobile */
      @media (max-width: 768px) {
        #category-selector {
          flex-direction: row;
          justify-content: center;
          flex-wrap: wrap;
          gap: 10px;
        }
        
        #category-selector > div {
          flex: 0 1 auto;
          min-width: 150px;
          max-width: 180px;
        }
        
        #category, #difficulty {
          font-size: 0.85rem !important;
          padding: 5px !important;
        }
        
        .mobile-container {
          width: 95% !important;
          max-width: 600px !important;
          margin: 5px auto !important;
          padding: 10px !important;
          background-color: var(--container-bg) !important;
          border-radius: 10px !important;
          border: 2px solid var(--border-color) !important;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.1) !important;
          box-sizing: border-box !important;
          text-align: center !important;
        }
        
        /* Reduce spacing in game elements */
        h1 {
          font-size: 1rem !important;
          margin: 5px 0 !important;
          line-height: 1.2;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          background: linear-gradient(90deg, 
            #ff0000 0%,
            #ff7e00 10%,
            #ffff00 20%,
            #00ff00 30%,
            #00ffff 40%,
            #0000ff 50%,
            #8b00ff 60%,
            #ff00ff 70%,
            #ff0000 80%
          );
          -webkit-background-clip: text;
          background-clip: text;
          color: transparent;
          animation: rainbow 2s linear infinite;
        }

        @keyframes rainbow {
          0% {
            background-position: 0% 50%;
          }
          100% {
            background-position: 100% 50%;
          }
        }
        
        .high-score-container {
          margin-bottom: 10px !important;
        }
        
        #category-selector {
          margin: 5px 0 !important;
        }
        
        .score-container {
          margin: 5px 0 !important;
          display: flex !important;
          justify-content: center !important;
          gap: 5px !important;
          align-items: center !important;
          font-size: 0.9rem !important;
        }
        
        .mobile-timer-wrapper {
          display: flex !important;
          flex-direction: column !important;
          align-items: center !important;
          gap: 5px !important;
        }
        
        .timer-container {
          margin: 0 !important;
          padding: 3px 6px !important;
          border-radius: 12px !important;
          font-size: 0.85rem !important;
          background-color: rgba(255, 255, 255, 0.9) !important;
          order: -1 !important; /* Ensures timer is above score */
        }
        
        .timer {
          font-size: 0.9rem !important;
          padding: 2px 4px !important;
          margin: 0 !important;
        }
        
        #score {
          margin-top: 2px !important;
        }
        
        #imageDisplay {
          max-height: 250px !important;
          margin: 5px auto !important;
        }
        
        #feedback {
          margin: 5px !important;
          min-height: 20px !important;
        }
        
        #guess-input {
          margin: 5px 0 !important;
        }
        
        button {
          margin: 5px 2px !important;
          padding: 8px 10px !important;
        }
        
        /* Special handling for mobile nav bar to maintain flex layout */
        .mobile-nav-bar.mobile-container {
          display: flex !important;
          justify-content: space-between !important;
          text-align: left !important;
        }
      }
      
      /* Responsive styles for leaderboards */
      @media (max-width: 1000px) {
        .leaderboards-container {
          max-width: 700px;
        }
      }
      
      @media (max-width: 768px) {
        .leaderboards-container {
          grid-template-columns: 1fr 1fr;
          max-width: 600px;
          gap: 15px;
        }
      }
      
      @media (max-width: 600px) {
        .leaderboards-container {
          grid-template-columns: 1fr;
          max-width: 350px;
          gap: 10px; /* Reduced from 15px to 10px to match the game container spacing */
          margin-top: 10px; /* Add top margin to match spacing below game container */
        }
        
        .category-leaderboard {
          margin-bottom: 10px; /* Ensure consistent spacing between leaderboards */
        }
      }
      
      @media (max-width: 768px) {
        body {
          padding: 10px;
          display: flex;
          flex-direction: column;
          align-items: center;
        }
        
        /* Create space above game container for buttons */
        .mobile-nav-bar {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 10px 5px;
          margin-bottom: 15px;
          background-color: rgba(255, 249, 240, 0.9);
          border: 2px solid var(--border-color);
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        /* Style mobile buttons */
        .mobile-btn {
          background-color: #4a90e2;
          color: white;
          border: none;
          border-radius: 6px;
          padding: 8px 12px;
          font-size: 12px;
          font-weight: bold;
          cursor: pointer;
        }
        
        /* Hide desktop buttons on mobile */
        #admin-toggle-btn, 
        #logoutBtn, 
        button[onclick*="leaderboards.html"] {
          display: none;
        }
        
        #game-container {
          padding: 15px 10px;
          margin-top: 10px;
        }
        
        .category-container {
          flex-direction: column;
          align-items: center;
        }
        
        .timer-container {
          margin-left: 0;
          margin-top: 10px;
        }
        
        input, button {
          margin: 5px 2px;
          padding: 8px;
          font-size: 14px;
        }
        
        #leaderboard-container {
          width: 95%;
          margin-left: auto;
          margin-right: auto;
          background-color: #e8f5e9; /* Soft mint green that complements the theme */
        }
        
        /* Ensure modal is properly sized on mobile */
        .modal-content {
          width: 90%;
          max-width: 300px;
          padding: 15px;
        }
      }
      
      /* Small mobile devices */
      @media (max-width: 480px) {
        h1 {
          font-size: 1.5rem;
        }
        
        .category-leaderboard {
          min-width: 150px;
        }
        
        #guess-input {
          max-width: 100%;
        }
        
        #leaderboard-container {
          width: 95%;
          margin-left: auto;
          margin-right: auto;
          background-color: #e8f5e9;
        }
      }
    </style>
    <style>
      /* Style for welcome message on mobile */
      @media (max-width: 768px) {
        #welcome-message {
          font-size: 0.9rem !important;
          max-width: 150px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
      }
      
      /* Style for passcode input */
      #passcode-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 10000;
        justify-content: center;
        align-items: center;
      }
      
      #passcode-container {
        background: white;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        max-width: 300px;
        width: 80%;
      }
      
      #passcode-input {
        width: 100%;
        padding: 10px;
        margin: 15px 0;
        font-size: 16px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      
      #passcode-submit {
        background-color: #4a90e2;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
      }
      
      #passcode-submit:hover {
        background-color: #357abd;
      }
    </style>
    <!-- Audio Elements -->
    <!-- Optimized OGG audio elements with WAV fallbacks -->
    <audio id="correct-sound" preload="auto">
      <source src="sounds/correct.ogg" type="audio/ogg">
      <source src="sounds/correct.wav" type="audio/wav">
    </audio>
    <audio id="game-over-sound" preload="auto">
      <source src="sounds/game-over.ogg" type="audio/ogg">
      <source src="sounds/game-over.wav" type="audio/wav">
    </audio>
    <audio id="start-game-sound" preload="none">
      <source src="sounds/start-game.ogg" type="audio/ogg">
      <source src="sounds/start-game.wav" type="audio/wav">
    </audio>
    <audio id="high-score-sound" preload="none">
      <source src="sounds/high-score.ogg" type="audio/ogg">
      <source src="sounds/high-score.wav" type="audio/wav">
    </audio>
    <audio id="toggle-on-sound" preload="none">
      <source src="sounds/toggle-on.ogg" type="audio/ogg">
      <source src="sounds/toggle-on.wav" type="audio/wav">
    </audio>
    <audio id="toggle-off-sound" preload="none">
      <source src="sounds/toggle-off.ogg" type="audio/ogg">
      <source src="sounds/toggle-off.wav" type="audio/wav">
    </audio>
    <script>
      // Helper function to show notifications
      function showNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        document.body.appendChild(notification);

        // Add the 'show' class to trigger the animation
        setTimeout(() => {
          notification.style.opacity = '1';
          setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
              document.body.removeChild(notification);
            }, 300);
          }, 2000);
        }, 10);
      }
    </script>
  </head>
  <body>
    <!-- Passcode Modal -->
    <div id="passcode-modal">
      <div id="passcode-container">
        <h3>Enter Passcode</h3>
        <form id="passcode-form" onsubmit="return false;" autocomplete="off">
          <!-- Hidden username field for accessibility -->
          <div style="position: absolute; left: -9999px; width: 1px; height: 1px; overflow: hidden;">
            <label for="hidden-username">Username</label>
            <input type="text" id="hidden-username" name="username" autocomplete="username" tabindex="-1">
          </div>
          <input type="password" id="passcode-input" name="passcode" placeholder="Enter passcode" autocomplete="new-password">
          <button type="button" id="passcode-submit">Submit</button>
        </form>
      </div>
    </div>
    <!-- Fixed Top Navigation Bar -->
    <div id="fixed-nav-bar" style="position:fixed; top:0; left:0; width:100vw; height:85px; background:rgba(255,255,255,0.5); z-index:999; display:flex; justify-content:space-between; align-items:center; box-shadow:0 2px 12px rgba(0,0,0,0.07); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px); padding: 0 30px 0 20px;">
      <!-- Left Side: Admin Button and Welcome Message -->
      <div style="display: flex; align-items: center; gap: 20px;">
        <button id="admin-toggle-btn-mobile" class="mobile-btn" style="background:transparent; border:none; cursor:pointer; width:60px; height:60px; display:flex; align-items:center; justify-content:center; padding:0;">
          <img src="images/admin.png" alt="Nook" style="width:60px; height:60px;">
        </button>
        <!-- Welcome Message Speech Bubble -->
        <div id="welcome-message" class="speech-bubble" style="font-family: 'ACfont', sans-serif; font-size: 1rem; color: #5a3d2b; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); background-color: #ffffff; padding: 4px 10px; position: absolute; left: 85px; top: 50%; transform: translateY(-50%); z-index: 1000; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border-radius: 8px;">
          Welcome, <span id="username-display">Guest</span>!
        </div>
        <!-- Separate tail element for better control -->
        <div class="speech-bubble-tail" style="position: absolute; left: 79px; top: 50%; transform: translateY(-50%); width: 0; height: 0; border: 8px solid transparent; border-right-color: #ffffff; border-left: 0; border-bottom: 0; z-index: 1001;"></div>
      </div>
      
      <!-- Center: Standalone Mode Indicator -->
      <div id="standalone-indicator-container" style="position: absolute; left: 50%; transform: translateX(-50%); top: 15px; display: none;">
        <button id="standalone-mode-btn" style="background: #ff9800; color: white; border: none; border-radius: 20px; padding: 8px 16px; font-family: 'ACfont', sans-serif; font-size: 0.9rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer;">
          Standalone Mode
        </button>
      </div>
      
      <!-- Speech Bubble Styles -->
      <style>
        @keyframes pulse {
          0% { opacity: 0.4; }
          50% { opacity: 1; }
          100% { opacity: 0.4; }
        }
        
        .speech-bubble {
          position: relative;
          background: #ffffff;
          border-radius: 0.3em;
          line-height: 1.2;
        }
        
        .speech-bubble:after {
          content: '';
          position: absolute;
          left: -6px;
          top: 50%;
          width: 0;
          height: 0;
          border: 8px solid transparent;
          border-right-color: #ffffff;
          border-left: 0;
          border-bottom: 0;
          transform: translateY(-50%);
          z-index: 1001;
        }
        
        /* Mobile styles for welcome message */
        @media (max-width: 768px) {
          #welcome-message {
            font-size: 0.85rem !important;
            max-width: 140px;
            padding: 5px 12px;
            left: 75px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            border-radius: 8px;
          }
          
          .speech-bubble-tail {
            left: 69px;
            top: 50%;
            transform: translateY(-50%);
            display: block !important;
          }
          
          /* Hide standalone mode button on mobile */
          #standalone-indicator-container {
            display: none !important;
          }
        }
      </style>
      
      <!-- Right Side: Sound and Home Buttons -->
      <div style="position: absolute; right: 60px; top: 15px; display: flex; gap: 4px; align-items: center;">
        <button id="sound-toggle-mobile" class="mobile-btn" style="background:#fff; box-shadow:0 4px 16px rgba(0,0,0,0.18); border:none; cursor:pointer; width:48px; height:48px; border-radius:50%; display:flex; align-items:center; justify-content:center; transition:all 0.2s;">
          <img src="images/speaker.png" alt="Sound" style="width:42px; height:42px; border-radius:50%;">
        </button>
        <button id="logoutBtn-mobile" class="mobile-btn" style="background:#fff; box-shadow:0 4px 16px rgba(0,0,0,0.18); border:none; cursor:pointer; width:48px; height:48px; border-radius:50%; display:flex; align-items:center; justify-content:center; transition:all 0.2s;">
          <img src="images/home.png" alt="Home" style="width:42px; height:42px; border-radius:50%;">
        </button>
      </div>
    </div>
    <div style="width:100%; height:85px;"></div> <!-- Spacer for buttons -->
    
    <script>
      // Function to check if we're in standalone mode
      function isStandaloneMode() {
        return window.location.protocol === 'file:' || localStorage.getItem('force_standalone') === 'true' || localStorage.getItem('standalone_confirmed_this_session') === 'true';
      }
      
      // Function to check if the server is available
      async function checkServerAvailable() {
        const API_URL = 'http://localhost:8000';
        try {
          console.log('Checking server availability at:', API_URL);
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
          
          // Try direct health check first
          try {
            const response = await fetch(`${API_URL}/api/v1/health`, {
              method: 'GET',
              signal: controller.signal,
              mode: 'cors',
              headers: {
                'Accept': 'application/json'
              }
            });
            
            clearTimeout(timeoutId);
            if (response.ok) {
              console.log('Server is available');
              return true;
            }
          } catch (healthError) {
            console.log('Health check failed, trying root endpoint');
          }
          
          // If health check fails, try root endpoint
          const baseUrl = API_URL.split('/api')[0];
          const rootResponse = await fetch(baseUrl, {
            method: 'GET',
            signal: controller.signal,
            mode: 'cors',
            headers: {
              'Accept': 'application/json'
            }
          });
          
          clearTimeout(timeoutId);
          console.log('Root endpoint check result:', rootResponse.ok);
          return rootResponse.ok;
        } catch (error) {
          console.error('Server availability check failed:', error);
          return false;
        }
      }
      
      // Function to show or hide the standalone mode indicator
      function updateStandaloneModeIndicator() {
        const standaloneContainer = document.getElementById('standalone-indicator-container');
        const standaloneBtn = document.getElementById('standalone-mode-btn');
        
        if (isStandaloneMode()) {
          standaloneContainer.style.display = 'block';
          
          // Add click handler to show explanation when clicked
          standaloneBtn.onclick = function() {
            alert('You are playing in standalone mode. Your scores are saved locally and not shared online.');
          };
        } else {
          standaloneContainer.style.display = 'none';
        }
      }
      
      // Function to update the welcome message with the username
      function updateWelcomeMessage() {
        const username = localStorage.getItem('username') || sessionStorage.getItem('username') || 'Guest';
        const usernameDisplay = document.getElementById('username-display');
        if (usernameDisplay) {
          usernameDisplay.textContent = username;
        }
      }
      
      // Mobile navigation buttons event listeners
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize standalone mode status
        window.standaloneMode = isStandaloneMode();
        
        // Check server connection when the page loads
        document.addEventListener('DOMContentLoaded', async function() {
          // Update welcome message
          updateWelcomeMessage();
          
          // Check if we're already in standalone mode
          if (window.standaloneMode) {
            updateStandaloneModeIndicator();
            return;
          }
          
          // Try to check server connection
          if (typeof checkServerAvailable === 'function') {
            const serverAvailable = await checkServerAvailable();
            if (!serverAvailable && !localStorage.getItem('standalone_confirmed_this_session')) {
              // Server is not available, offer standalone mode
              if (confirm("Server connection unavailable. Your scores will be saved locally but not shared online. Continue in standalone mode?")) {
                localStorage.setItem('standalone_confirmed_this_session', 'true');
                localStorage.setItem('force_standalone', 'true');
                window.standaloneMode = true;
              } else {
                // User declined standalone mode, redirect to index
                window.location.href = 'index.html';
                return;
              }
            }
            
            // Update the standalone mode indicator
            updateStandaloneModeIndicator();
          } else {
            // Fallback if checkServerAvailable isn't available
            updateStandaloneModeIndicator();
          }
        });
        
        // Admin toggle button for mobile with secret activation pattern
        const adminToggleBtnMobile = document.getElementById('admin-toggle-btn-mobile');
        if (adminToggleBtnMobile) {
          let mobileClickCount = 0;
          let mobileClickTimer = null;
          const mobileRequiredClicks = 5;
          const mobileTimeWindow = 3000; // 3 seconds in milliseconds
          
          adminToggleBtnMobile.addEventListener('click', function() {
            // Increment click counter
            mobileClickCount++;
            
            // Add a small animation effect on click
            adminToggleBtnMobile.style.transform = 'scale(0.9)';
            setTimeout(() => {
              adminToggleBtnMobile.style.transform = 'scale(1)';
            }, 100);
            
            // Clear existing timer if it exists
            if (mobileClickTimer) {
              clearTimeout(mobileClickTimer);
            }
            
            // Set new timer to reset counter after timeWindow
            mobileClickTimer = setTimeout(() => {
              mobileClickCount = 0;
            }, mobileTimeWindow);
            
            // Check if we've reached the required number of clicks within the time window
            if (mobileClickCount >= mobileRequiredClicks) {
              // Reset counter
              mobileClickCount = 0;
              
              // Check if already in admin mode
              const adminToolsContainer = document.getElementById('admin-tools-container');
              const isHidden = adminToolsContainer.style.display === 'none';
              
              // If trying to activate admin mode, show passcode modal
              if (isHidden) {
                const passcodeModal = document.getElementById('passcode-modal');
                const passcodeInput = document.getElementById('passcode-input');
                const passcodeSubmit = document.getElementById('passcode-submit');
                
                // Show the modal
                passcodeModal.style.display = 'flex';
                setTimeout(() => passcodeInput.focus(), 100); // Delay focus to ensure modal is visible
                
                // Handle passcode submission with debounce to prevent multiple rapid submissions
                let isProcessing = false;
                const checkPasscode = () => {
                  if (isProcessing) return; // Prevent multiple submissions
                  isProcessing = true;
                  
                  // Get the stored passcode or use default
                  const storedPasscode = localStorage.getItem('adminPasscode') || 'T0mN00k'; // Default passcode
                  const enteredPasscode = passcodeInput.value;
                  
                  // Simple validation
                  if (!enteredPasscode) {
                    isProcessing = false;
                    return;
                  }
                  
                  // Check passcode
                  if (enteredPasscode === storedPasscode) {
                    adminToolsContainer.style.display = 'block';
                    passcodeModal.style.display = 'none';
                    passcodeInput.value = ''; // Clear the input
                    showNotification('Admin Mode Activated');
                  } else {
                    alert('Incorrect passcode');
                    passcodeInput.value = ''; // Clear the input
                    setTimeout(() => passcodeInput.focus(), 100);
                  }
                  
                  // Reset processing flag after a short delay
                  setTimeout(() => {
                    isProcessing = false;
                  }, 300);
                };
                
                // Handle Enter key
                passcodeInput.onkeydown = (e) => {
                  if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent form submission
                    checkPasscode();
                  } else if (e.key === 'Escape') {
                    passcodeModal.style.display = 'none';
                    passcodeInput.value = '';
                  }
                };
                
                // Handle button click
                passcodeSubmit.onclick = checkPasscode;
                
                // Handle clicking outside the modal to close
                passcodeModal.onclick = (e) => {
                  if (e.target === passcodeModal) {
                    passcodeModal.style.display = 'none';
                    passcodeInput.value = '';
                  }
                };
                
                return; // Don't proceed with the rest of the click handler
              } else {
                // Deactivating admin mode - no passcode needed
                adminToolsContainer.style.display = 'none';
              }
              
              // Show notification for admin mode activation
              showNotification('Admin Mode Deactivated');
            }
          });
        }
        
        // Home button for mobile
        const logoutBtnMobile = document.getElementById('logoutBtn-mobile');
        if (logoutBtnMobile) {
          logoutBtnMobile.addEventListener('click', function() {
            localStorage.removeItem('acnh_current_score');
            localStorage.removeItem('acnh_last_category');
            window.location.href = 'index.html';
          });
        }
        
        // Sound toggle button for mobile
        const soundToggleBtnMobile = document.getElementById('sound-toggle-mobile');
        if (soundToggleBtnMobile) {
          // Initialize sound state (off by default)
          soundEnabled = false;
          
          // Set initial image to muted
          const soundImg = soundToggleBtnMobile.querySelector('img');
          if (soundImg) {
            soundImg.src = 'images/speaker-mute.png';
            soundImg.alt = 'Sound Off';
          }
          
          soundToggleBtnMobile.addEventListener('click', function() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('acnh_sound_enabled', soundEnabled);
            
            // Add a small animation effect on click
            soundToggleBtnMobile.style.transform = 'scale(0.9)';
            setTimeout(() => {
              soundToggleBtnMobile.style.transform = 'scale(1)';
            }, 100);
            
            // Update the image based on sound state
            if (soundImg) {
              soundImg.src = soundEnabled ? 'images/speaker.png' : 'images/speaker-mute.png';
              soundImg.alt = soundEnabled ? 'Sound On' : 'Sound Off';
            }
          });
        }
        

      });
    </script>
    
    <!-- Desktop Buttons (hidden on mobile) -->
    <div class="nav-container" style="
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      z-index: 1000;
      background-color: #4a90e2;
      padding: 8px 12px;
      border-radius: 6px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease !important;
      display: none; /* Hide on mobile */">
      <button id="admin-toggle-btn" style="
        background-color: #4a90e2;
        color: white;
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-family: 'ACfont', Arial, sans-serif;
        transition: background-color 0.3s ease;
        display: none; /* Hide on mobile */">
        Show Admin Tools
      </button>
      <button id="logoutBtn" style="
        background-color: #4a90e2;
        color: white;
        padding: 8px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-family: 'ACfont', Arial, sans-serif;
        transition: background-color 0.3s ease;
        display: none; /* Hide on mobile */">Home</button>
    </div>

    <style>
      #admin-toggle-btn:hover {
        background-color: #357abd !important;
      }

      /* Start Game Button Hover Effect */
      #start-game-btn {
        transition: background-color 0.3s ease !important;
      }

      #start-game-btn:hover {
        background-color: #45a049 !important;
      }

      /* Back to Home Button Hover Effect */
      .logout-btn {
        transition: background-color 0.3s ease !important;
      }

      .logout-btn:hover {
        background-color: #357abd !important;
      }
    </style>

    <div
      id="greeting"
      style="position: absolute; top: 10px; left: 10px; font-weight: bold"
    ></div>
    

    
    <!-- Admin Tools Container -->
    <div id="admin-tools-container" style="display: none;">
      <h2>Admin Tools</h2>
      <button id="reset-fish-btn">Reset Fish Scores</button>
      <button id="reset-bugs-btn">Reset Bugs Scores</button>
      <button id="reset-sea-btn">Reset Sea Scores</button>
      <button id="reset-villagers-btn">Reset Villagers Scores</button>
      <button id="reset-to-defaults-btn" style="background-color: #4a90e2; margin-top: 15px;">Reset All Leaderboards</button>
      <button id="reset-all-btn" style="background-color: #ff6b6b;">Clear All Leaderboards</button>
      <button id="reset-high-score" style="background-color: #ffa500; margin-top: 15px;">Reset Personal Best</button>
    </div>
    <!-- Main Content Wrapper -->
    <div style="width: 100%; display: flex; flex-direction: column; align-items: center;">
      <!-- Game Container -->
      <div id="game-container" class="mobile-container">
      <div class="nav-container" style="
        position: absolute;
        top: 10px;
        left: 10px;
        display: flex;
        gap: 10px;
        align-items: center;
        z-index: 1000;
        background-color: #4a90e2;
        padding: 8px 12px;
        border-radius: 6px;
        color: white;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.3s ease !important;
        display: none; /* Hide on mobile */">
        <button id="admin-toggle-btn" style="
          background: none;
          border: none;
          cursor: pointer;
          padding: 0;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background-color: transparent;
          transition: transform 0.2s ease;
          position: absolute;
          z-index: 1000;
          display: none; /* Hide on mobile */">
          <img src="images/admin.png" alt="Nook" style="width: 40px; height: 40px; border-radius: 50%;">
        </button>
        <button id="sound-toggle" style="
          background: none;
          border: none;
          cursor: pointer;
          padding: 0;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background-color: transparent;
          transition: transform 0.2s ease;
          position: relative;
          margin: 0 auto;
          display: none; /* Hide on mobile */">
          <img src="images/speaker.png" alt="Sound" style="width: 40px; height: 40px; border-radius: 50%;">
        </button>
        <button id="logoutBtn" style="
          background: none;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 14px;
          font-family: 'ACfont', Arial, sans-serif;
          transition: background-color 0.3s ease;
          display: none; /* Hide on mobile */">Home</button>
      </div>
      
      <h1 style="
        font-size: 1.8rem;
        margin: 10px 0 20px;
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        background: linear-gradient(90deg, 
          #ff9aa2 0%,    /* Soft pink */
          #ffb7b2 10%,   /* Light coral */
          #ffdac1 20%,   /* Peach */
          #e2f0cb 30%,   /* Soft green */
          #b5ead7 40%,   /* Mint green */
          #c7ceea 50%,   /* Periwinkle */
          #b8d8d8 60%,   /* Powder blue */
          #f8c8dc 70%,   /* Pink */
          #ff9aa2 80%    /* Soft pink */
        );
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: rainbow 2s linear infinite;
      ">Welcome to the Identifier Game!<br><br>Choose category/difficulty below.</h1>
      <div id="category-selector" class="category-container" style="display: flex; flex-direction: column; align-items: center; gap: 10px; margin: 10px 0; width: 100%;">
        <div style="display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 200px;">
          <label for="category" style="margin-bottom: 5px; font-size: 0.9rem; width: 100%; text-align: center;">Category</label>
          <select id="category" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #8b4513; font-size: 0.9rem; min-width: 0;">
            <option value="fish">Fish</option>
            <option value="bugs">Bugs</option>
            <option value="sea">Sea Creatures</option>
            <option value="villagers">Villagers</option>
          </select>
        </div>
        
        <div style="display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 200px;">
          <label for="difficulty" style="margin-bottom: 5px; font-size: 0.9rem; width: 100%; text-align: center;">Difficulty</label>
          <select id="difficulty" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #8b4513; font-size: 0.9rem; min-width: 0;">
            <option value="15000">Easy (15s)</option>
            <option value="10000">Medium (10s)</option>
            <option value="5000">Hard (5s)</option>
          </select>
        </div>
      </div>
      <div class="high-score-container">
        <div id="high-score">Personal Best: 0</div>
        <button id="start-game-btn" style="background-color: #4CAF50;">Start Game</button>
      </div>
      
      <div class="sound-settings" style="margin-top: 10px; display: flex; justify-content: center; align-items: center;">
      </div>
      <div class="score-container">
        <div class="mobile-timer-wrapper">
          <div class="timer-container">
            <div id="timer" class="timer">Time: 15</div>
          </div>
          <div id="score">Score: 0</div>
        </div>
      </div>
      <div class="loading-leaf"></div>
      <img id="imageDisplay" src="" alt="Loading..." />

      <div id="feedback" aria-live="polite"></div>

      <input
        type="text"
        id="guess-input"
        placeholder="Enter your guess..."
        autocomplete="off"
        disabled
        style="display: none"
      />
      <button id="submit-guess" style="display: none">Submit</button>
      <button id="next-btn" style="display: none">Next Item</button>
      <button id="try-again-btn" style="display: none">Try Again</button>
      <button id="end-game-btn" style="background-color: #ff6b6b; margin-top: 20px; display: none">End Game</button>
    </div>

    </div>
    
    
    
    <!-- Leaderboards-->
    <div class="leaderboards-container">
    <div class="category-leaderboard" id="fish-leaderboard">
      <h3>Fish</h3>
      <div id="fish-scores"></div>
    </div>
    <div class="category-leaderboard" id="bugs-leaderboard">
      <h3>Bugs</h3>
      <div id="bugs-scores"></div>
    </div>
    <div class="category-leaderboard" id="sea-leaderboard">
      <h3>Sea Creatures</h3>
      <div id="sea-scores"></div>
    </div>
    <div class="category-leaderboard" id="villagers-leaderboard">
      <h3>Villagers</h3>
      <div id="villagers-scores"></div>
    </div>
    </div>
    <!-- High Score Modal -->
    <div id="highScoreModal" class="modal">
      <div class="modal-content">
        <h2>New High Score!</h2>
        <p>Congratulations! You scored <span id="finalScore"></span> points!</p>
        <div id="placementMessage"></div>
        <p>Enter your name for the leaderboard:</p>
        <input type="text" id="playerName" placeholder="Your name" maxlength="10" style="width: 150px; padding: 8px; font-size: 14px;" />
        <div class="modal-buttons">
          <button id="submitScore" class="modal-btn submit-btn">Submit</button>
          <button id="skipSubmit" class="modal-btn skip-btn">Skip</button>
        </div>
      </div>
    </div>

    <script>
      const NOOKIPEDIA_API_KEY = "8a10f688-39d6-40b8-8426-744f30542e94"; // API key
      const apiEndpoint = "https://api.nookipedia.com";
      const apiVersion = "1.0.0";
      const imageDisplay = document.getElementById("imageDisplay");
      const guessInput = document.getElementById("guess-input");
      const submitButton = document.getElementById("submit-guess");
      const nextButton = document.getElementById("next-btn");
      const feedbackElement = document.getElementById("feedback");
      const scoreElement = document.getElementById("score");
      const highScoreElement = document.getElementById("high-score");
      const categorySelector = document.getElementById("category");
      const difficultySelector = document.getElementById("difficulty");
      const logoutBtn = document.getElementById("logoutBtn");
      const adminToggleBtn = document.getElementById("admin-toggle-btn");
      const adminToolsContainer = document.getElementById("admin-tools-container");
      
      // Sound Manager - Clean implementation with OGG support
      const SoundManager = {
        enabled: false,
        hasUserInteracted: false,
        sounds: {},
        
        // Sound file configurations - optimized OGG files with WAV fallbacks
        soundConfigs: {
          'correct': '/sounds/correct.ogg',
          'game-over': '/sounds/game-over.ogg',
          'start-game': '/sounds/start-game.ogg',
          'high-score': '/sounds/high-score.ogg',
          'toggle-on': '/sounds/toggle-on.ogg',
          'toggle-off': '/sounds/toggle-off.ogg'
        },
        
        // Initialize the sound manager
        init: function() {
          try {
            // Load sound preference from localStorage
            const savedPreference = localStorage.getItem('acnh_sound_enabled');
            if (savedPreference !== null) {
              this.enabled = savedPreference === 'true';
            }
            
            // Initialize audio elements
            this.initAudioElements();
            
            // Update UI
            this.updateToggleUI();
            
            console.log('SoundManager initialized with OGG files:', {
              enabled: this.enabled,
              soundConfigs: this.soundConfigs
            });
            
            return this;
          } catch (error) {
            console.error('Error initializing SoundManager:', error);
            return this;
          }
        },
        
        // Initialize audio elements
        initAudioElements: function() {
          try {
            for (const [soundId, src] of Object.entries(this.soundConfigs)) {
              const audioElement = document.getElementById(`${soundId}-sound`);
              if (audioElement) {
                this.sounds[soundId] = audioElement;
                console.log(`Initialized sound: ${soundId}`);
              } else {
                console.warn(`Audio element not found: ${soundId}-sound`);
              }
            }
          } catch (error) {
            console.error('Error initializing audio elements:', error);
          }
        },
        
        // Play a sound by ID
        play: function(soundId) {
          try {
            // Check if sound is enabled and user has interacted
            if (!this.enabled || !this.hasUserInteracted) {
              const reason = !this.enabled ? 'sound is disabled' : 'no user interaction yet';
              console.log(`Sound playback prevented: ${reason}`);
              return Promise.resolve(false);
            }
            
            // Get the sound element
            const sound = this.sounds[soundId];
            if (!sound) {
              console.error(`Sound not found: ${soundId}. Available sounds:`, Object.keys(this.sounds));
              return Promise.resolve(false);
            }
            
            // Reset and prepare for playback
            sound.currentTime = 0;
            sound.volume = 0.5;
            
            // Try to play the sound
            const playPromise = sound.play();
            
            if (playPromise !== undefined) {
              return playPromise
                .then(() => {
                  console.log(`Sound playback started successfully: ${soundId}`);
                  return true;
                })
                .catch(error => {
                  console.error(`Error playing sound ${soundId}:`, error);
                  return false;
                });
            }
            
            // For browsers that don't return a promise
            console.log(`Playback started (legacy browser): ${soundId}`);
            return Promise.resolve(true);
            
          } catch (error) {
            console.error(`Unexpected error playing sound ${soundId}:`, error);
            return Promise.resolve(false);
          }
        },
        
        // Toggle sound on/off
        toggle: function(event) {
          try {
            if (event) event.preventDefault();
            
            // Mark that user has interacted with sound controls
            this.hasUserInteracted = true;
            
            // Toggle the enabled state
            this.enabled = !this.enabled;
            
            // Save preference to localStorage
            localStorage.setItem('acnh_sound_enabled', this.enabled.toString());
            
            // Update the UI
            this.updateToggleUI();
            
            // Play appropriate toggle sound
            const soundToPlay = this.enabled ? 'toggle-on' : 'toggle-off';
            this.play(soundToPlay);
            
            console.log('Sound toggled:', {
              enabled: this.enabled,
              soundPlayed: soundToPlay
            });
            
          } catch (error) {
            console.error('Error in sound toggle:', error);
            this.updateToggleUI();
          }
        },
        
        // Update toggle UI
        updateToggleUI: function() {
          try {
            const soundToggle = document.getElementById('sound-toggle');
            if (soundToggle) {
              let icon = soundToggle.querySelector('img, span');
              if (!icon) {
                icon = document.createElement('span');
                soundToggle.appendChild(icon);
              }
              
              if (icon.tagName === 'SPAN') {
                icon.textContent = this.enabled ? '' : '';
              }
              
              soundToggle.title = this.enabled ? 'Mute sound' : 'Unmute sound';
            }
            
            // Update mobile toggle as well
            const soundToggleMobile = document.getElementById('sound-toggle-mobile');
            if (soundToggleMobile) {
              const img = soundToggleMobile.querySelector('img');
              if (img) {
                img.src = this.enabled ? 'images/speaker.png' : 'images/speaker-mute.png';
                img.alt = this.enabled ? 'Sound On' : 'Sound Off';
              }
            }
            
          } catch (error) {
            console.error('Error updating sound toggle UI:', error);
          }
        },
        
        // Create audio elements dynamically if they don't exist
        createAudioElements: function() {
          try {
            console.log('Creating audio elements dynamically...');
            const head = document.head || document.getElementsByTagName('head')[0];
            
            for (const [id, src] of Object.entries(this.soundConfigs)) {
              // Check if element already exists
              if (document.getElementById(`${id}-sound`)) {
                console.log(`Audio element ${id} already exists`);
                continue;
              }
              
              // Create audio element
              const audio = document.createElement('audio');
              audio.id = `${id}-sound`;
              audio.preload = 'auto';
              
              // Create source element
              const source = document.createElement('source');
              source.src = src;
              source.type = 'audio/wav';
              
              // Add fallback text
              const fallback = document.createTextNode('Your browser does not support the audio element.');
              
              // Assemble the audio element
              audio.appendChild(source);
              audio.appendChild(fallback);
              
              // Add to document
              document.body.appendChild(audio);
              
              // Initialize the audio element
              this.initAudioElement(audio);
              
              console.log(`Created audio element: ${id}-sound`);
            }
            
          } catch (error) {
            console.error('Error creating audio elements:', error);
          }
        },
        
        init: function() {
          try {
            console.log('=== SOUND MANAGER INIT ===');
            
            // Check for existing interaction
            const savedSoundState = localStorage.getItem('soundEnabled');
            console.log('Saved sound state from localStorage:', savedSoundState);
            
            this.hasUserInteracted = savedSoundState !== null;
            this.enabled = this.hasUserInteracted ? (savedSoundState === 'true') : false;
            
            console.log('Initialized with - enabled:', this.enabled, 'hasUserInteracted:', this.hasUserInteracted);
            
            // Create audio elements if they don't exist
            this.createAudioElements();
            
            // Initialize all sound elements
            this.initAudioElements();
            
            // Make soundManager globally available for debugging
            window.soundManager = this;
            
            // Update the UI to reflect current state
            this.updateToggleUI();
            
            console.log('SoundManager initialization complete');
            
          } catch (error) {
            console.error('Error initializing SoundManager:', error);
          }
          
          return this;
        },
        
        // Lazy load audio on first play attempt
        lazyLoadAudio: function(soundId) {
          return new Promise((resolve) => {
            const audioElement = document.getElementById(`${soundId}-sound`);
            if (!audioElement) {
              console.warn(`Audio element not found: ${soundId}-sound`);
              resolve(false);
              return;
            }
            
            // If already loaded or loading, resolve immediately
            if (audioElement.readyState >= 2 || audioElement.preload === 'auto') {
              resolve(true);
              return;
            }
            
            // Load the audio
            console.log(`Lazy loading audio: ${soundId}`);
            audioElement.preload = 'auto';
            audioElement.load();
            
            // Wait for it to be ready
            const onCanPlay = () => {
              audioElement.removeEventListener('canplay', onCanPlay);
              audioElement.removeEventListener('error', onError);
              resolve(true);
            };
            
            const onError = () => {
              audioElement.removeEventListener('canplay', onCanPlay);
              audioElement.removeEventListener('error', onError);
              console.error(`Failed to lazy load audio: ${soundId}`);
              resolve(false);
            };
            
            audioElement.addEventListener('canplay', onCanPlay);
            audioElement.addEventListener('error', onError);
            
            // Timeout after 3 seconds
            setTimeout(() => {
              audioElement.removeEventListener('canplay', onCanPlay);
              audioElement.removeEventListener('error', onError);
              resolve(audioElement.readyState >= 2);
            }, 3000);
          });
        },
        
        // Helper to resume AudioContext if suspended
        resumeAudioContext: function() {
          if (window.AudioContext || window.webkitAudioContext) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (this.audioContext) {
              if (this.audioContext.state === 'suspended') {
                console.log('Resuming suspended AudioContext...');
                return this.audioContext.resume()
                  .then(() => {
                    console.log('AudioContext resumed successfully');
                    return true;
                  });
              }
              return Promise.resolve(true);
            } else {
              // Create a new AudioContext if none exists
              this.audioContext = new AudioContext();
              return Promise.resolve(true);
            }
          }
          return Promise.resolve(false);
        },
        
        toggle: function(event) {
          try {
            // Prevent default to avoid any default button behavior
            if (event) event.preventDefault();
            
            console.log('=== SOUND TOGGLE REQUESTED ===');
            console.log('Current sound state:', {
              enabled: this.enabled,
              hasUserInteracted: this.hasUserInteracted,
              availableSounds: Object.keys(this.sounds)
            });
            
            // Mark that user has interacted with sound controls
            this.hasUserInteracted = true;
            
            // Toggle the enabled state
            const wasEnabled = this.enabled;
            this.enabled = !wasEnabled;
            
            // Save preference to localStorage
            localStorage.setItem('acnh_sound_enabled', this.enabled);
            console.log(`Sound ${this.enabled ? 'enabled' : 'disabled'}`);
            
            // Determine which sound to play
            const soundToPlay = this.enabled ? 'toggle-on' : 'toggle-off';
            console.log(`Will play sound: ${soundToPlay}`);
            
            // Force play the toggle sound (bypassing the enabled check)
            const currentState = this.enabled;
            this.enabled = true; // Temporarily enable for the toggle sound
            
            // Play the sound with error handling
            this.play(soundToPlay)
              .then(success => {
                if (!success) {
                  console.warn(`Failed to play ${soundToPlay} sound`);
                }
              })
              .catch(e => {
                console.error(`Error playing ${soundToPlay} sound:`, e);
              })
              .finally(() => {
                // Restore the original state
                this.enabled = currentState;
                
                // Update the UI to reflect the new state
                this.updateToggleUI();
                
                console.log('Toggle completed. New state:', {
                  enabled: this.enabled,
                  soundPlayed: soundToPlay
                });
              });
            
          } catch (error) {
            console.error('Error in sound toggle:', error);
            // Ensure UI is updated even if there's an error
            this.updateToggleUI();
          }
        },
        
        updateToggleUI: function() {
          try {
            const soundToggle = document.getElementById('sound-toggle');
            if (!soundToggle) {
              console.error('Sound toggle button not found');
              return;
            }
            
            let icon = soundToggle.querySelector('img, span');
            
            // If no icon exists, create one
            if (!icon) {
              icon = document.createElement('span');
              soundToggle.appendChild(icon);
            }
            
            // Always use emoji for consistency
            if (icon.tagName === 'IMG') {
              const emoji = document.createElement('span');
              emoji.textContent = this.enabled ? '' : '';
              soundToggle.replaceChild(emoji, icon);
            } else if (icon.tagName === 'SPAN') {
              icon.textContent = this.enabled ? '' : '';
            }
            
            // Update title for accessibility
            soundToggle.title = this.enabled ? 'Mute sound' : 'Unmute sound';
            soundToggle.setAttribute('aria-pressed', !this.enabled);
            
          } catch (error) {
            console.error('Error updating sound toggle UI:', error);
          }
        },
        
        addTestButton: function() {
          try {
            // Check if test button already exists
            if (document.getElementById('sound-test-button')) {
              return;
            }
            
            // Create test button
            const testButton = document.createElement('button');
            testButton.id = 'sound-test-button';
            testButton.textContent = ' Test Sound';
            testButton.style.position = 'fixed';
            testButton.style.bottom = '10px';
            testButton.style.right = '10px';
            testButton.style.padding = '8px 16px';
            testButton.style.borderRadius = '20px';
            testButton.style.border = '2px solid #4CAF50';
            testButton.style.backgroundColor = '#4CAF50';
            testButton.style.color = 'white';
            testButton.style.fontWeight = 'bold';
            testButton.style.cursor = 'pointer';
            
            document.body.appendChild(testButton);
            
          } catch (error) {
            console.error('Error adding test button:', error);
          }
        },
        
        testAllSounds: function() {
          console.log('=== TESTING ALL SOUNDS ===');
          
          // First, ensure we have user interaction
          this.hasUserInteracted = true;
          
          // Temporarily enable sound for testing
          const wasEnabled = this.enabled;
          this.enabled = true;
          
          // Test each sound with a delay between them
          const sounds = Object.keys(this.sounds);
          let delay = 0;
          
          sounds.forEach((soundId, index) => {
            setTimeout(() => {
              console.log(`\n--- Testing sound: ${soundId} (${index + 1}/${sounds.length}) ---`);
              this.play(soundId)
                .then(success => {
                  console.log(`Sound test ${success ? 'succeeded' : 'failed'}: ${soundId}`);
                })
                .catch(e => {
                  console.error(`Error testing sound ${soundId}:`, e);
                });
            }, delay);
            
            // Add 1.5 seconds between sounds
            delay += 1500;
          });
          
          // Restore original state after all sounds have played
          setTimeout(() => {
            this.enabled = wasEnabled;
            console.log('=== SOUND TESTING COMPLETE ===');
          }, delay + 1000);
        },
        
        // Test sound functionality  
        testSound: function(soundId) {
          console.log(`Testing sound: ${soundId}`);
          this.hasUserInteracted = true;
          const wasEnabled = this.enabled;
          this.enabled = true;
          
          this.play(soundId)
            .then(success => {
              console.log(`Sound test ${success ? 'succeeded' : 'failed'}: ${soundId}`);
            })
            .catch(e => {
              console.error(`Error testing sound ${soundId}:`, e);
            })
            .finally(() => {
              this.enabled = wasEnabled;
            });
        }
      };
      
      // Initialize sound manager
      const soundManager = SoundManager.init();
      
      // Add Start Game button event handler
      document.addEventListener('DOMContentLoaded', function() {
        const startGameButton = document.getElementById('start-game-btn');
        if (startGameButton) {
          startGameButton.addEventListener('click', function() {
            console.log('Start Game button clicked');
            
            // Play start game sound
            if (soundManager) {
              soundManager.play('start-game');
            }
            
            // Hide the start game button
            startGameButton.style.display = 'none';
            
            // Start the game by initializing
            initGame();
            
            // Start the timer
            startTimer();
            
            // Update feedback
            const feedbackElement = document.getElementById('feedback');
            if (feedbackElement) {
              feedbackElement.textContent = 'Game started! Good luck!';
              feedbackElement.className = 'correct';
              setTimeout(() => {
                feedbackElement.textContent = '';
                feedbackElement.className = '';
              }, 2000);
            }
          });
        }
      });
      
      // Function to test direct audio playback
      function testDirectAudioPlayback() {
        console.log('=== TESTING DIRECT AUDIO PLAYBACK ===');
        
        // Create a new audio context
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioContext = new AudioContext();
        
        console.log('AudioContext state:', audioContext.state);
        
        // Try to play a simple oscillator sound
        try {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
          gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          console.log('Starting oscillator...');
          oscillator.start();
          
          // Stop after 1 second
          setTimeout(() => {
            oscillator.stop();
            console.log('Oscillator stopped');
          }, 1000);
          
        } catch (e) {
          console.error('Error with Web Audio API:', e);
        }
      }
      
      // Direct sound test function
      function testSoundPlayback() {
        console.log('=== SOUND PLAYBACK TEST ===');
        
        // Create a new audio element for testing
        const testAudio = new Audio('/sounds/toggle-on.wav');
        testAudio.volume = 0.5;
        
        // Log audio element state
        console.log('Test audio element created:', testAudio);
        
        // Add event listeners for debugging
        const events = ['canplay', 'canplaythrough', 'play', 'playing', 'pause', 'error', 'stalled', 'suspend', 'abort'];
        events.forEach(event => {
          testAudio.addEventListener(event, (e) => {
            console.log(`Audio ${event} event fired:`, e);
            if (event === 'error') {
              console.error('Audio error details:', {
                error: testAudio.error,
                readyState: testAudio.readyState,
                networkState: testAudio.networkState,
                src: testAudio.src
              });
            }
          });
        });
        
        // Try to play the sound
        console.log('Attempting to play test sound...');
        testAudio.play()
          .then(() => console.log('Test sound playback started successfully'))
          .catch(e => console.error('Test sound playback failed:', e));
      }
      
      // Add test sound button handler
      document.getElementById('test-sound')?.addEventListener('click', (e) => {
        e.preventDefault();
        console.clear(); // Clear console for better visibility
        console.log('=== SOUND TEST BUTTON CLICKED ===');
        
        // Run all available sound tests
        testDirectAudioPlayback();
        testSoundPlayback();
        
        // Also test the sound manager directly
        if (window.soundManager) {
          console.log('=== TESTING SOUND MANAGER ===');
          console.log('Sound manager state:', {
            enabled: soundManager.enabled,
            hasUserInteracted: soundManager.hasUserInteracted,
            availableSounds: Object.keys(soundManager.sounds)
          });
          
          // If sound is disabled, enable it first
          if (!soundManager.enabled) {
            console.log('Sound is disabled, enabling...');
            soundManager.enabled = true;
            soundManager.hasUserInteracted = true;
            soundManager.updateToggleUI();
          }
          
          console.log('Playing toggle-on sound through SoundManager...');
          soundManager.play('toggle-on');
        }
        
        // Test direct audio element access
        const toggleOnSound = document.getElementById('toggle-on-sound');
        if (toggleOnSound) {
          console.log('Direct audio element state:', {
            readyState: toggleOnSound.readyState,
            error: toggleOnSound.error,
            src: toggleOnSound.src || toggleOnSound.currentSrc
          });
          
          console.log('Attempting to play directly...');
          toggleOnSound.currentTime = 0;
          toggleOnSound.volume = 0.5;
          toggleOnSound.play().then(() => {
            console.log('Direct play successful!');
          }).catch(e => {
            console.error('Direct play failed:', e);
          });
        } else {
          console.error('toggle-on-sound element not found!');
        }
      });
      
      // Simple sound player function (kept for backward compatibility)
      function playSound(soundId) {
        try {
          // Convert old sound IDs to new format if needed
          const soundName = soundId.endsWith('-sound') ? soundId.replace('-sound', '') : soundId;
          soundManager.play(soundName);
        } catch (error) {
          console.error('Error in playSound:', error);
        }
      }
      
      // Toggle sound using the sound manager
      function toggleSound(event) {
        if (event) event.preventDefault();
        soundManager.toggle();
      }
      
      // Add click event listener to sound toggle button
      document.addEventListener('DOMContentLoaded', function() {
        const soundToggle = document.getElementById('sound-toggle');
        if (soundToggle) {
          soundToggle.addEventListener('click', function(event) {
            soundManager.toggle(event);
          });
          console.log('Sound toggle event listener added');
        } else {
          console.warn('Sound toggle button not found during initialization');
        }
        
        // Also add event listener for mobile sound toggle
        const soundToggleMobile = document.getElementById('sound-toggle-mobile');
        if (soundToggleMobile) {
          soundToggleMobile.addEventListener('click', function(event) {
            soundManager.toggle(event);
          });
          console.log('Mobile sound toggle event listener added');
        }
      });

    // Add event listener for admin tools toggle with secret activation pattern
    let clickCount = 0;
    let clickTimer = null;
    const requiredClicks = 5;
    const timeWindow = 3000; // 3 seconds in milliseconds
    
    adminToggleBtn.addEventListener("click", () => {
      // Increment click counter
      clickCount++;
      
      // Add a small animation effect on click
      adminToggleBtn.style.transform = 'scale(0.9)';
      setTimeout(() => {
        adminToggleBtn.style.transform = 'scale(1)';
      }, 100);
      
      // Clear existing timer if it exists
      if (clickTimer) {
        clearTimeout(clickTimer);
      }
      
      // Set new timer to reset counter after timeWindow
      clickTimer = setTimeout(() => {
        clickCount = 0;
      }, timeWindow);
      
      // Check if we've reached the required number of clicks within the time window
      if (clickCount >= requiredClicks) {
        // Reset counter
        clickCount = 0;
        
        // Toggle admin tools
        const isHidden = adminToolsContainer.style.display === "none";
        adminToolsContainer.style.display = isHidden ? "block" : "none";
        
        // Add a subtle notification that admin mode is activated/deactivated
        const notification = document.createElement('div');
        notification.textContent = isHidden ? 'Admin Mode Activated' : 'Admin Mode Deactivated';
        notification.style.position = 'fixed';
        notification.style.top = '50px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.backgroundColor = '#4a90e2';
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '5px';
        notification.style.zIndex = '9999';
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.3s ease';
        document.body.appendChild(notification);
        
        // Show and then fade out the notification
        setTimeout(() => {
          notification.style.opacity = '1';
          setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
              document.body.removeChild(notification);
            }, 300);
          }, 2000);
        }, 10);
      }
    });

    // Add event listener for sound toggle button
    const soundToggleBtn = document.getElementById('sound-toggle');
    soundToggleBtn.addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      soundToggleBtn.innerHTML = soundEnabled ? ' Sound: ON' : ' Sound: OFF';
      soundToggleBtn.style.backgroundColor = soundEnabled ? '#4a90e2' : '#cccccc';
      
      // Save sound preference to localStorage
      localStorage.setItem('acnh_sound_enabled', soundEnabled.toString());
    });
    
    // Load sound preference from localStorage
    const savedSoundPreference = localStorage.getItem('acnh_sound_enabled');
    if (savedSoundPreference !== null) {
      soundEnabled = savedSoundPreference === 'true';
      soundToggleBtn.innerHTML = soundEnabled ? ' Sound: ON' : ' Sound: OFF';
      soundToggleBtn.style.backgroundColor = soundEnabled ? '#4a90e2' : '#cccccc';
    }

      // Prevent right-click and dragging on image
      imageDisplay.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        return false;
      });

      // Prevent image dragging
      imageDisplay.addEventListener('dragstart', (e) => {
        e.preventDefault();
        return false;
      });
      imageDisplay.addEventListener('drag', (e) => {
        e.preventDefault();
        return false;
      });

      const leaderboardElement = document.getElementById("leaderboard");

      const urlParams = new URLSearchParams(window.location.search);
      const isGuest = urlParams.get("guest") === "true";

      if (isGuest) {
        logoutBtn.textContent = "Back to Home";
      }

      logoutBtn.addEventListener("click", () => {
        localStorage.removeItem("acnh_current_score");
        localStorage.removeItem("acnh_last_category");
        window.location.href = "index.html";
      });

      let score = 0;
      let highScore = localStorage.getItem("acnh_high_score") || 0;
      let currentItem = null;
      let currentCategory = null;
      let shownItems = {}; // Object to track shown items for each category
      let allItems = {}; // Store all items for each category
      let availableItems = []; // Current available items for the category
      let timerInterval = null;
      let timeLeft = 15; // Default to easy mode (15s)
      let maxTime = 15; // Will be updated based on difficulty
      let isLoadingItems = false; // Track if we're currently loading items
      let lastLoadedCategory = null; // Track the last loaded category
      let gameOver = false; // Flag to track if the game is over
      let currentlyDisplayingItem = null; // Track which item is being displayed
      let isTryingFallback = false; // Flag to prevent recursive fallback calls
      const timerDisplay = document.getElementById('timer');

      async function loadCategoryItems(category) {
        // If we've already loaded this category and have items, use them
        if (allItems[category]?.length > 0) {
          console.log(`Using cached items for ${category}`);
          return allItems[category];
        }
        
        // If we're already loading this category, wait for it to complete
        if (isLoadingItems) {
          console.log(`Already loading ${category}, waiting...`);
          // Wait with multiple retries before timing out
          for (let i = 0; i < 10; i++) { // Try up to 10 times (1 second total)
            await new Promise(resolve => setTimeout(resolve, 100));
            if (allItems[category]?.length > 0) {
              return allItems[category];
            }
          }
          // If we still don't have items after waiting, use fallback data
          console.log(`Timeout waiting for ${category} to load, using fallback data`);
          return getFallbackData(category);
        }
        
        // Set loading flag
        isLoadingItems = true;
        
        // Define the API endpoint based on the category
        let endpoint = "";
        switch (category) {
          case "fish":
            endpoint = "/nh/fish";
            break;
          case "bugs":
            endpoint = "/nh/bugs";
            break;
          case "sea":
            endpoint = "/nh/sea";
            break;
          case "villagers":
            endpoint = "/villagers";
            break;
          default:
            console.error("Invalid category:", category);
            isLoadingItems = false;
            return [];
        }
        
        // Use the Nookipedia API to get the items
        const apiKey = NOOKIPEDIA_API_KEY;
        const apiUrl = `${apiEndpoint}${endpoint}`;
        
        try {
          // Show loading leaf indicator
          const loadingLeaf = document.querySelector('.loading-leaf');
          if (loadingLeaf) loadingLeaf.style.display = 'block';
          
          // Attempt to fetch from API with a timeout to prevent long waits
          try {
            const response = await fetchWithTimeout(apiUrl, {
              headers: {
                "X-API-KEY": apiKey,
                "Accept-Version": apiVersion
              }
            });
            
            if (!response || !response.length) {
              console.log(`API returned empty data for ${category}, using fallback data`);
              throw new Error(`API request failed or returned empty data`);
            }
            
            console.log(`Loaded ${response.length} items for ${category} from API`);
            
            // Update last loaded category and clear loading flag
            lastLoadedCategory = category;
            isLoadingItems = false;
            
            // Process the data to ensure consistent format
            const processedItems = response.map(item => {
              return {
                name: item.name,
                image_url: item.image_url || null,
                // Add fallback image in case the API image fails to load
                fallback_image_url: `images/${category}/placeholder.svg`
              };
            });
            
            // Store the items in our global object
            allItems[category] = processedItems;
            
            // Initialize shown items for this category if it doesn't exist
            if (!shownItems[category]) {
              shownItems[category] = [];
            }
            
            // Hide loading indicators
            if (loadingLeaf) loadingLeaf.style.display = 'none';
            feedbackElement.textContent = "";
            
            return processedItems;
          } catch (error) {
            console.error("Error fetching from API:", error);
            throw error; // Let the outer catch block handle it
          }
          
        } catch (error) {
          console.error("Error loading items from API:", error);
          isLoadingItems = false; // Clear loading flag on error
          
          // Fallback to previously cached data if available
          if (allItems[category] && allItems[category].length > 0) {
            console.log(`Using cached items for ${category} due to API error`);
            return allItems[category];
          }
          
          // Hide loading indicators
          const loadingLeaf = document.querySelector('.loading-leaf');
          if (loadingLeaf) loadingLeaf.style.display = 'none';
          
          // Show error message
          feedbackElement.textContent = "Could not load items from API. Using local data.";
          
          // Use fallback data
          return getFallbackData(category);
        }
      }
      
      // Function to provide fallback data when API fails
      function getFallbackData(category) {
        console.log(`Using fallback data for ${category}`);
        // Store the fallback data in our global object so we don't try to fetch again
        if (!allItems[category]) {
          // Fallback to local data if API fails
          const mockData = {
          fish: [
            { name: "Sea Bass", image_url: "https://dodo.ac/np/images/d/d5/Sea_Bass_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Koi", image_url: "https://dodo.ac/np/images/7/7c/Koi_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Goldfish", image_url: "https://dodo.ac/np/images/a/a5/Goldfish_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Tuna", image_url: "https://dodo.ac/np/images/8/8c/Tuna_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Coelacanth", image_url: "https://dodo.ac/np/images/4/45/Coelacanth_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" }
            ],
            bugs: [
              { name: "Common Butterfly", image_url: "https://dodo.ac/np/images/8/8f/Common_Butterfly_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Monarch Butterfly", image_url: "https://dodo.ac/np/images/a/a9/Monarch_Butterfly_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Scorpion", image_url: "https://dodo.ac/np/images/6/6f/Scorpion_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Tarantula", image_url: "https://dodo.ac/np/images/0/0e/Tarantula_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Stinkbug", image_url: "https://dodo.ac/np/images/b/b4/Stinkbug_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" }
            ],
            sea: [
              { name: "Sea Star", image_url: "https://dodo.ac/np/images/1/1d/Sea_Star_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Sea Urchin", image_url: "https://dodo.ac/np/images/b/b9/Sea_Urchin_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Seaweed", image_url: "https://dodo.ac/np/images/5/53/Seaweed_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Pearl Oyster", image_url: "https://dodo.ac/np/images/1/11/Pearl_Oyster_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Scallop", image_url: "https://dodo.ac/np/images/d/d5/Scallop_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" }
            ],
            villagers: [
              { name: "Tom Nook", image_url: "https://dodo.ac/np/images/4/4f/Tom_Nook_NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "Isabelle", image_url: "https://dodo.ac/np/images/8/8e/Isabelle_NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "K.K. Slider", image_url: "https://dodo.ac/np/images/e/e0/K.K._NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "Blathers", image_url: "https://dodo.ac/np/images/b/b3/Blathers_NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "Celeste", image_url: "https://dodo.ac/np/images/9/93/Celeste_NH.png", fallback_image_url: "images/villagers/placeholder.svg" }
            ]
          };
          
          // Store the mock data for the selected category
          allItems[category] = mockData[category] || [];
          
          // Initialize shown items for this category if it doesn't exist
          if (!shownItems[category]) {
            shownItems[category] = [];
          }
          
          return allItems[category];
        }
      }

      function getAvailableItems(category) {
        if (!allItems[category]) {
          return [];
        }
        
        const shown = shownItems[category] || [];
        return allItems[category].filter(item => !shown.includes(item.name));
      }

      async function getRandomItem(category) {
        if (!category) return null;

        if (!allItems[category]) {
          return loadCategoryItems(category).then(() => getRandomItem(category));
        }

        const available = getAvailableItems(category);
        
        if (available.length === 0) {
          // Reset shown items when all items have been shown
          shownItems[category] = [];
          localStorage.setItem(`shown_items_${category}`, JSON.stringify([]));
          return getRandomItem(category);
        }

        // Get a random item from the available items
        const randomIndex = Math.floor(Math.random() * available.length);
        const item = available[randomIndex];

        // Add this item to the shown items list
        if (!shownItems[category]) {
          shownItems[category] = [];
        }
        shownItems[category].push(item.name);
        localStorage.setItem(`shown_items_${category}`, JSON.stringify(shownItems[category]));

        try {
          // First try to use the image URL from the item object if it exists
          if (item.image_url) {
            return {
              name: item.name,
              image_url: item.image_url
            };
          }
          
          // Otherwise try to fetch from API
          const imageUrl = `${apiEndpoint}/nh/${category}/${item.name}?api_key=${NOOKIPEDIA_API_KEY}`;
          const imageData = await fetchWithTimeout(imageUrl);
          
          if (imageData && imageData.data && imageData.data.image_url) {
            return {
              name: item.name,
              image_url: imageData.data.image_url
            };
          }
          
          // If API fetch fails, use fallback image
          return {
            name: item.name,
            image_url: item.fallback_image_url || `images/${category}/placeholder.svg`
          };
        } catch (error) {
          console.error('Error fetching image for item:', item.name, error);
          // Return the item with fallback image
          return {
            name: item.name,
            image_url: item.fallback_image_url || `images/${category}/placeholder.svg`
          };
        }
      }

      function showHighScoreModal(finalScore, category) {
        // Play high score sound
        playSound(highScoreSound);
        
        // Set the final score in the modal
        document.getElementById('finalScore').textContent = finalScore;
        
        // Show the modal
        const modal = document.getElementById('highScoreModal');
        modal.style.display = 'block';
        
        // Focus on the name input
        const playerNameInput = document.getElementById('playerName');
        playerNameInput.value = '';
        playerNameInput.focus();
        
        // Store category for later use
        modal.dataset.category = category;
        
        // Add event listeners for the buttons
        document.getElementById('submitScore').onclick = function() {
          submitHighScore(finalScore, category);
        };
        
        document.getElementById('skipSubmit').onclick = function() {
          closeHighScoreModal();
        };
        
        // Allow Enter key to submit
        playerNameInput.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            submitHighScore(finalScore, category);
          }
        });
      }
      
      function closeHighScoreModal() {
        document.getElementById('highScoreModal').style.display = 'none';
      }
      
      async function submitHighScore(finalScore, category) {
        const playerName = document.getElementById('playerName').value.trim();
        if (!playerName) {
          alert('Please enter your name or click Skip');
          return;
        }
        
        // Get the current username from localStorage or sessionStorage
        const username = localStorage.getItem('username') || sessionStorage.getItem('username') || playerName;
        
        // Check if we're in standalone mode
        if (isStandaloneMode()) {
          // Always confirm before switching to standalone mode
          if (!localStorage.getItem('standalone_confirmed_this_session')) {
            if (confirm("Server connection unavailable. Your scores will be saved locally but not shared online. Continue in standalone mode?")) {
              // Set a session flag to avoid multiple prompts in the same session
              localStorage.setItem('standalone_confirmed_this_session', 'true');
              localStorage.setItem('force_standalone', 'true');
            } else {
              // User declined standalone mode, redirect to index
              window.location.href = 'index.html';
              return;
            }
          }
          console.log('Running in standalone mode, saving score to local storage only');
          saveScoreToLocalStorage(playerName, finalScore, category);
          return;
        }
        
        try {
          // Get the JWT token for authentication
          const token = localStorage.getItem('token') || sessionStorage.getItem('token');
          
          // Prepare the headers
          const headers = {
            'Content-Type': 'application/json'
          };
          
          // Add authorization header if token exists
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
          }
          
          // Submit the score to the server with a timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
          
          const response = await fetch('/api/save-score', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify({
              category: category,
              score: finalScore
            }),
            signal: controller.signal
          }).catch(error => {
            // Mark API as unavailable for future calls
            window.apiUnavailable = true;
            throw error;
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`Failed to save score: ${response.status}`);
          }
          
          const result = await response.json();
          
          // Get the placement by fetching the updated leaderboard
          const leaderboardController = new AbortController();
          const leaderboardTimeoutId = setTimeout(() => leaderboardController.abort(), 2000);
          
          const leaderboardResponse = await fetch(`/api/leaderboard/${category}`, {
            signal: leaderboardController.signal
          }).catch(error => {
            window.apiUnavailable = true;
            throw error;
          });
          
          clearTimeout(leaderboardTimeoutId);
          
          if (!leaderboardResponse.ok) {
            throw new Error(`Failed to fetch leaderboard: ${leaderboardResponse.status}`);
          }
          
          const leaderboardData = await leaderboardResponse.json();
          
          // Find the placement of the new score
          const placement = leaderboardData.findIndex(entry => entry.username === username && entry.score === finalScore) + 1;
          
          // Show placement message
          showPlacementMessage(placement);
          
          // Close the modal
          closeHighScoreModal();
          
          // Update the displayed leaderboard
          updateLeaderboard();
          
        } catch (error) {
          console.log('Error with server, falling back to local storage');
          
          // Fall back to local storage if server request fails
          saveScoreToLocalStorage(playerName, finalScore, category);
        }
      }
      
      // Helper function to save score to localStorage and show placement
      function saveScoreToLocalStorage(playerName, finalScore, category) {
        // Get existing leaderboard data
        const savedLeaderboard = localStorage.getItem('acnh_leaderboard');
        let leaderboardData = {};
        
        if (savedLeaderboard) {
          try {
            leaderboardData = JSON.parse(savedLeaderboard);
          } catch (e) {
            console.error('Error parsing saved leaderboard:', e);
            leaderboardData = { ...DEFAULT_LEADERBOARD };
          }
        } else {
          leaderboardData = { ...DEFAULT_LEADERBOARD };
        }
        
        // Add the new score
        const newScore = {
            name: playerName,
            score: finalScore,
            date: new Date().toISOString().split('T')[0], // Format: YYYY-MM-DD
            isNew: true // Mark this as a new score for highlighting
        };
        
        // Add to the appropriate category
        if (!leaderboardData[category]) {
            leaderboardData[category] = [];
        }
        
        leaderboardData[category].push(newScore);
        
        // Sort scores in descending order
        leaderboardData[category].sort((a, b) => b.score - a.score);
        
        // Keep only top 10 scores
        leaderboardData[category] = leaderboardData[category].slice(0, 10);
        
        // Save the updated leaderboard to localStorage
        localStorage.setItem('acnh_leaderboard', JSON.stringify(leaderboardData));
        
        // Find the placement of the new score
        const placement = leaderboardData[category].findIndex(score => score.name === playerName && score.score === finalScore) + 1;
        
        // Show placement message
        showPlacementMessage(placement);
        
        // Close the modal
        closeHighScoreModal();
        
        // Update the displayed leaderboard
        updateLeaderboardUI(leaderboardData);
      }
      
      // Helper function to show placement message
      function showPlacementMessage(placement) {
        const placementMessage = document.getElementById('placementMessage');
        if (placement === 1) {
            placementMessage.innerHTML = '<p style="color: #ffd700; font-weight: bold;">You achieved 1st place! </p>';
        } else if (placement === 2) {
            placementMessage.innerHTML = '<p style="color: #c0c0c0; font-weight: bold;">You achieved 2nd place! </p>';
        } else if (placement === 3) {
            placementMessage.innerHTML = '<p style="color: #cd7f32; font-weight: bold;">You achieved 3rd place! </p>';
        } else {
            placementMessage.innerHTML = '<p style="color: #ffa500; font-weight: bold;">You achieved ' + placement + 'th place! </p>';
        }
      }
      
      function saveLeaderboard(data) {
        // In a real application, this would send the data to a server
        // For this demo, we'll store it in localStorage
        console.log('Leaderboard data updated:', data);
        
        // Save to localStorage for persistence
        localStorage.setItem('acnh_leaderboard', JSON.stringify(data));
        
        // Directly update the leaderboard UI with the new data
        updateLeaderboardUI(data);
      }
      
      // Check if a score is high enough to be on the leaderboard
      async function isHighScore(score, category) {
        try {
          // Check if we're in standalone mode
          if (isStandaloneMode()) {
            // Always confirm before switching to standalone mode
            if (!localStorage.getItem('standalone_confirmed_this_session')) {
              if (confirm("Server connection unavailable. Your scores will be saved locally but not shared online. Continue in standalone mode?")) {
                // Set a session flag to avoid multiple prompts in the same session
                // This will be cleared when the browser is closed
                localStorage.setItem('standalone_confirmed_this_session', 'true');
                localStorage.setItem('force_standalone', 'true');
              } else {
                // User declined standalone mode, redirect to index
                window.location.href = 'index.html';
                return false;
              }
            }
            throw new Error('Running in standalone mode');
          }
          
          // Fetch the current leaderboard from the server with a timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
          
          const response = await fetch(`/api/leaderboard/${category}`, {
            signal: controller.signal
          }).catch(error => {
            // Mark API as unavailable for future calls
            window.apiUnavailable = true;
            throw error;
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`Failed to fetch leaderboard: ${response.status}`);
          }
          
          const leaderboardData = await response.json();
          
          // If there are fewer than 10 scores, any score qualifies
          if (leaderboardData.length < 10) {
            return true;
          }
          
          // Otherwise, check if the score is higher than the lowest score on the leaderboard
          const lowestScore = leaderboardData[leaderboardData.length - 1].score;
          return score > lowestScore;
        } catch (error) {
          console.log('Using local leaderboard data for high score check');
          
          // Fall back to local storage if server request fails
          const savedLeaderboard = localStorage.getItem('acnh_leaderboard');
          if (savedLeaderboard) {
            try {
              const data = JSON.parse(savedLeaderboard);
              const categoryScores = data[category] || [];
              
              // If there are fewer than 10 scores, any score qualifies
              if (categoryScores.length < 10) {
                return true;
              }
              
              // Otherwise, check if the score is higher than the lowest score on the leaderboard
              const lowestScore = categoryScores[categoryScores.length - 1].score;
              return score > lowestScore;
            } catch (e) {
              console.error('Error parsing saved leaderboard:', e);
              return true; // Assume it's a high score if we can't check
            }
          } else {
            return true; // Assume it's a high score if we can't check
          }
        }
      }
      
      function updateLeaderboardUI(data) {
        const categories = ['fish', 'bugs', 'sea', 'villagers'];
        
        categories.forEach(category => {
          const scores = data[category] || [];
          const scoresElement = document.getElementById(`${category}-scores`);
          if (scoresElement) {
            // Clear existing content
            scoresElement.innerHTML = '';
            
            if (scores.length === 0) {
              scoresElement.innerHTML = '<div>No scores yet</div>';
              return;
            }
            
            // Add each score to the leaderboard with animation for new scores
            scores.forEach((score, index) => {
              const scoreDiv = document.createElement('div');
              scoreDiv.style.display = 'flex';
              scoreDiv.style.alignItems = 'center';
              
              // Determine if this is a newly added score (could be marked in the data)
              const isNewScore = score.isNew;
              
              // Create name span with appropriate styling
              const nameSpan = document.createElement('span');
              nameSpan.textContent = `${index + 1}. ${score.name}`;
              
              // Add medal colors for top 3
              if (index === 0) {
                nameSpan.style.color = '#ff00ff'; // 1st place
                nameSpan.style.textShadow = '1px 1px 2px black';
              } else if (index === 1) {
                nameSpan.style.color = '#ffff00'; // 2nd place
                nameSpan.style.textShadow = '1px 1px 2px black';
              } else if (index === 2) {
                nameSpan.style.color = '#00ffff'; // 3rd place
                nameSpan.style.textShadow = '1px 1px 2px black';
              }
              
              // Create divider - positioned higher to align with text
              const divider = document.createElement('span');
              divider.style.flexGrow = '1';
              divider.style.borderBottom = '1px solid black';
              divider.style.margin = '0 10px';
              divider.style.transform = 'translateY(-4px)'; // Move it up to center with text
              
              // Create score span
              const scoreSpan = document.createElement('span');
              scoreSpan.textContent = score.score;
              
              // Apply same color to score as name
              if (index === 0) {
                scoreSpan.style.color = '#ff00ff';
                scoreSpan.style.textShadow = '1px 1px 2px black';
              } else if (index === 1) {
                scoreSpan.style.color = '#ffff00';
                scoreSpan.style.textShadow = '1px 1px 2px black';
              } else if (index === 2) {
                scoreSpan.style.color = '#00ffff';
                scoreSpan.style.textShadow = '1px 1px 2px black';
              }
              
              // Add highlight animation for new scores
              if (isNewScore) {
                scoreDiv.style.animation = 'highlight 2s ease-in-out';
                scoreDiv.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
                
                // Add keyframes for highlight animation if not already added
                if (!document.getElementById('highlight-animation')) {
                  const style = document.createElement('style');
                  style.id = 'highlight-animation';
                  style.textContent = `
                    @keyframes highlight {
                      0% { background-color: rgba(76, 175, 80, 0.3); }
                      50% { background-color: rgba(76, 175, 80, 0.6); }
                      100% { background-color: transparent; }
                    }
                  `;
                  document.head.appendChild(style);
                }
                
                // Remove highlight after animation
                setTimeout(() => {
                  scoreDiv.style.backgroundColor = 'transparent';
                }, 2000);
              }
              
              // Assemble the score entry
              scoreDiv.appendChild(nameSpan);
              scoreDiv.appendChild(divider);
              scoreDiv.appendChild(scoreSpan);
              
              // Add to leaderboard
              scoresElement.appendChild(scoreDiv);
            });
          }
        });
      }
      
      // Default leaderboard data
      const DEFAULT_LEADERBOARD = {
        fish: [
          { name: "Kapp'n", score: 10 },
          { name: "Leif", score: 9 },
          { name: "Cyrus", score: 8 },
          { name: "Kicks", score: 7 },
          { name: "Redd", score: 6 },
          { name: "Mabel", score: 5 },
          { name: "Saharah", score: 4 },
          { name: "Gulliver", score: 3 },
          { name: "Wisp", score: 2 },
          { name: "Harvey", score: 1 }
        ],
        bugs: [
          { name: "Flick", score: 10 },
          { name: "Cube", score: 9 },
          { name: "Kapp'n", score: 8 },
          { name: "Kiki", score: 7 },
          { name: "Cyrus", score: 6 },
          { name: "Kicks", score: 5 },
          { name: "Redd", score: 4 },
          { name: "Mabel", score: 3 },
          { name: "Saharah", score: 2 },
          { name: "Wisp", score: 1 }
        ],
        sea: [
          { name: "Gulliver", score: 10 },
          { name: "JJ", score: 9 },
          { name: "Redd", score: 8 },
          { name: "Kapp'n", score: 7 },
          { name: "Flick", score: 6 },
          { name: "Cyrus", score: 5 },
          { name: "Kicks", score: 4 },
          { name: "Mabel", score: 3 },
          { name: "Saharah", score: 2 },
          { name: "Wisp", score: 1 }
        ],
        villagers: [
          { name: "K.K. Slider", score: 10 },
          { name: "Kapp'n", score: 9 },
          { name: "Tom Nook", score: 8 },
          { name: "Cyrus", score: 7 },
          { name: "Kicks", score: 6 },
          { name: "Redd", score: 5 },
          { name: "Mabel", score: 4 },
          { name: "Saharah", score: 3 },
          { name: "Gulliver", score: 2 },
          { name: "Harvey", score: 1 }
        ]
      };

      // Function to detect if we're running in standalone mode (without a server)
      function isStandaloneMode() {
        // Check URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const guestParam = urlParams.get('guest');
        
        // Check if running via file:// protocol
        const isFileProtocol = window.location.protocol === 'file:';
        
        // Check if API has been marked as unavailable
        const apiUnavailable = window.apiUnavailable === true;
        
        // Check if force_standalone is set in localStorage
        const forceStandalone = localStorage.getItem('force_standalone') === 'true';
        
        return guestParam === 'true' || isFileProtocol || apiUnavailable || forceStandalone;
      }
      
      async function updateLeaderboard() {
        try {
          // Get the current category
          const category = categorySelector.value || 'fish';
          
          // Check if we're in standalone mode
          if (isStandaloneMode()) {
            // Always confirm before switching to standalone mode
            if (!localStorage.getItem('standalone_confirmed_this_session')) {
              if (confirm("Server connection unavailable. Your scores will be saved locally but not shared online. Continue in standalone mode?")) {
                // Set a session flag to avoid multiple prompts in the same session
                localStorage.setItem('standalone_confirmed_this_session', 'true');
                localStorage.setItem('force_standalone', 'true');
              } else {
                // User declined standalone mode, redirect to index
                window.location.href = 'index.html';
                return;
              }
            }
            throw new Error('Running in standalone mode');
          }
          
          // Fetch leaderboard data from the server with a timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
          
          const response = await fetch(`/api/leaderboard/${category}`, {
            signal: controller.signal
          }).catch(error => {
            // Mark API as unavailable for future calls
            window.apiUnavailable = true;
            throw error;
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`Failed to fetch leaderboard: ${response.status}`);
          }
          
          const leaderboardData = await response.json();
          
          // Format the data for the UI
          const formattedData = {};
          formattedData[category] = leaderboardData.map(entry => ({
            name: entry.username,
            score: entry.score,
            date: new Date(entry.date).toISOString().split('T')[0]
          }));
          
          // Update the UI with the fetched data
          updateLeaderboardUI(formattedData);
        } catch (error) {
          console.log('Using local leaderboard data');
          // Fall back to local data if server request fails
          const savedLeaderboard = localStorage.getItem('acnh_leaderboard');
          if (savedLeaderboard) {
            try {
              const data = JSON.parse(savedLeaderboard);
              updateLeaderboardUI(data);
            } catch (e) {
              console.error('Error parsing saved leaderboard:', e);
              // If all else fails, use default data
              updateLeaderboardUI(DEFAULT_LEADERBOARD);
            }
          } else {
            updateLeaderboardUI(DEFAULT_LEADERBOARD);
          }
        }
      }

      function resetToDefaults() {
        localStorage.setItem('acnh_leaderboard', JSON.stringify(DEFAULT_LEADERBOARD));
        updateLeaderboardUI(DEFAULT_LEADERBOARD);
      }

      async function initGame(isInitialLoad = false) {
        // Prevent multiple initializations
        if (isLoadingItem) {
          console.log('Game initialization already in progress, waiting...');
          return;
        }
        
        try {
          const category = categorySelector.value;
          console.log(`Initializing game for category: ${category}`);
          
          // Reset score only if changing categories
          if (currentCategory !== category) {
            console.log(`Category changed to ${category}, resetting score`);
            score = 0;
            currentCategory = category;
          }
          
          localStorage.setItem("acnh_last_category", category);
          
          // Only show loading message if not the initial page load
          if (!isInitialLoad) {
            feedbackElement.textContent = "Loading...";
            feedbackElement.className = "";
          }
          
          // Disable input during initialization
          guessInput.disabled = true;
          submitButton.disabled = true;

          // If setupNewRound has been called recently, don't load a new item
          if (Date.now() - lastLoadTimestamp < 500 && currentItem && currentItem.name) {
            console.log(`Using recently loaded item: ${currentItem.name} instead of loading a new one in initGame`);
            // Just update the UI with the current item
            displayItem(currentItem);
            feedbackElement.textContent = '';
            scoreElement.textContent = `Score: ${score}`;
            return;
          }

          const item = await getRandomItem(category);
          
          if (item) {
            // Set the current item and display it
            currentItem = item;
            await displayItem(item);
            feedbackElement.textContent = '';
            scoreElement.textContent = `Score: ${score}`;
            
            // Re-enable input
            guessInput.disabled = false;
            submitButton.disabled = false;
          } else {
            console.error('No item returned from getRandomItem');
            feedbackElement.textContent = 'Failed to load game items. Please try again.';
            feedbackElement.className = 'wrong';
          }
        } catch (error) {
          console.error('Error in initGame:', error);
          feedbackElement.textContent = 'An error occurred while initializing the game. Please try again.';
          feedbackElement.className = 'wrong';
          
          // Try to recover by resetting the category
          try {
            const category = categorySelector.value;
            if (allItems[category]) {
              console.log('Attempting to reset category data');
              delete allItems[category];
              await loadCategoryItems(category);
              await initGame();
            }
          } catch (recoveryError) {
            console.error('Recovery failed:', recoveryError);
          }
        }
      }

      function updateHighScore() {
        const category = categorySelector.value;
        if (!category) return;

        // Get the current high score for this category
        const categoryKey = `acnh_high_score_${category}`;
        const currentHighScore = parseInt(localStorage.getItem(categoryKey) || '0', 10);

        let isNewPersonalBest = false;
        
        // Update category high score if new high
        if (score > currentHighScore) {
          localStorage.setItem(categoryKey, score);
          isNewPersonalBest = true;
          highScoreElement.textContent = `Personal Best: ${score}`;
        }

        // Update overall high score
        const overallHighScore = parseInt(localStorage.getItem('acnh_high_score') || '0', 10);
        if (score > overallHighScore) {
          localStorage.setItem('acnh_high_score', score);
        }
      }

      function updateScore(newScore) {
        score = newScore;
        localStorage.setItem('acnh_current_score', score);
        scoreElement.textContent = `Score: ${score}`;
      }

      async function fetchWithTimeout(resource, options = {}, timeout = 10000) { // Increased timeout to 10 seconds
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);

        try {
          const response = await fetch(resource, {
            ...options,
            signal: controller.signal,
          });
          clearTimeout(id);
          if (!response.ok) {
            console.error(`Fetch failed with status: ${response.status}`);
            throw new Error(`Fetch failed with status: ${response.status}`);
          }
          return await response.json();
        } catch (error) {
          clearTimeout(id);
          console.error(`Fetch error: ${error.message}`);
          return null;
        }
      }

      async function getRandomItem(category) {
        // Check if we're already loading an item to prevent race conditions
        if (isLoadingItem) {
          // Wait for the current operation to complete with a shorter timeout to prevent getting stuck
          let timeoutCounter = 0;
          await new Promise(resolve => {
            const checkInterval = setInterval(() => {
              timeoutCounter++;
              // Reduced timeout to 1 second (10 * 100ms) to make next image load faster
              if (!isLoadingItem || timeoutCounter > 10) { 
                clearInterval(checkInterval);
                
                // If we timed out, force reset the loading state
                if (timeoutCounter > 10) {
                  isLoadingItem = false;
                }
                
                resolve();
              }
            }, 100);
          });
          
          // If the last item loaded was very recent (within 200ms), return the current item
          // This prevents race conditions where multiple calls happen in quick succession
          // Reduced from 500ms to 200ms to make next image load faster
          if (Date.now() - lastLoadTimestamp < 200 && currentItem && currentItem.name) {
            return currentItem;
          }
        }
        
        try {
          // Set the loading flag to prevent concurrent calls
          isLoadingItem = true;
          
          // Make sure we have items for this category
          if (!allItems[category] || allItems[category].length === 0) {
            try {
              await loadCategoryItems(category);
            } catch (error) {
              console.log(`Error loading category items, using fallback data for ${category}`);
              // Use fallback data if API fails
              allItems[category] = getFallbackData(category);
            }
          }
          
          // Initialize shown items array for this category if it doesn't exist
          if (!shownItems[category]) {
            shownItems[category] = [];
          }
          
          // Get items that haven't been shown yet
          const availableItems = allItems[category].filter(item => {
            return !shownItems[category].includes(item.name);
          });
          
          // If all items have been shown, reset the shown items for this category
          if (availableItems.length === 0) {
            console.log(`All items in ${category} have been shown. Resetting.`);
            shownItems[category] = [];
            
            // Return a random item from all items
            const randomIndex = Math.floor(Math.random() * allItems[category].length);
            const randomItem = allItems[category][randomIndex];
            if (randomItem) {
              shownItems[category].push(randomItem.name);
              return randomItem;
            } else {
              console.error(`Failed to get random item from allItems[${category}]`);
              throw new Error(`Failed to get random item for category: ${category}`);
            }
          }
          
          // Get a random item from the available items
          const randomIndex = Math.floor(Math.random() * availableItems.length);
          const randomItem = availableItems[randomIndex];
          
          if (!randomItem) {
            console.error('Failed to get random item from available items');
            throw new Error('Failed to select a random item');
          }
          
          // Add the selected item to the shown items list
          shownItems[category].push(randomItem.name);
          
          // Record the timestamp of this successful load
          lastLoadTimestamp = Date.now();
          
          return randomItem;
        } catch (error) {
          console.error('Error in getRandomItem:', error);
          
          // Create a fallback item as last resort
          console.log(`Creating emergency fallback item for ${category}`);
          const fallbackItem = {
            name: `${category.charAt(0).toUpperCase() + category.slice(1)} Item`,
            image_url: null,
            fallback_image_url: `images/${category}/placeholder.svg`
          };
          
          return fallbackItem; // Return fallback item instead of throwing error
        } finally {
          // Always release the lock, even if an error occurred
          isLoadingItem = false;
        }
      }

      function startTimer() {
        // Don't start the timer if the game is over
        if (gameOver) {
          return;
        }
        
        // Clear any existing timer
        stopTimer();
        
        // Double-check game over state after stopping timer
        if (gameOver) {
          return;
        }
        
        // Get selected difficulty
        const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
        timeLeft = difficulty;
        maxTime = difficulty;
        
        timerDisplay.textContent = `Time: ${timeLeft}`;
        timerDisplay.classList.add('running');
        timerDisplay.classList.remove('warning', 'expired');
        
        // Store the start time for more accurate timing
        const startTime = Date.now();
        const endTime = startTime + (timeLeft * 1000);
        
        // Update timer immediately to avoid initial delay
        updateTimer();
        
        // Set up the timer with requestAnimationFrame for smoother updates
        function updateTimer() {
          // First check if game is over or timer should be stopped
          if (gameOver || timerInterval === null) {
            cancelAnimationFrame(timerInterval);
            timerInterval = null;
            return;
          }
          
          const now = Date.now();
          timeLeft = Math.max(0, Math.ceil((endTime - now) / 1000));
          
          timerDisplay.textContent = `Time: ${timeLeft}`;
          
          // Change color based on time remaining (warning at 30% of max time)
          const warningThreshold = Math.ceil(maxTime * 0.3);
          if (timeLeft <= warningThreshold) {
            timerDisplay.classList.add('warning');
            timerDisplay.classList.remove('running');
          }
          
          if (timeLeft <= 0) {
            // Properly stop the timer
            cancelAnimationFrame(timerInterval);
            timerInterval = null;
            
            // Update timer display
            timerDisplay.classList.add('expired');
            timerDisplay.classList.remove('warning', 'running');
            
            // Set game over flag
            gameOver = true;
            
            // Check if the score is a leaderboard high score
            const category = categorySelector.value;
            
            // Check for high scores regardless of the score value
            isHighScore(score, category).then(isHighEnough => {
              if (isHighEnough) {
                // Play high score sound first
                playSound(highScoreSound);
                showHighScoreModal(score, category);
              } else {
                // Play game over sound if not a high score
                soundManager.play('game-over');
              }
            });
            
            // Show game over message
            feedbackElement.textContent = `Game Over! Time's up! The answer was ${currentItem.name}. Final Score: ${score}`;
            feedbackElement.className = 'wrong';
            scoreElement.textContent = `Score: ${score}`;
            
            // Disable input and show try again button
            guessInput.disabled = true;
            submitButton.disabled = true;
            document.getElementById('try-again-btn').style.display = 'inline-block';
            
            // Update personal best scores in localStorage
            updateHighScore();
            
            return; // Exit the update loop
          }
          
          // Double-check game over state before scheduling next update
          if (!gameOver) {
            // Schedule the next update only if game is not over
            timerInterval = requestAnimationFrame(updateTimer);
          } else {
            timerInterval = null;
          }
        }
        
        // Start the timer loop
        timerInterval = requestAnimationFrame(updateTimer);
      }

      function stopTimer() {
        // Force cancel any existing animation frame
        if (timerInterval) {
          cancelAnimationFrame(timerInterval);
          timerInterval = null;
        }
        
        // Double check - use a direct global variable reference to ensure we're truly stopping all timers
        window.cancelAnimationFrame(timerInterval);
        timerInterval = null;
        
        // Reset timer display classes
        timerDisplay.classList.remove('running', 'warning');
        
        // Don't remove 'expired' class if the timer ran out or game is over (to keep the red color)
        if (timeLeft > 0 && !gameOver) {
          timerDisplay.classList.remove('expired');
        }
        
        // If game is over, make sure the timer stays stopped and update visual state
        if (gameOver) {
          timerInterval = null;
          timerDisplay.classList.add('expired');
        }
      }

      // Track the current loading state to prevent multiple simultaneous operations
      let isLoadingItem = false;
      let lastLoadTimestamp = 0;
      
      async function displayItem(item) {
        return new Promise(async (resolve, reject) => {
          try {
            if (!item || !item.name) {
              showPlaceholder('Invalid item data');
              resolve(false);
              return;
            }
            
            // Check if we're already displaying this item to prevent duplicate calls
            if (currentlyDisplayingItem === item.name) {
              return resolve(true);
            }
            
            // Set the currently displaying item to prevent race conditions
            currentlyDisplayingItem = item.name;
            
            // Get UI elements
            const loadingLeaf = document.querySelector('.loading-leaf');
            const placeholder = document.querySelector(".image-placeholder");
            
            // Hide any existing placeholder
            if (placeholder) {
              placeholder.style.display = "none";
            }
            
            // Reset image display
            imageDisplay.src = '';
            imageDisplay.style.display = "none";
            imageDisplay.classList.remove('loaded');
            
            // Show loading indicator
            if (loadingLeaf) {
              loadingLeaf.style.display = 'block';
            }
            
            // Helper function to load an image with a timeout
            const loadImage = (url, timeout = 5000) => {
              return new Promise((resolveImg, rejectImg) => {
                if (!url) {
                  return rejectImg(new Error('No image URL provided'));
                }
                
                const img = new Image();
                const timer = setTimeout(() => {
                  img.onload = img.onerror = null;
                  rejectImg(new Error(`Image load timed out: ${url}`));
                }, timeout);
                
                img.onload = () => {
                  clearTimeout(timer);
                  resolveImg(url);
                };
                
                img.onerror = () => {
                  clearTimeout(timer);
                  rejectImg(new Error(`Failed to load image: ${url}`));
                };
                
                img.src = url;
              });
            };
            
            // Track if we're already trying the fallback image to prevent infinite loops
            let isTryingFallback = false;
            
            // Function to try the fallback image
            const tryFallbackImage = async () => {
              // Prevent recursive calls that could cause infinite loops
              if (isTryingFallback) {
                // Show text placeholder as last resort
                imageDisplay.style.display = 'none';
                showPlaceholder(`${item.name} (Image unavailable)`);
                if (loadingLeaf) loadingLeaf.style.display = 'none';
                resolve(false);
                return;
              }
              
              // Set the flag to prevent recursive calls
              isTryingFallback = true;
              
              const fallbackUrl = item.fallback_image_url || 
                               (currentCategory ? `images/${currentCategory}/placeholder.svg` : null);
              
              if (fallbackUrl) {
                try {
                  await loadImage(fallbackUrl);
                  
                  // Set the fallback image source and wait for it to load
                  imageDisplay.onload = () => {
                    imageDisplay.style.display = 'block';
                    imageDisplay.classList.add('loaded');
                    if (loadingLeaf) loadingLeaf.style.display = 'none';
                    console.log(`Successfully displayed fallback image for ${item.name}`);
                    
                    // Start the timer now that the fallback image is successfully loaded
                    if (!gameOver) {
                      // Reset timer with current difficulty
                      const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
                      timeLeft = difficulty;
                      maxTime = difficulty;
                      timerDisplay.textContent = `Time: ${timeLeft}`;
                      timerDisplay.classList.remove('warning', 'expired');
                      
                      // Start the timer
                      startTimer();
                    }
                    
                    resolve(true);
                  };
                  
                  imageDisplay.onerror = () => {
                    console.error(`Error displaying fallback image for ${item.name}`);
                    // Show text placeholder as last resort
                    imageDisplay.style.display = 'none';
                    showPlaceholder(`${item.name} (Image unavailable)`);
                    if (loadingLeaf) loadingLeaf.style.display = 'none';
                    resolve(false);
                  };
                  
                  imageDisplay.src = fallbackUrl;
                } catch (error) {
                  console.error(`All image attempts failed for ${item.name}`);
                  // Show text placeholder if all image attempts fail
                  imageDisplay.style.display = 'none';
                  showPlaceholder(`${item.name} (Image unavailable)`);
                  if (loadingLeaf) loadingLeaf.style.display = 'none';
                  resolve(false);
                }
              } else {
                // No fallback URL available
                imageDisplay.style.display = 'none';
                showPlaceholder(`${item.name} (Image unavailable)`);
                if (loadingLeaf) loadingLeaf.style.display = 'none';
                resolve(false);
              }
            };
            
            // Try primary image first
            if (item.image_url) {
              try {
                await loadImage(item.image_url);
                
                // Set timeout to handle cases where onload/onerror might not fire
                const imageTimeout = setTimeout(() => {
                  // Check if this is still the current item we want to display
                  if (currentlyDisplayingItem !== item.name) {
                    return;
                  }
                  
                  // Remove the event handlers to prevent them from firing again
                  imageDisplay.onload = null;
                  imageDisplay.onerror = null;
                  
                  // Try the fallback image instead, but only if we haven't already
                  if (!isTryingFallback) {
                    tryFallbackImage();
                  } else {
                    // If we're already trying the fallback, just show a placeholder
                    imageDisplay.style.display = 'none';
                    showPlaceholder(`${item.name} (Image unavailable)`);
                    if (loadingLeaf) loadingLeaf.style.display = 'none';
                    resolve(false);
                  }
                }, 5000);
                
                // Set the image source and wait for it to load
                imageDisplay.onload = () => {
                  // Check if this is still the current item we want to display
                  if (currentlyDisplayingItem !== item.name) {
                    return;
                  }
                  
                  // Clear the timeout to prevent it from triggering
                  clearTimeout(imageTimeout);
                  
                  imageDisplay.style.display = 'block';
                  imageDisplay.classList.add('loaded');
                  if (loadingLeaf) loadingLeaf.style.display = 'none';
                  
                  // Start the timer now that the image is successfully loaded
                  if (!gameOver) {
                    // Reset timer with current difficulty
                    const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
                    timeLeft = difficulty;
                    maxTime = difficulty;
                    timerDisplay.textContent = `Time: ${timeLeft}`;
                    timerDisplay.classList.remove('warning', 'expired');
                    
                    // Start the timer
                    startTimer();
                  }
                  
                  resolve(true);
                };
                
                imageDisplay.onerror = () => {
                  // Check if this is still the current item we want to display
                  if (currentlyDisplayingItem !== item.name) {
                    return;
                  }
                  
                  // Clear the timeout to prevent it from triggering
                  clearTimeout(imageTimeout);
                  
                  // Remove the event handlers to prevent them from firing again
                  imageDisplay.onload = null;
                  imageDisplay.onerror = null;
                  
                  // Clear the image source
                  imageDisplay.src = '';
                  
                  // Try the fallback image instead, but only if we haven't already
                  if (!isTryingFallback) {
                    tryFallbackImage();
                  } else {
                    // If we're already trying the fallback, just show a placeholder
                    imageDisplay.style.display = 'none';
                    showPlaceholder(`${item.name} (Image unavailable)`);
                    if (loadingLeaf) loadingLeaf.style.display = 'none';
                    resolve(false);
                  }
                };
                
                imageDisplay.src = item.image_url;
              } catch (error) {
                console.warn(`Primary image failed for ${item.name}, trying fallback`);
                // Continue to fallback if primary image fails
                tryFallbackImage();
              }
            } else {
              // No primary image URL, try fallback directly
              tryFallbackImage();
            }
            
          } catch (error) {
            console.error('Unexpected error in displayItem:', error);
            
            // Clean up and show error message
            imageDisplay.style.display = 'none';
            showPlaceholder(`Error loading image`);
            
            const loadingLeaf = document.querySelector('.loading-leaf');
            if (loadingLeaf) loadingLeaf.style.display = 'none';
            
            // Reset the currently displaying item
            currentlyDisplayingItem = null;
            
            // Resolve with false instead of rejecting to prevent unhandled promise rejections
            resolve(false);
          } finally {
            // Make sure we release any locks if needed
            // We don't reset currentlyDisplayingItem here because we want to keep track of what's displayed
          }
        });
      }

      function showPlaceholder(text) {
        // Hide the image display
        imageDisplay.style.display = "none";
        
        // Create or find the placeholder element
        let placeholder = document.querySelector(".image-placeholder");
        if (!placeholder) {
          placeholder = document.createElement("div");
          placeholder.className = "image-placeholder";
          // Insert the placeholder before the image display
          imageDisplay.parentNode.insertBefore(placeholder, imageDisplay);
        }
        
        // Set the placeholder text and display it
        placeholder.textContent = text || "Image not available";
        placeholder.style.display = "block";
        
        console.log('Showing placeholder with text:', text);
      }

      async function setupNewRound() {
        // Reduced delay to 50ms to make next image load faster
        await new Promise(resolve => setTimeout(resolve, 50));
        
        // Check if we're already loading an item to prevent race conditions
        if (isLoadingItem) {
          // Force reset loading state if it's been stuck for too long (over 2 seconds)
          if (Date.now() - lastLoadTimestamp > 2000) {
            isLoadingItem = false;
          } else {
            return;
          }
        }
        
        try {
          // Set the loading flag to prevent concurrent operations
          isLoadingItem = true;
          
          // Disable input while loading to prevent race conditions
          guessInput.disabled = true;
          submitButton.disabled = true;
          
          // Clear previous state
          guessInput.value = "";
          feedbackElement.textContent = "Loading...";
          feedbackElement.className = "";
          nextButton.style.display = "none";
          
          // First, remove any existing event handlers from the image display to prevent stale events
          imageDisplay.onload = null;
          imageDisplay.onerror = null;
          
          // Reset the image display
          imageDisplay.src = '';
          imageDisplay.style.display = 'none';
          imageDisplay.classList.remove('loaded');
          
          // Reset the currently displaying item
          currentlyDisplayingItem = null;
          
          // Reset the trying fallback flag
          isTryingFallback = false;
          
          // Hide any existing placeholder
          const placeholder = document.querySelector(".image-placeholder");
          if (placeholder) {
            placeholder.style.display = "none";
          }
          
          // Show loading indicator
          const loadingLeaf = document.querySelector('.loading-leaf');
          if (loadingLeaf) {
            loadingLeaf.style.display = 'block';
          }

          // Get the current category
          const category = categorySelector.value;
          if (!category) {
            console.error('No category selected');
            feedbackElement.textContent = 'Error: No category selected';
            isLoadingItem = false; // Release the lock
            return;
          }
          
          console.log(`Setting up new round for category: ${category}`);
          
          try {
            // Get a random item from the current category - await to ensure synchronization
            const item = await getRandomItem(category);
            
            if (item && item.name) {
              console.log(`Got item for display: ${item.name}`);
              
              // Set the current item BEFORE displaying it to ensure consistency
              currentItem = item;
              currentCategory = category;
              
              // Wait for the item to be displayed before enabling input
              await displayItem(item);
              
              // Update UI
              feedbackElement.textContent = '';
              scoreElement.textContent = `Score: ${score}`;
              
              // Re-enable input after everything is loaded
              guessInput.disabled = false;
              submitButton.disabled = false;
              guessInput.focus();
              
              console.log(`Ready for guessing. Current item is: ${currentItem.name}`);
            } else {
              console.error('Invalid or missing item data');
              feedbackElement.textContent = 'Error loading item. Please try again.';
            }
          } catch (error) {
            console.error('Error getting or displaying item:', error);
            feedbackElement.textContent = 'Error loading item. Please try again.';
          } finally {
            // Hide loading indicator
            if (loadingLeaf) {
              loadingLeaf.style.display = 'none';
            }
            
            // Always release the lock
            isLoadingItem = false;
          }

          // Timer will be started after image is successfully loaded - see displayItem function

        } catch (error) {
          console.error('Error setting up new round:', error);
          feedbackElement.textContent = 'Error setting up new round. Please try again.';
        }
      }

      // Reset function for when categories are changed or Try Again is pressed
      async function resetGame() {
        console.log('Resetting game...');
        
        // Stop any current timer
        stopTimer();
        
        // Reset timer display based on current difficulty setting
        const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
        timeLeft = difficulty;
        maxTime = difficulty;
        timerDisplay.textContent = `Time: ${timeLeft}`;
        timerDisplay.className = 'timer';
        
        // Reset score
        score = 0;
        scoreElement.textContent = `Score: ${score}`;
        
        // Reset image display state
        imageDisplay.onload = null;
        imageDisplay.onerror = null;
        imageDisplay.src = '';
        imageDisplay.style.display = 'none';
        imageDisplay.classList.remove('loaded');
        
        // Reset state variables
        currentlyDisplayingItem = null;
        isTryingFallback = false;
        gameOver = false;
        
        // Reset loading state - IMPORTANT to prevent the game from getting stuck
        isLoadingItem = false;
        
        // Hide any existing placeholder
        const placeholder = document.querySelector(".image-placeholder");
        if (placeholder) {
          placeholder.style.display = "none";
        }
        
        // Show loading indicator
        const loadingLeaf = document.querySelector('.loading-leaf');
        if (loadingLeaf) {
          loadingLeaf.style.display = 'block';
        }
        
        // Hide next button if visible
        nextButton.style.display = 'none';
        
        // Reset feedback
        feedbackElement.textContent = "Loading...";
        feedbackElement.className = "";
        
        // Enable input and buttons
        guessInput.disabled = false;
        submitButton.disabled = false;
        guessInput.value = "";
        
        // Load a new item
        try {
          // Initialize the game with a new item
          await initGame();
          
          // Timer will be started after the image is successfully loaded in displayItem
          
          // Make sure the timer display shows the correct class
          timerDisplay.classList.remove('warning', 'expired');
          timerDisplay.classList.add('running');
        } catch (error) {
          console.error('Error resetting game:', error);
          feedbackElement.textContent = 'Error resetting game. Please try again.';
        }
      }

      function checkGuess() {
        if (submitButton.disabled) return; // Prevent multiple submissions
        
        // Stop the timer when an answer is submitted
        stopTimer();
        
        const guess = guessInput.value.trim().toLowerCase();
        const correctAnswer = currentItem.name.toLowerCase();

        if (guess === correctAnswer) {
          // Play correct answer sound
          playSound('correct-sound');
          
          // Get current difficulty
          const difficulty = document.getElementById('difficulty').value;
          
          // Calculate base points
          let pointsEarned = 10 + timeLeft;
          let multiplier = 1;
          
          // Apply difficulty multiplier
          if (difficulty === '10000') { // Medium
            multiplier = 2;
          } else if (difficulty === '5000') { // Hard
            multiplier = 3;
          }
          
          // Calculate final points
          pointsEarned *= multiplier;
          score += pointsEarned;
          
          scoreElement.textContent = `Score: ${score}`;
          const multiplierText = multiplier > 1 ? ` x${multiplier}!` : '';
          feedbackElement.textContent = `Correct! +${pointsEarned} points${multiplierText}`;
          feedbackElement.className = "correct";
          
          // Update personal best score after each correct answer
          updateHighScore();
          
          // Stop the timer after a correct guess
          stopTimer();
          
          // Reset image display state to prepare for the next round
          // First, remove any existing event handlers from the image display to prevent stale events
          imageDisplay.onload = null;
          imageDisplay.onerror = null;
          
          // Reset state variables
          currentlyDisplayingItem = null;
          isTryingFallback = false;
          
          // Show next button
          nextButton.style.display = 'block';
          
          // Disable input until next round
          guessInput.disabled = true;
          submitButton.disabled = true;
          
          // Make sure we release any loading locks before setting up a new round
          isLoadingItem = false;
          console.log('Setting isLoadingItem to false in checkGuess before timeout');
          
          // Automatically load next item with reduced delay for faster image loading
          // Reduced from 1000ms to 500ms for faster transitions between rounds
          setTimeout(async () => {
            // Make sure we're not in a loading state before setting up a new round
            if (isLoadingItem) {
              console.log('Resetting isLoadingItem flag before setting up new round');
              isLoadingItem = false;
            }
            
            // Reduced delay to 50ms to make next image load faster
            await new Promise(resolve => setTimeout(resolve, 50));
            
            // Double-check we're not in a loading state
            if (isLoadingItem) {
              console.warn('Still in loading state after delay, forcing reset');
              isLoadingItem = false;
            }
            
            // Set up new round (this will reset the timer values)
            setupNewRound();
            
            // Don't start the timer here - it will be started after the image loads in displayItem
            
            // Re-enable input for the next round
            guessInput.disabled = false;
            submitButton.disabled = false;
            submitButton.style.display = 'inline-block';
          }, 500); // Reduced from 1000ms to 500ms for faster transitions
        } else {
          // Stop the timer
          stopTimer();
          
          // Play wrong answer sound
          playSound('game-over-sound');
          
          // Incorrect guess - game over
          feedbackElement.textContent = `Game Over! The answer was ${currentItem.name}. Final Score: ${score}`;
          feedbackElement.className = "wrong";
          scoreElement.textContent = `Score: ${score}`;
          
          // Set game over flag BEFORE stopping timer
          gameOver = true;
          console.log('Game over set to true');
          
          // Make sure timer is completely stopped - call this AFTER setting gameOver flag
          stopTimer();
          
          // Force timer display to stop and cancel any pending animation frames
          if (timerInterval) {
            cancelAnimationFrame(timerInterval);
            timerInterval = null;
          }
          
          // Freeze the timer display to show the final time
          timerDisplay.classList.remove('running', 'warning');
          timerDisplay.classList.add('expired');
          
          // Disable input and replace submit button with try again button
          guessInput.disabled = true;
          submitButton.style.display = 'none';
          const tryAgainButton = document.getElementById('try-again-btn');
          tryAgainButton.style.display = 'inline-block';
          guessInput.focus(); // Keep focus on input for keyboard users
          
          // Update personal best scores in localStorage
          updateHighScore();
          
          // Check if the score is a leaderboard high score
          const category = categorySelector.value;
          
          // Only check for high scores if the score is at least 3
          if (score >= 3) {
            isHighScore(score, category).then(isHighEnough => {
              if (isHighEnough) {
                showHighScoreModal(score, category);
              }
            });
          }
          
          // Reset shown items when game is over
          shownItems = {};
        }
        guessInput.value = '';
      }
      
      function resetLeaderboardCategory(category) {
        if (!confirm(`Are you sure you want to reset the ${category} leaderboard? This cannot be undone.`)) {
          return; // User canceled
        }
        
        // Get current leaderboard data or create empty if not exists
        let leaderboardData = JSON.parse(localStorage.getItem('acnh_leaderboard') || '{}');
        
        // If leaderboard exists, reset the selected category
        if (leaderboardData) {
          try {
            // Reset the category to an empty array
            leaderboardData[category] = [];
            
            // Save updated leaderboard to localStorage
            localStorage.setItem('acnh_leaderboard', JSON.stringify(leaderboardData));
            
            // Update UI
            updateLeaderboardUI(leaderboardData);
            alert(`${category.charAt(0).toUpperCase() + category.slice(1)} leaderboard has been reset.`);
          } catch (e) {
            console.error('Error resetting leaderboard category:', e);
            alert('An error occurred while resetting the leaderboard.');
          }
        } else {
          // If no leaderboard exists yet, create an empty one
          leaderboardData = { fish: [], bugs: [], sea: [], villagers: [] };
          localStorage.setItem('acnh_leaderboard', JSON.stringify(leaderboardData));
          updateLeaderboardUI(leaderboardData);
          alert(`${category.charAt(0).toUpperCase() + category.slice(1)} leaderboard has been reset.`);
        }
      }

      function resetAllLeaderboards() {
        if (!confirm('Are you sure you want to reset ALL leaderboards? This cannot be undone.')) {
          return; // User canceled
        }
        
        // Create empty leaderboard data
        const emptyLeaderboard = { fish: [], bugs: [], sea: [], villagers: [] };
        
        // Save to localStorage
        localStorage.setItem('acnh_leaderboard', JSON.stringify(emptyLeaderboard));
        
        // Update the UI
        updateLeaderboardUI(emptyLeaderboard);
        
        alert('All leaderboards have been reset.');
      }
      
      function resetToDefaults() {
        if (!confirm('Are you sure you want to reset the leaderboards to default values from leaderboard.json?')) {
          return; // User canceled
        }
        
        // Fetch the default leaderboard data from leaderboard.json
        fetch('leaderboard.json')
          .then(response => {
            if (!response.ok) {
              throw new Error('Failed to load default leaderboard data');
            }
            return response.json();
          })
          .then(defaultData => {
            // Save the default data to localStorage
            localStorage.setItem('acnh_leaderboard', JSON.stringify(defaultData));
            
            // Update the UI
            updateLeaderboardUI(defaultData);
            
            alert('Leaderboards have been reset to default values.');
          })
          .catch(error => {
            console.error('Error loading default leaderboard data:', error);
            alert('Error loading default leaderboard data. Please try again.');
          });
      }

      function isHighScore(score, category) {
        return new Promise((resolve) => {
          fetch('leaderboard.json')
            .then(response => response.json())
            .then(data => {
              // Get the scores for the current category
              const scores = data[category] || [];
              
              // If there are fewer than 10 scores, any score is a high score
              if (scores.length < 10) {
                resolve(true);
                return;
              }
              
              // Find the lowest score in the top 10
              const lowestScore = scores.reduce((min, entry) => 
                entry.score < min ? entry.score : min, scores[0].score);
              
              // It's a high score if it's higher than the lowest score in the top 10
              resolve(score > lowestScore);
            })
            .catch(error => {
              console.error('Error checking high score:', error);
              // Default to true if there's an error (to be safe)
              resolve(true);
            });
        });
      }

      window.addEventListener("DOMContentLoaded", () => {
        // Add reset button event listener
        const resetButton = document.getElementById('reset-high-score');
        if (resetButton) {
          resetButton.addEventListener('click', () => {
            // Reset all high scores
            localStorage.removeItem('acnh_high_score');
            const category = categorySelector.value;
            localStorage.removeItem(`acnh_high_score_${category}`);
            
            // Reset shown items
            localStorage.removeItem(`shown_items_${category}`);
            
            // Reset current score
            score = 0;
            scoreElement.textContent = `Score: ${score}`;
            
            // Update high score display
            highScoreElement.textContent = `Personal Best: 0`;
            
            // Don't load a new image when resetting high score
            // Show the Start Game button instead
            const startGameButton = document.getElementById('start-game-btn');
            if (startGameButton) {
              startGameButton.style.display = 'inline-block';
            }
          });
        }

        // Flag to prevent duplicate category change handling
        let isHandlingCategoryChange = false;
        
        // Event listener for category change
        categorySelector.addEventListener('change', async function(e) {
          if (isHandlingCategoryChange) return; // Prevent multiple simultaneous category changes
          
          isHandlingCategoryChange = true;
          const category = e.target.value;
          
          try {
            // Don't reset the game state with resetGame() as it loads images
            // Instead, just stop the timer and reset the score
            stopTimer();
            
            // Make sure the timer is completely stopped
            if (timerInterval) {
              cancelAnimationFrame(timerInterval);
              timerInterval = null;
            }
            
            // Reset game over flag to ensure timer can start again
            gameOver = false;
            
            // Reset timer display
            const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
            timeLeft = difficulty;
            maxTime = difficulty;
            timerDisplay.textContent = `Time: ${timeLeft}`;
            timerDisplay.classList.remove('warning', 'expired', 'running');
            
            score = 0;
            scoreElement.textContent = `Score: ${score}`;
            
            // Update high score for the selected category
            const categoryKey = `acnh_high_score_${category}`;
            const currentHighScore = parseInt(localStorage.getItem(categoryKey) || '0', 10);
            highScoreElement.textContent = `Personal Best: ${currentHighScore}`;
            
            // Save selected category to localStorage
            localStorage.setItem("acnh_last_category", category);
            
            // Load new category items but don't start the game yet
            if (!isLoadingItems) {
              // Wait for items to load before continuing
              await loadCategoryItems(category);
            } else {
              console.log('Waiting for previous category load to complete...');
              // Wait for loading to complete and then try again
              await new Promise(resolve => {
                const checkLoading = setInterval(() => {
                  if (!isLoadingItems) {
                    clearInterval(checkLoading);
                    resolve();
                  }
                }, 100);
              });
              await loadCategoryItems(category);
            }
            
            // Show the Start Game button
            const startGameButton = document.getElementById('start-game-btn');
            if (startGameButton) {
              startGameButton.style.display = 'inline-block';
            }
          } catch (error) {
            console.error('Error changing category:', error);
            feedbackElement.textContent = 'Error loading category. Please try again.';
          } finally {
            isHandlingCategoryChange = false; // Reset the flag when done
          }
        });
        
        // Event listener for difficulty change
        difficultySelector.addEventListener('change', function() {
          // Stop the current timer when difficulty changes
          stopTimer();
          
          // Update timer values based on the new difficulty
          const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
          timeLeft = difficulty;
          maxTime = difficulty;
          timerDisplay.textContent = `Time: ${timeLeft}`;
          timerDisplay.classList.remove('warning', 'expired');
          
          // Don't load a new image when difficulty changes, only update the timer values
          // setupNewRound will be called when Start Game is pressed
        });

        // Restore score and category from previous session
        const savedScore = localStorage.getItem("acnh_current_score");
        if (savedScore) {
          score = parseInt(savedScore, 10);
          scoreElement.textContent = `Score: ${score}`;
        }

        const savedCategory = localStorage.getItem("acnh_last_category");
        if (savedCategory) {
          categorySelector.value = savedCategory;
          
          // Update high score for the selected category
          const categoryKey = `acnh_high_score_${savedCategory}`;
          const currentHighScore = parseInt(localStorage.getItem(categoryKey) || '0', 10);
          highScoreElement.textContent = `Personal Best: ${currentHighScore}`;
        }

        updateLeaderboard();
        
        // Don't load any images until the game starts
        
        // Add event listener for the Start Game button
        const startGameButton = document.getElementById('start-game-btn');
        if (startGameButton) {
          startGameButton.addEventListener('click', function() {
            // Hide the start game button
            startGameButton.style.display = 'none';
            
            // Enable the input field and focus it
            guessInput.disabled = false;
            guessInput.style.display = 'inline-block';
            guessInput.focus();
            
            // Show the submit button
            submitButton.style.display = 'inline-block';
            
            // Initialize the game (this will load the first image)
            initGame(true);
            
            // Start the game round - the timer will be started after the image loads
            setupNewRound();
            
            // Play new round sound using the sound manager
            soundManager.play('start-game');
          });
        }
        
        // Add event listener for the sound toggle button
        const soundToggleBtn = document.getElementById('sound-toggle');
        if (soundToggleBtn) {
          soundToggleBtn.addEventListener('click', function(e) {
            e.preventDefault();
            soundManager.toggle();
            // Add a small animation effect on click
            soundToggleBtn.style.transform = 'scale(0.9)';
            setTimeout(() => {
              soundToggleBtn.style.transform = 'scale(1)';
            }, 100);
          });
        }
        
        // Add event listeners for the reset buttons - safely with null checks
        const resetFishBtn = document.getElementById('reset-fish-btn');
        if (resetFishBtn) resetFishBtn.addEventListener('click', () => resetLeaderboardCategory('fish'));
        
        const resetBugsBtn = document.getElementById('reset-bugs-btn');
        if (resetBugsBtn) resetBugsBtn.addEventListener('click', () => resetLeaderboardCategory('bugs'));
        
        const resetSeaBtn = document.getElementById('reset-sea-btn');
        if (resetSeaBtn) resetSeaBtn.addEventListener('click', () => resetLeaderboardCategory('sea'));
        
        const resetVillagersBtn = document.getElementById('reset-villagers-btn');
        if (resetVillagersBtn) resetVillagersBtn.addEventListener('click', () => resetLeaderboardCategory('villagers'));
        
        const resetAllBtn = document.getElementById('reset-all-btn');
        if (resetAllBtn) resetAllBtn.addEventListener('click', resetAllLeaderboards);
        
        const resetToDefaultsBtn = document.getElementById('reset-to-defaults-btn');
        if (resetToDefaultsBtn) resetToDefaultsBtn.addEventListener('click', resetToDefaults);

        submitButton.addEventListener("click", checkGuess);
        guessInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            e.preventDefault(); // Prevent form submission if any
            const tryAgainButton = document.getElementById("try-again-btn");
            if (tryAgainButton && window.getComputedStyle(tryAgainButton).display !== 'none') {
              // If Try Again button is visible, trigger it
              tryAgainButton.click();
            } else {
              // Otherwise, check the guess as normal
              checkGuess();
            }
          }
        });

        // Handle keyboard visibility on mobile devices
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
          // Set fixed position for game container to prevent automatic scrolling
          const gameContainer = document.getElementById('game-container');
          if (gameContainer) {
            // Add CSS to allow manual scrolling but prevent automatic repositioning
            gameContainer.style.position = 'relative';
            gameContainer.style.overflowY = 'auto';
            gameContainer.style.maxHeight = '90vh'; // Set maximum height to allow scrolling
          }
          
          // Prevent default focus behavior that would scroll the screen
          guessInput.addEventListener('focus', function(e) {
            // Prevent automatic scrolling
            e.preventDefault();
            // Keep focus on input field
            setTimeout(function() {
              guessInput.focus();
            }, 50);
          });

          // Handle orientation changes without repositioning
          window.addEventListener('resize', function() {
            // No automatic scrolling on resize
          });
        }
        // Custom handler for next button to avoid playing start-game sound
        nextButton.addEventListener("click", () => {
          // Hide the next button
          nextButton.style.display = 'none';
          
          // Set up a new round without playing the start-game sound
          setupNewRound();
          
          // Re-enable input
          guessInput.disabled = false;
          submitButton.disabled = false;
          submitButton.style.display = 'inline-block';
          guessInput.focus();
        });
        const tryAgainButton = document.getElementById("try-again-btn");
        tryAgainButton.addEventListener("click", async () => {
          // Reset game state
          gameOver = false;
          
          // Hide the try again button
          tryAgainButton.style.display = 'none';
          
          // Show the submit button
          submitButton.style.display = 'inline-block';
          
          // Play new round sound using sound manager
          soundManager.play('start-game');
          
          // Use our improved resetGame function to properly reset everything
          await resetGame();
          
          // Focus the input field
          guessInput.focus();
        });
        
        // Add event listener for the End Game button
        const endGameButton = document.getElementById("end-game-btn");
        endGameButton.addEventListener("click", () => {
          // Stop the timer
          stopTimer();
          
          // Disable game controls
          guessInput.disabled = true;
          submitButton.disabled = true;
          
          // Set game over flag
          gameOver = true;
          
          // Show feedback and Try Again button
          feedbackElement.textContent = `Game Over! Final Score: ${score}`;
          feedbackElement.className = "";
          
          // Show the Try Again button
          const tryAgainButton = document.getElementById("try-again-btn");
          tryAgainButton.style.display = 'inline-block';
          
          // Hide the End Game button
          endGameButton.style.display = 'none';
          
          // Update personal best scores in localStorage
          updateHighScore();
          
          // Check if the score is a leaderboard high score
          const category = categorySelector.value;
          
          // Check for high scores regardless of the score value
          isHighScore(score, category).then(isHighEnough => {
            if (isHighEnough) {
              showHighScoreModal(score, category);
            } else {
              playSound(gameOverSound);
            }
          });
        });
        
        function startGame() {
         
          // Add event listener for sound toggle
          soundToggleBtn.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggleBtn.style.backgroundColor = soundEnabled ? '#4a90e2' : '#cccccc';
          });
          
          const startGameBtn = document.getElementById('start-game-btn');
          startGameBtn.addEventListener('click', () => {
            // Hide the start button
            startGameBtn.style.display = 'none';
            
            // Show the end game button
            document.getElementById('end-game-btn').style.display = 'inline-block';
            
            // Enable the guess input and submit button
            guessInput.disabled = false;
            guessInput.style.display = 'inline-block';
            submitButton.style.display = 'inline-block';
            submitButton.disabled = false;
            
            // Focus on the input
            guessInput.focus();
            
            // Reset score
            score = 0;
            scoreElement.textContent = `Score: ${score}`;
            
            // Clear any feedback
            feedbackElement.textContent = '';
            feedbackElement.className = '';
            
            // Play new round sound using the sound manager
            soundManager.play('start-game');
            
            // Start the timer after a short delay to ensure UI is ready
            setTimeout(() => {
              stopTimer(); // Clear any existing timer first
              startTimer();
              setupNewRound();
            }, 100);
          });  
        }
        
        function resetLeaderboardCategory(category) {
          if (!confirm(`Are you sure you want to reset the ${category} leaderboard?`)) {
            return; // User canceled
          }
          // Get current leaderboard data
          const savedLeaderboard = localStorage.getItem('acnh_leaderboard');
          let leaderboardData = {};
          
          if (savedLeaderboard) {
            try {
              leaderboardData = JSON.parse(savedLeaderboard);
              // Reset the specified category
              leaderboardData[category] = [];
              // Save the updated leaderboard
              localStorage.setItem('acnh_leaderboard', JSON.stringify(leaderboardData));
              // Update the UI
              updateLeaderboardUI(leaderboardData);
              alert(`${category.charAt(0).toUpperCase() + category.slice(1)} leaderboard has been reset.`);
            } catch (e) {
              console.error('Error resetting leaderboard category:', e);
              alert('An error occurred while resetting the leaderboard.');
            }
          } else {
            // If no leaderboard exists yet, create an empty one
            leaderboardData = { fish: [], bugs: [], sea: [], villagers: [] };
            localStorage.setItem('acnh_leaderboard', JSON.stringify(leaderboardData));
            updateLeaderboardUI(leaderboardData);
            alert(`${category.charAt(0).toUpperCase() + category.slice(1)} leaderboard has been reset.`);
          }
        }
        
        // Store the current category change promise to prevent race conditions
      let categoryChangePromise = null;
      let isCategoryLoading = false;
      
      categorySelector.addEventListener("change", async (e) => {
        const category = e.target.value;
        
        // If we're already changing categories, wait for that to complete
        if (isCategoryLoading) {
          console.log('Category change already in progress, waiting...');
          return;
        }
        
        isCategoryLoading = true;
        feedbackElement.textContent = "Loading...";
        feedbackElement.className = "";
        
        try {
          // Stop the current timer if it's running
          stopTimer();
          
          // Reset timer variables
          timeLeft = 15;
          timerDisplay.textContent = `Time: ${timeLeft}`;
          timerDisplay.className = 'timer';
          
          console.log(`Loading category: ${category}`);
          
          // Always load items for the category to ensure we have fresh data
          await loadCategoryItems(category);
          
          // Only update the category and score, but don't load images yet
          if (currentCategory !== category) {
            console.log(`Category changed from ${currentCategory} to ${category}, resetting score`);
            score = 0;
            currentCategory = category;
            // Don't call initGame() here, wait for Start Game button
            
            // Show the Start Game button
            const startGameButton = document.getElementById('start-game-btn');
            if (startGameButton) {
              startGameButton.style.display = 'inline-block';
            }
          }
          
          // Update high score when category changes
          const categoryKey = `acnh_high_score_${category}`;
          const currentHighScore = parseInt(localStorage.getItem(categoryKey) || '0', 10);
          highScoreElement.textContent = `Personal Best: ${currentHighScore}`;
          
        } catch (error) {
          console.error('Error changing category:', error);
          feedbackElement.textContent = 'Error changing category. Please try again.';
          feedbackElement.className = 'wrong';
        } finally {
          isCategoryLoading = false;
          feedbackElement.textContent = '';
        }
      });
      });
    </script>
    <!-- Blathers Character -->
    <div id="blathers-character">
      <img src="images/Blathers_PG.png" alt="Blathers" style="width: 100%; height: auto;">
    </div>
  </body>
</html>