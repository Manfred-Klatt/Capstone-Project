<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <script>
      // Set the backend API URL
      window.BACKEND_API = 'https://capstone-project-production-3cce.up.railway.app/api/v1';
    </script>
    <script>
      // Optimized font loading with Font Loading API and fallback
      document.documentElement.classList.add('font-loading');
      
      // Load custom font asynchronously
      async function loadCustomFont() {
        try {
          const font = new FontFace('CustomFont', 
            'url(fonts/customfont.woff2) format("woff2"), ' +
            'url(fonts/customfont.otf) format("opentype")',
            { display: 'swap' }
          );
          
          // Load the font
          await font.load();
          document.fonts.add(font);
          
          // Apply the font
          document.documentElement.classList.remove('font-loading');
          document.documentElement.classList.add('font-loaded');
        } catch (e) {
          console.warn('Failed to load custom font, using fallback', e);
          document.documentElement.classList.remove('font-loading');
        }
      }
      
      // Start loading the font
      if ('fonts' in document) {
        loadCustomFont();
      } else {
        // Fallback for browsers without Font Loading API
        document.documentElement.classList.remove('font-loading');
      }
    </script>
    <script type="module" src="game.js"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Preload sound effects -->
    <audio id="correct-sound" preload="auto">
      <source src="sounds/correct.ogg" type="audio/ogg">
    </audio>
    <audio id="game-over-sound" preload="auto">
      <source src="sounds/game-over.ogg" type="audio/ogg">
    </audio>
    <audio id="start-game-sound" preload="auto">
      <source src="sounds/start-game.ogg" type="audio/ogg">
    </audio>
    <audio id="high-score-sound" preload="auto">
      <source src="sounds/high-score.ogg" type="audio/ogg">
    </audio>
    <title>Animal Crossing Quiz Game</title>
    <style>
      /* Font face is now loaded via JavaScript for better performance */
      .font-loading {
        visibility: hidden;
      }
      
      .font-loaded {
        font-family: 'CustomFont', 'Arial', sans-serif;
      }

      :root {
        /* Light theme (default) */
        --background-color: #f8f9fa;
        --text-color: #2c3e50;
        --container-bg: #ffffff;
        --border-color: #8b4513;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --button-bg: #4a90e2;
        --button-hover: #357abd;
        --card-bg: #ffffff;
        --card-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        --input-bg: #ffffff;
        --input-text: #2c3e50;
        
        /* Dark theme - will be applied when .dark-mode class is added to body */
        --dark-background: #1a1a2e;
        --dark-text: #f0f0f0;
        --dark-container: #16213e;
        --dark-border: #4a4a6a;
        --dark-shadow: rgba(0, 0, 0, 0.3);
        --dark-button-bg: #4a90e2;
        --dark-button-hover: #5d9ce6;
        --dark-card-bg: #0f3460;
        --dark-input-bg: #2d3748;
        --dark-input-text: #e2e8f0;
      }

      body {
        font-family: "CustomFont", "Arial", sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        text-align: center;
        background-image: url("images/background.webp");
        background-size: cover;
        background-position: center;
        background-attachment: fixed;
        background-color: rgba(255, 255, 255, 0.15);
        background-blend-mode: soft-light;
        color: #f0f0f0;
        box-sizing: border-box;
        line-height: 1.6;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      #imageDisplay {
        max-width: 100%;
        max-height: 400px;
        margin: 10px auto;
        display: block;
        border: none;
        box-shadow: none;
        /* Hide broken image icon */
        font-size: 0;
        color: transparent;
        /* Smooth transition for loading */
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
      }
      
      #imageDisplay.loaded {
        opacity: 1;
      }
      
      .image-placeholder {
        width: 100%;
        max-width: 400px;
        height: 200px;
        margin: 10px auto;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f8f8f8;
        border: 2px dashed #ccc;
        border-radius: 10px;
        color: #666;
        font-size: 18px;
        text-align: center;
      }
      
      .loading-leaf {
        width: 80px;
        height: 80px;
        margin: 10px auto;
        display: none;
        background-image: url('images/leaf.png');
        background-size: contain;
        background-repeat: no-repeat;
        animation: spin 2s linear infinite;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      input, button {
        padding: 10px;
        font-size: 14px;
        border-radius: 6px;
        margin-right: 8px;
      }

      #guess-input {
        width: 100%;
        max-width: 280px;
        border: 1px solid var(--border-color);
        background-color: #fffdf8;
        margin: 5px 0;
      }

      button {
        background-color: #6b8e23;
        color: white;
        border: none;
        cursor: pointer;
        transition: background-color 0.3s;
      }
            
      #start-round:hover {
        background-color: #a0522d;
      }
      button:hover {
        background-color: #556b2f;
      }
      
      #try-again-btn {
        background-color: #ff8c00;
      }
      
      #try-again-btn:hover {
        background-color: #e67e00;
      }
      #feedback {
        margin: 20px 15px;
        padding: 15px 20px;
        font-size: 1.2em;
        min-height: 24px;
        font-weight: 600;
        border-radius: 8px;
        line-height: 1.4;
        max-width: 90%;
        margin-left: auto;
        margin-right: auto;
        transition: all 0.3s ease;
      }
      
      #feedback.wrong {
        background-color: rgba(220, 53, 69, 0.15);
        color: #dc3545;
        border-left: 4px solid #dc3545;
      }
      
      .dark-mode #feedback.wrong {
        background-color: rgba(220, 53, 69, 0.25);
        color: #ff6b6b;
      }
      
      #feedback.correct {
        background-color: rgba(40, 167, 69, 0.15);
        color: #28a745;
        border-left: 4px solid #28a745;
      }
      
      .dark-mode #feedback.correct {
        background-color: rgba(40, 167, 69, 0.25);
        color: #6cff8f;
      }
      #score {
        font-weight: bold;
        font-size: 18px;
        color: #8b4513;
      }
      #category-selector {
        margin: 15px 0;
      }
      select {
        padding: 6px;
        border-radius: 4px;
        border: 1px solid #5a3d2b;
        background-color: #fffdf8;
        font-family: 'CustomFont', Arial, sans-serif;
      }
      option {
        font-family: 'CustomFont', Arial, sans-serif;
      }
      .correct {
        color: #2e8b57;
      }
      .incorrect {
        color: #cd5c5c;
      }
      .logout-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background-color: #ff6b6b;
      }
      .logout-btn:hover {
        background-color: #ff5252;
      }
      #leaderboard-section {
        width: 200px;
        float: right;
        margin-right: 20px;
        background-color: rgba(45, 40, 35, 0.8);
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        border: 2px solid #8b5a2b;
        backdrop-filter: blur(5px);
      }
      #leaderboard-section h2 {
        margin-bottom: 10px;
        border-bottom: 2px solid #8b4513;
        padding-bottom: 5px;
        color: #5a3d2b;
        font-size: 1.4em;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
      }
      
      #admin-tools-container {
        width: 90%;
        max-width: 800px;
        margin: 10px auto;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        z-index: 100;
        border: 2px solid #8b4513;
      }
      
      #admin-tools-container h2 {
        margin-bottom: 10px;
        border-bottom: 2px solid #8b4513;
        padding-bottom: 5px;
        color: #5a3d2b;
      }
      
      #admin-tools-container button {
        padding: 10px 15px;
        background-color: #6b8e23;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
        white-space: nowrap;
        transition: background-color 0.2s;
      }
      
      #admin-tools-container button:hover {
        background-color: #5a7c1f;
      }
      
      #game-container {
        width: 95%;
        max-width: 1100px;
        margin: 0 auto 30px;
        padding: 15px;
        background-color: #fff9e6; /* Warm yellow that complements the Animal Crossing theme */
        border-radius: 10px;
        border: 2px solid var(--border-color, #8b4513);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        box-sizing: border-box;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      #leaderboard {
        font-size: 16px;
        font-weight: bold;
      }
      
      /* Leaderboard container */
      .leaderboards-container {
        display: grid;
        grid-template-columns: repeat(2, minmax(250px, 1fr));
        gap: 20px;
        margin: 0 auto 40px;
        width: 100%;
        max-width: 900px;
        padding: 0 15px;
        box-sizing: border-box;
        align-items: start; /* Align items to the top */
        justify-content: center;
      }

      .category-leaderboard {
        background-color: #fff9f0;
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 0 12px rgba(0, 0, 0, 0.1);
        border: 2px solid #8b4513;
        width: 100%;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: auto; /* Let content determine height */
        margin: 0 auto;
      }

      .category-leaderboard h3 {
        margin: 0 0 15px 0;
        padding: 12px 0;
        border-bottom: 2px solid rgba(0, 0, 0, 0.2);
        font-size: 1.2rem;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 1px;
        border-radius: 8px 8px 0 0;
        font-weight: 600;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .category-leaderboard > div {
        display: flex;
        flex-direction: column;
        min-height: 0; /* Prevents flex item from growing */
      }

      .category-leaderboard span {
        display: block;
        padding: 6px 0;
        border-bottom: 1px solid #e8e8e8;
        line-height: 1.3;
      }

      .category-leaderboard span:last-child {
        border-bottom: none;
      }
      #leaderboard-container {
        width: 100%;
        max-width: 1140px;
        margin: 20px auto;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        flex-wrap: wrap;
        gap: 10px;
        padding: 15px;
        background-color: #fff9f0;
        border-radius: 12px;
        box-shadow: 0 0 12px rgba(0, 0, 0, 0.1);
        border: 2px solid #8b4513;
        box-sizing: border-box;
      }
      .category-leaderboard h3 {
        margin-bottom: 5px;
        border-bottom: 2px solid #8b4513;
        padding-bottom: 2.5px;
      }
      .high-score-container {
        margin: 10px 0;
        padding: 0;
        background-color: transparent;
        font-size: 1.3em;
        font-weight: 600;
        letter-spacing: 0.5px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }
      
        #high-score {
        font-family: 'CustomFont', 'Arial', sans-serif;
        color: #2c3e50;
        margin-bottom: 8px;
        font-size: 1.1em;
      }
      
      .dark-mode {
        background-image: url("images/background.webp") !important;
        background-size: cover !important;
        background-position: center !important;
        background-attachment: fixed !important;
        background-color: rgba(26, 32, 44, 0.7) !important;
        background-blend-mode: soft-light !important;
        color: #f0f0f0 !important;
      }
      
      .dark-mode #high-score {
        color: #f0f0f0;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }
      .score-container {
        text-align: center;
      }
      .category-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
      }
      select {
        padding: 8px 12px;
        margin: 8px 0 15px;
        border-radius: 6px;
        border: 2px solid #8b4513;
        font-size: 1em;
        font-family: 'CustomFont', 'Arial', sans-serif;
        background-color: #ffffff;
        color: #2c3e50;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }
      
      select:hover {
        border-color: #a0522d;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      
      select:focus {
        outline: none;
        border-color: #6b8e23;
        box-shadow: 0 0 0 3px rgba(107, 142, 35, 0.2);
      }
      
      .dark-mode select {
        background-color: #2d3748;
        border-color: #4a4a6a;
        color: #e2e8f0;
      }
      label {
        font-size: 1.2em;
        margin: 12px 0 8px;
        display: block;
        font-weight: 600;
        color: #2c3e50;
        letter-spacing: 0.5px;
        text-transform: uppercase;
        font-family: 'CustomFont', 'Arial', sans-serif;
      }
      
      .dark-mode label {
        color: #f0f0f0;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }
      
      .dark-mode .high-score-container {
        background-color: transparent;
        border: none;
      }
      .timer-container {
        display: block;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px 20px;
        border-radius: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin: 10px auto;
        text-align: center;
        width: fit-content;
      }

      .loading-leaf {
        width: 40px;
        height: 40px;
        background: url('images/loading.png') no-repeat center;
        background-size: contain;
        animation: spin 1s linear infinite;
        margin: 20px auto;
        display: none;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .timer {
        font-size: 24px;
        font-weight: bold;
        color: #333;
        transition: color 0.3s ease;
      }

      .timer.running {
        color: #4CAF50;
      }

      .timer.warning {
        color: #FFA500;
      }

      .timer.expired {
        color: #FF4444;
      }
      
      /* High Score Modal Styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
      }
      
      .modal-content {
        background-color: #f8f8f8;
        margin: 15% auto;
        padding: 20px;
        border: 2px solid #4CAF50;
        border-radius: 10px;
        width: 300px;
        text-align: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        animation: modalAppear 0.4s;
      }
      
      @keyframes modalAppear {
        from {transform: scale(0.8); opacity: 0;}
        to {transform: scale(1); opacity: 1;}
      }
      
      .modal h2 {
        color: #4CAF50;
        margin-top: 0;
      }
      
      .modal input {
        width: 90%;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 16px;
        font-family: Arial, sans-serif;
        color: #333;
      }
      

          .logout-btn {
            background-color: #4a90e2;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease !important;
          }

      .logout-btn:hover {
        background-color: #357abd !important;
      }

      /* Reset All Button Hover Effect */
      #reset-all-btn {
        transition: background-color 0.3s ease !important;
      }

      #reset-all-btn:hover {
        background-color: #d93025 !important; /* Darker shade of red */
      }

      /* Reset to Defaults Button Hover Effect */
      #reset-to-defaults-btn {
        transition: background-color 0.3s ease !important;
      }

      #reset-to-defaults-btn:hover {
        background-color: #357abd !important; /* Darker shade of blue */
      }

      /* Reset Personal Best Button Hover Effect */
      #reset-high-score {
        transition: background-color 0.3s ease !important;
      }

      #reset-high-score:hover {
        background-color: #e69138 !important; /* Darker shade of orange */
      }
      
      /* Mobile Navigation Bar */
      .mobile-nav-bar {
        display: none;
      }
      
      /* Leaderboard Styles */
      .leaderboards-container {
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        padding: 0 20px;
        box-sizing: border-box;
      }
      
      .category-leaderboard {
        width: 100%;
        margin-bottom: 20px;
        box-sizing: border-box;
      }
      
      #fish-scores,
      #bugs-scores,
      #sea-scores,
      #villagers-scores {
        width: 100%;
        display: flex;
        flex-direction: column;
      }
      
      .category-leaderboard h3 {
        width: 100%;
        max-width: 800px;
        margin: 20px auto;
        padding: 0 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      
      .category-leaderboard {
        border-radius: 10px;
        border: 2px solid var(--border-color);
        padding: 15px;
        margin-bottom: 20px;
      }

      /* Unique background colors and header styles for each category */
      #fish-leaderboard {
        background: linear-gradient(to top, #87CEEB, #B0E0E6); /* Gradient from light blue to very light blue */
      }
      #fish-leaderboard h3 {
        color: #1a4b8c; /* Darker blue for better contrast */
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.5);
      }

      #bugs-leaderboard {
        background: linear-gradient(to top, #32CD32, #98FB98); /* Gradient from light green to very light green */
      }
      #bugs-leaderboard h3 {
        color: #1a5c1a; /* Darker green for better contrast */
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.5);
      }
      
      #sea-leaderboard {
        background: linear-gradient(to top, #00BFFF, #1E90FF); /* Gradient from darker blue to medium blue */
      }
      #sea-leaderboard h3 {
        color: #0a3d6b; /* Darker blue for better contrast */
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.5);
      }

      #villagers-leaderboard {
        background: linear-gradient(to top, #FFD700, #FFB6C1); /* Gradient from gold to light pink */
      }
      #villagers-leaderboard h3 {
        color: #8b4513; /* Brownish-gold for better contrast */
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.5);
      }
      
      .category-leaderboard:last-child {
        margin-bottom: 0;
      }
      
      .leaderboard-score {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 15px;
        margin: 4px 0;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 6px;
        border-left: 4px solid transparent;
        transition: all 0.2s ease;
        color: #3a2a1b;
        font-weight: 500;
      }
      
      .leaderboard-score .name {
        flex: 1;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-weight: 500;
        padding: 0 15px 0 8px;
        text-align: left;
        font-size: 1.05rem;
        color: inherit;
      }
      
      .leaderboard-score .score {
        flex: 0 0 auto;
        min-width: 60px;
        text-align: right;
        font-weight: 600;
        color: #2c3e50;
        white-space: nowrap;
        padding: 4px 10px;
        background: rgba(255, 255, 255, 0.4);
        border-radius: 4px;
        font-size: 1.05rem;
        border: 1px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      }
      
      .leaderboard-score.is-new {
        background-color: rgba(76, 175, 80, 0.1);
      }
      
      .dark-mode .leaderboard-score {
        background-color: rgba(50, 50, 55, 0.9);
        color: #f0f0f0;
        border-left: 3px solid #8b5a2b;
        transition: all 0.2s ease;
      }
      
      .dark-mode .leaderboard-score:hover {
        background-color: rgba(60, 60, 70, 0.95);
        transform: translateX(3px);
      }
      
      .dark-mode .leaderboard-score .score {
        background-color: rgba(255, 255, 255, 0.15);
        color: #ffffff;
        border-color: rgba(255, 255, 255, 0.1);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }
      
      .dark-mode .leaderboard-score:nth-child(4),
      .dark-mode .leaderboard-score:nth-child(5),
      .dark-mode .leaderboard-score:nth-child(6),
      .dark-mode .leaderboard-score:nth-child(7),
      .dark-mode .leaderboard-score:nth-child(8),
      .dark-mode .leaderboard-score:nth-child(9),
      .dark-mode .leaderboard-score:nth-child(10) {
        background-color: rgba(50, 50, 70, 0.95);
        color: #ffffff;
        border-left-color: #8b5a2b;
      }
      
      .leaderboard-score:nth-child(4),
      .leaderboard-score:nth-child(5),
      .leaderboard-score:nth-child(6),
      .leaderboard-score:nth-child(7),
      .leaderboard-score:nth-child(8),
      .leaderboard-score:nth-child(9),
      .leaderboard-score:nth-child(10) {
        background-color: #f0f0f0;
        color: #2a1e13;
        font-weight: 500;
        border-left: 4px solid #8b5a2b;
      }
      
      /* Responsive adjustments */
      @media (max-width: 768px) {
        .category-leaderboard h3 {
          font-size: 1.1rem;
        }
        
        .leaderboard-score {
          font-size: 0.9rem;
        }
        
        .leaderboard-score .score {
          min-width: 50px;
        }
      }
      
      @media (max-width: 480px) {
        .category-leaderboard h3 {
          font-size: 1rem;
        }
        
        .leaderboard-score {
          font-size: 0.8rem;
        }
        
        .leaderboard-score .score {
          min-width: 45px;
        }

        /* Make guess input field fit mobile screen */
        #guess-input {
          width: 100%;
          max-width: 100%;
          box-sizing: border-box;
          padding: 8px;
          margin: 8px 0;
        }

        /* Fix admin container overlap on mobile */
        #admin-tools-container {
          position: absolute;
          top: 50px;
          left: 0;
          right: 0;
          background-color: var(--container-bg);
          border-radius: 10px;
          padding: 15px;
          margin: 10px;
          z-index: 1000;
        }

        /* Adjust admin toggle button position on mobile */
        #admin-toggle-btn {
          top: 10px;
          left: 10px;
          z-index: 2000;
        }
      }
      
      /* Special styling for top 3 positions */
      .leaderboard-score:nth-child(-n+3) .name::before {
        content: counter(rank);
        color: var(--text-color);
        font-weight: bold;
        margin-right: 5px;
        padding: 2px 5px;
        border-radius: 3px;
        background-color: var(--container-bg);
        text-shadow: 0 0 1px rgba(0, 0, 0, 0.8); /* Thin black outline */
      }
      
      /* Media Queries for Mobile Responsiveness */
      /* Common container styles for mobile */
      .mobile-container {
        width: 95%;
        margin-left: auto;
        margin-right: auto;
        box-sizing: border-box;
        border-radius: 10px;
        border: 2px solid var(--border-color);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        background-color: #e8f5e9; /* Soft mint green that complements the theme */
      }
      
      /* Ensure all containers have the same styling on mobile */
      @media (max-width: 768px) {
        #category-selector {
          flex-direction: row;
          justify-content: center;
          flex-wrap: wrap;
          gap: 10px;
        }
        
        #category-selector > div {
          flex: 0 1 auto;
          min-width: 150px;
          max-width: 180px;
        }
        
        #category, #difficulty {
          font-size: 0.85rem !important;
          padding: 5px !important;
        }
        
        .mobile-container {
          width: 95% !important;
          max-width: 600px !important;
          margin: 5px auto !important;
          padding: 10px !important;
          background-image: url("images/background.webp") !important;
          background-color: rgba(26, 32, 44, 0.9) !important;
          background-blend-mode: overlay !important;
          color: var(--dark-text) !important;
          border: 2px solid var(--border-color) !important;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.1) !important;
          box-sizing: border-box !important;
          text-align: center !important;
        }
        
        /* Reduce spacing in game elements */
        h1 {
          font-size: 1rem !important;
          margin: 5px 0 !important;
          line-height: 1.2;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          background: linear-gradient(90deg, 
            #ff0000 0%,
            #ff7e00 10%,
            #ffff00 20%,
            #00ff00 30%,
            #00ffff 40%,
            #0000ff 50%,
            #8b00ff 60%,
            #ff00ff 70%,
            #ff0000 80%
          );
          -webkit-background-clip: text;
          background-clip: text;
          color: transparent;
          animation: rainbow 2s linear infinite;
        }

        @keyframes rainbow {
          0% {
            background-position: 0% 50%;
          }
          100% {
            background-position: 100% 50%;
          }
        }
        
        .high-score-container {
          margin-bottom: 10px !important;
        }
        
        #category-selector {
          margin: 5px 0 !important;
        }
        
        .score-container {
          margin: 5px 0 !important;
          display: flex !important;
          justify-content: center !important;
          gap: 5px !important;
          align-items: center !important;
          font-size: 0.9rem !important;
        }
        
        .mobile-timer-wrapper {
          display: flex !important;
          flex-direction: column !important;
          align-items: center !important;
          gap: 5px !important;
        }
        
        .timer-container {
          margin: 0 !important;
          padding: 3px 6px !important;
          border-radius: 12px !important;
          font-size: 0.85rem !important;
          background-color: rgba(255, 255, 255, 0.9) !important;
          order: -1 !important; /* Ensures timer is above score */
        }
        
        .timer {
          font-size: 0.9rem !important;
          padding: 2px 4px !important;
          margin: 0 !important;
        }
        
        #score {
          margin-top: 2px !important;
        }
        
        #imageDisplay {
          max-height: 250px !important;
          margin: 5px auto !important;
        }
        
        #feedback {
          margin: 5px !important;
          min-height: 20px !important;
        }
        
        #guess-input {
          margin: 5px 0 !important;
        }
        
        button {
          margin: 5px 2px !important;
          padding: 8px 10px !important;
        }
        
        /* Special handling for mobile nav bar to maintain flex layout */
        .mobile-nav-bar.mobile-container {
          display: flex !important;
          justify-content: space-between !important;
          text-align: left !important;
        }
      }
      
      /* Responsive styles for leaderboards */
      @media (max-width: 1000px) {
        .leaderboards-container {
          max-width: 700px;
        }
      }
      
      @media (max-width: 768px) {
        .leaderboards-container {
          grid-template-columns: 1fr 1fr;
          max-width: 600px;
          gap: 15px;
        }
      }
      
      @media (max-width: 600px) {
        .leaderboards-container {
          grid-template-columns: 1fr;
          max-width: 350px;
          gap: 10px; /* Reduced from 15px to 10px to match the game container spacing */
          margin-top: 10px; /* Add top margin to match spacing below game container */
        }
        
        .category-leaderboard {
          margin-bottom: 10px; /* Ensure consistent spacing between leaderboards */
        }
      }
      
      @media (max-width: 768px) {
        body {
          padding: 10px;
          display: flex;
          flex-direction: column;
          align-items: center;
        }
        
        /* Create space above game container for buttons */
        .mobile-nav-bar {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 10px 5px;
          margin-bottom: 15px;
          background-color: rgba(255, 249, 240, 0.9);
          border: 2px solid var(--border-color);
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        /* Style mobile buttons */
        .mobile-btn {
          background-color: #4a90e2;
          color: white;
          border: none;
          border-radius: 6px;
          padding: 8px 12px;
          font-size: 12px;
          font-weight: bold;
          cursor: pointer;
        }
        
        /* Hide desktop buttons on mobile */
        #admin-toggle-btn, 
        #logoutBtn, 
        button[onclick*="leaderboards.html"] {
          display: none;
        }
        
        #game-container {
          padding: 15px 10px;
          margin-top: 10px;
        }
        
        .category-container {
          flex-direction: column;
          align-items: center;
        }
        
        .timer-container {
          margin-left: 0;
          margin-top: 10px;
        }
        
        input, button {
          margin: 5px 2px;
          padding: 8px;
          font-size: 14px;
        }
        
        #leaderboard-container {
          width: 95%;
          margin-left: auto;
          margin-right: auto;
          background-color: #e8f5e9; /* Soft mint green that complements the theme */
        }
        
        /* Ensure modal is properly sized on mobile */
        .modal-content {
          width: 90%;
          max-width: 300px;
          padding: 15px;
        }
      }
      
      /* Small mobile devices */
      @media (max-width: 480px) {
        h1 {
          font-size: 1.5rem;
        }
        
        .category-leaderboard {
          min-width: 150px;
        }
        
        #guess-input {
          max-width: 100%;
        }
        
        #leaderboard-container {
          width: 95%;
          margin-left: auto;
          margin-right: auto;
          background-color: #e8f5e9;
        }
      }
    </style>
    <style>
      /* Style for welcome message on mobile */
      @media (max-width: 768px) {
        #welcome-message {
          font-size: 0.9rem !important;
          max-width: 150px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
      }
      
      /* Style for passcode input */
      #passcode-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 10000;
        justify-content: center;
        align-items: center;
      }
      
      #passcode-container {
        background: white;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        max-width: 300px;
        width: 80%;
      }
      
      #passcode-input {
        width: 100%;
        padding: 10px;
        margin: 15px 0;
        font-size: 16px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      
      #passcode-submit {
        background-color: #4a90e2;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
      }
      
      #passcode-submit:hover {
        background-color: #357abd;
      }
    </style>
    <script>
      // Helper function to show notifications
      function showNotification(message) {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.position = 'fixed';
        notification.style.top = '50px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.backgroundColor = '#4a90e2';
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '5px';
        notification.style.zIndex = '9999';
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.3s ease';
        document.body.appendChild(notification);
        
        // Show and then fade out the notification
        setTimeout(() => {
          notification.style.opacity = '1';
          setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
              document.body.removeChild(notification);
            }, 300);
          }, 2000);
        }, 10);
      }
    </script>
  </head>
  <body>
    <!-- Passcode Modal -->
    <div id="passcode-modal">
      <div id="passcode-container">
        <h3 style="color: #2c3e50; margin-top: 0;">Enter Passcode</h3>
        <form id="passcode-form" onsubmit="return false;" autocomplete="off">
          <!-- Hidden username field for accessibility -->
          <div style="position: absolute; left: -9999px; width: 1px; height: 1px; overflow: hidden;">
            <label for="hidden-username">Username</label>
            <input type="text" id="hidden-username" name="username" autocomplete="username" tabindex="-1">
          </div>
          <input type="password" id="passcode-input" name="passcode" placeholder="Enter passcode" autocomplete="new-password">
          <button type="button" id="passcode-submit">Submit</button>
        </form>
      </div>
    </div>
    <!-- Fixed Top Navigation Bar -->
    <div id="fixed-nav-bar" style="position:fixed; top:0; left:0; width:100vw; height:85px; background:rgba(255,255,255,0.5); z-index:999; display:flex; justify-content:space-between; align-items:center; box-shadow:0 2px 12px rgba(0,0,0,0.07); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px); padding: 0 30px 0 20px;">
      <!-- Left Side: Admin Button and Welcome Message -->
      <div style="display: flex; align-items: center; gap: 20px;">
        <button id="admin-toggle-btn-mobile" class="mobile-btn" style="background:transparent; border:none; cursor:pointer; width:60px; height:60px; display:flex; align-items:center; justify-content:center; padding:0;">
          <img src="images/admin.png" alt="Nook" style="width:60px; height:60px;">
        </button>
        <!-- Welcome Message Speech Bubble -->
        <div id="welcome-message" class="speech-bubble" style="font-family: 'CustomFont', sans-serif; font-size: 1rem; color: #5a3d2b; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); background-color: #ffffff; padding: 4px 10px; position: absolute; left: 85px; top: 50%; transform: translateY(-50%); z-index: 1000; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border-radius: 8px;">
          Welcome, <span id="username-display">Guest</span>!
        </div>
        <!-- Separate tail element for better control -->
        <div class="speech-bubble-tail" style="position: absolute; left: 79px; top: 50%; transform: translateY(-50%); width: 0; height: 0; border: 8px solid transparent; border-right-color: #ffffff; border-left: 0; border-bottom: 0; z-index: 1001;"></div>
      </div>
      
      <!-- Center: Standalone Mode Indicator -->
      <div id="standalone-indicator-container" style="position: absolute; left: 50%; transform: translateX(-50%); top: 15px; display: none;">
        <button id="standalone-mode-btn" style="background: #ff9800; color: white; border: none; border-radius: 20px; padding: 8px 16px; font-family: 'CustomFont', sans-serif; font-size: 0.9rem; box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer;">
          Standalone Mode
        </button>
      </div>
      
      <!-- Speech Bubble Styles -->
      <style>
        @keyframes pulse {
          0% { opacity: 0.4; }
          50% { opacity: 1; }
          100% { opacity: 0.4; }
        }
        
        .speech-bubble {
          position: relative;
          background: #ffffff;
          border-radius: 0.3em;
          line-height: 1.2;
        }
        
        .speech-bubble:after {
          content: '';
          position: absolute;
          left: -6px;
          top: 50%;
          width: 0;
          height: 0;
          border: 8px solid transparent;
          border-right-color: #ffffff;
          border-left: 0;
          border-bottom: 0;
          transform: translateY(-50%);
          z-index: 1001;
        }
        
        /* Mobile styles for welcome message */
        @media (max-width: 768px) {
          #welcome-message {
            font-size: 0.85rem !important;
            max-width: 140px;
            padding: 5px 12px;
            left: 75px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            border-radius: 8px;
          }
          
          .speech-bubble-tail {
            left: 69px;
            top: 50%;
            transform: translateY(-50%);
            display: block !important;
          }
          
          /* Hide standalone mode button on mobile */
          #standalone-indicator-container {
            display: none !important;
          }
        }
      </style>
      
      <!-- Right Side: Sound and Home Buttons -->
      <div style="position: absolute; right: 60px; top: 15px; display: flex; gap: 8px; align-items: center;">
        <button id="sound-toggle-mobile" class="mobile-btn" style="background:rgba(255,255,255,0.9); box-shadow:0 4px 16px rgba(0,0,0,0.18); border:none; cursor:pointer; width:48px; height:48px; border-radius:50%; display:flex; align-items:center; justify-content:center; transition:all 0.3s ease;" aria-label="Toggle sound">
          <img src="images/speaker.png" alt="Sound" style="width:28px; height:28px; transition:all 0.3s ease;">
        </button>
        <button id="logoutBtn-mobile" class="mobile-btn" style="background:rgba(255,255,255,0.9); box-shadow:0 4px 16px rgba(0,0,0,0.18); border:none; cursor:pointer; width:48px; height:48px; border-radius:50%; display:flex; align-items:center; justify-content:center; transition:all 0.3s ease;">
          <img src="images/home.png" alt="Home" style="width:28px; height:28px; transition:all 0.3s ease;">
        </button>
      </div>
    </div>
    <div style="width:100%; height:85px;" id="header-spacer"></div>
    
    <script>
      // Function to check if the server is available
      async function checkServerAvailable() {
        const API_URL = 'http://localhost:3002';
        try {
          console.log('Checking server availability at:', API_URL);
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
          
          // Try direct health check first
          try {
            const response = await fetch(`${API_URL}/health`, {
              method: 'GET',
              signal: controller.signal,
              mode: 'cors',
              headers: {
                'Accept': 'application/json'
              }
            });
            
            clearTimeout(timeoutId);
            if (response.ok) {
              console.log('Server is available');
              return true;
            }
          } catch (healthError) {
            console.log('Health check failed, trying root endpoint');
          }
          
          // If health check fails, try root endpoint
          const baseUrl = API_URL.split('/api')[0];
          const rootResponse = await fetch(baseUrl, {
            method: 'GET',
            signal: controller.signal,
            mode: 'cors',
            headers: {
              'Accept': 'application/json'
            }
          });
          
          clearTimeout(timeoutId);
          console.log('Root endpoint check result:', rootResponse.ok);
          return rootResponse.ok;
        } catch (error) {
          console.error('Server availability check failed:', error);
          return false;
        }
      }
      
      // Function to show or hide the standalone mode indicator
      function updateStandaloneModeIndicator() {
        const standaloneContainer = document.getElementById('standalone-indicator-container');
        const standaloneBtn = document.getElementById('standalone-mode-btn');
        
        if (isStandaloneMode()) {
          standaloneContainer.style.display = 'block';
          
          // Add click handler to show explanation when clicked
          standaloneBtn.onclick = function() {
            alert('You are playing in standalone mode. Your scores are saved locally and not shared online.');
          };
        } else {
          standaloneContainer.style.display = 'none';
        }
      }
      
      // Function to update the welcome message with the username
      function updateWelcomeMessage() {
        const username = localStorage.getItem('username') || sessionStorage.getItem('username') || 'Guest';
        const usernameDisplay = document.getElementById('username-display');
        if (usernameDisplay) {
          usernameDisplay.textContent = username;
        }
      }
      
      // Mobile navigation buttons event listeners
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize standalone mode status
        window.standaloneMode = isStandaloneMode();
        
        // Check server connection when the page loads
        document.addEventListener('DOMContentLoaded', async function() {
          // Update welcome message
          updateWelcomeMessage();
          
          // Check if we're already in standalone mode
          if (window.standaloneMode) {
            updateStandaloneModeIndicator();
            return;
          }
          
          // Try to check server connection
          if (typeof checkServerAvailable === 'function') {
            const serverAvailable = await checkServerAvailable();
            if (!serverAvailable && !localStorage.getItem('standalone_confirmed_this_session')) {
              // Server is not available, offer standalone mode
              if (confirm("Server connection unavailable. Your scores will be saved locally but not shared online. Continue in standalone mode?")) {
                localStorage.setItem('standalone_confirmed_this_session', 'true');
                localStorage.setItem('force_standalone', 'true');
                window.standaloneMode = true;
              } else {
                // User declined standalone mode, redirect to index
                window.location.href = 'index.html';
                return;
              }
            }
            
            // Update the standalone mode indicator
            updateStandaloneModeIndicator();
          } else {
            // Fallback if checkServerAvailable isn't available
            updateStandaloneModeIndicator();
          }
        });
        
        // Admin toggle button for mobile with secret activation pattern
        const adminToggleBtnMobile = document.getElementById('admin-toggle-btn-mobile');
        if (adminToggleBtnMobile) {
          let mobileClickCount = 0;
          let mobileClickTimer = null;
          const mobileRequiredClicks = 5;
          const mobileTimeWindow = 3000; // 3 seconds in milliseconds
          
          adminToggleBtnMobile.addEventListener('click', function() {
            // Increment click counter
            mobileClickCount++;
            
            // Add a small animation effect on click
            adminToggleBtnMobile.style.transform = 'scale(0.9)';
            setTimeout(() => {
              adminToggleBtnMobile.style.transform = 'scale(1)';
            }, 100);
            
            // Clear existing timer if it exists
            if (mobileClickTimer) {
              clearTimeout(mobileClickTimer);
            }
            
            // Set new timer to reset counter after timeWindow
            mobileClickTimer = setTimeout(() => {
              mobileClickCount = 0;
            }, mobileTimeWindow);
            
            // Check if we've reached the required number of clicks within the time window
            if (mobileClickCount >= mobileRequiredClicks) {
              // Reset counter
              mobileClickCount = 0;
              
              // Check if already in admin mode
              const adminToolsContainer = document.getElementById('admin-tools-container');
              const isHidden = adminToolsContainer.style.display === 'none';
              
              // If trying to activate admin mode, show passcode modal
              if (isHidden) {
                const passcodeModal = document.getElementById('passcode-modal');
                const passcodeInput = document.getElementById('passcode-input');
                const passcodeSubmit = document.getElementById('passcode-submit');
                
                // Show the modal
                passcodeModal.style.display = 'flex';
                setTimeout(() => passcodeInput.focus(), 100); // Delay focus to ensure modal is visible
                
                // Handle passcode submission with debounce to prevent multiple rapid submissions
                let isProcessing = false;
                const checkPasscode = () => {
                  if (isProcessing) return; // Prevent multiple submissions
                  isProcessing = true;
                  
                  // Get the stored passcode or use default
                  const storedPasscode = localStorage.getItem('adminPasscode') || 'blathers'; // Default passcode
                  const enteredPasscode = passcodeInput.value;
                  
                  // Simple validation
                  if (!enteredPasscode) {
                    isProcessing = false;
                    return;
                  }
                  
                  // Check passcode
                  if (enteredPasscode === storedPasscode) {
                    adminToolsContainer.style.display = 'block';
                    passcodeModal.style.display = 'none';
                    passcodeInput.value = ''; // Clear the input
                    showNotification('Admin Mode Activated');
                  } else {
                    alert('Incorrect passcode');
                    passcodeInput.value = ''; // Clear the input
                    setTimeout(() => passcodeInput.focus(), 100);
                  }
                  
                  // Reset processing flag after a short delay
                  setTimeout(() => {
                    isProcessing = false;
                  }, 300);
                };
                
                // Handle Enter key
                passcodeInput.onkeydown = (e) => {
                  if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent form submission
                    checkPasscode();
                  } else if (e.key === 'Escape') {
                    passcodeModal.style.display = 'none';
                    passcodeInput.value = '';
                  }
                };
                
                // Handle button click
                passcodeSubmit.onclick = checkPasscode;
                
                // Handle clicking outside the modal to close
                passcodeModal.onclick = (e) => {
                  if (e.target === passcodeModal) {
                    passcodeModal.style.display = 'none';
                    passcodeInput.value = '';
                  }
                };
                
                return; // Don't proceed with the rest of the click handler
              } else {
                // Deactivating admin mode - no passcode needed
                adminToolsContainer.style.display = 'none';
              }
              
              // Show notification for admin mode activation
              showNotification('Admin Mode Deactivated');
            }
          });
        }
        
        // Home button for mobile
        const logoutBtnMobile = document.getElementById('logoutBtn-mobile');
        if (logoutBtnMobile) {
          logoutBtnMobile.addEventListener('click', function() {
            localStorage.removeItem('acnh_current_score');
            localStorage.removeItem('acnh_last_category');
            window.location.href = 'index.html';
          });
        }
        
        // Sound toggle button for mobile
        const soundToggleBtnMobile = document.getElementById('sound-toggle-mobile');
        if (soundToggleBtnMobile) {
          // Initialize sound state (off by default)
          soundEnabled = false;
          
          // Set initial image to muted
          const soundImg = soundToggleBtnMobile.querySelector('img');
          if (soundImg) {
            soundImg.src = 'images/speaker-mute.png';
            soundImg.alt = 'Sound Off';
          }
          
          soundToggleBtnMobile.addEventListener('click', function() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('acnh_sound_enabled', soundEnabled);
            
            // Add a small animation effect on click
            soundToggleBtnMobile.style.transform = 'scale(0.9)';
            setTimeout(() => {
              soundToggleBtnMobile.style.transform = 'scale(1)';
            }, 100);
            
            // Update the image based on sound state
            if (soundImg) {
              soundImg.src = soundEnabled ? 'images/speaker.png' : 'images/speaker-mute.png';
              soundImg.alt = soundEnabled ? 'Sound On' : 'Sound Off';
            }
          });
        }
        

      });
    </script>
    
    <!-- Desktop Buttons (hidden on mobile) -->
    <div class="nav-container" style="
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      z-index: 1000;
      background-color: #4a90e2;
      padding: 8px 12px;
      border-radius: 6px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease !important;
      display: none; /* Hide on mobile */">
      <button id="admin-toggle-btn" style="
        background-color: #4a90e2;
        color: white;
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-family: 'CustomFont', Arial, sans-serif;
        transition: background-color 0.3s ease;
        display: none; /* Hide on mobile */">
        Show Admin Tools
      </button>
      <button id="logoutBtn" style="
        background-color: #4a90e2;
        color: white;
        padding: 8px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-family: 'CustomFont', Arial, sans-serif;
        transition: background-color 0.3s ease;
        display: none; /* Hide on mobile */">Home</button>
    </div>

    <style>
      #admin-toggle-btn:hover {
        background-color: #357abd !important;
      }

      /* Start Game Button Hover Effect */
      #start-game-btn {
        transition: background-color 0.3s ease !important;
      }

      #start-game-btn:hover {
        background-color: #45a049 !important;
      }

      /* Back to Home Button Hover Effect */
      .logout-btn {
        transition: background-color 0.3s ease !important;
      }

      .logout-btn:hover {
        background-color: #357abd !important;
      }
    </style>

    <div
      id="greeting"
      style="position: absolute; top: 10px; left: 10px; font-weight: bold"
    ></div>
    

    
    <!-- Main Content Wrapper -->
    <div id="admin-tools-container" style="display: none; margin: 10px auto; max-width: 300px; padding: 20px; background: rgba(255, 255, 255, 0.95); border-radius: 8px; box-shadow: 0 2px 15px rgba(0,0,0,0.15);">
      <h2 style="margin: 0 0 15px 0; text-align: center; color: #5a3d2b; font-size: 1.5em;">Admin Tools</h2>
      <div style="display: flex; flex-direction: column; gap: 12px;">
        <button id="simulate-score-btn" style="width: 100%; padding: 10px; margin: 0;">Simulate High Score</button>
        <button id="reset-fish-btn" style="width: 100%; padding: 10px; margin: 0;">Reset Fish</button>
        <button id="reset-bugs-btn" style="width: 100%; padding: 10px; margin: 0;">Reset Bugs</button>
        <button id="reset-sea-btn" style="width: 100%; padding: 10px; margin: 0;">Reset Sea</button>
        <button id="reset-villagers-btn" style="width: 100%; padding: 10px; margin: 0;">Reset Villagers</button>
        <button id="reset-to-defaults-btn" style="width: 100%; padding: 10px; margin: 0; background-color: #4a90e2; color: white;">Reset All Leaderboards</button>
        <button id="reset-high-score" style="width: 100%; padding: 10px; margin: 0; background-color: #ffa500; color: white;">Reset Personal Best</button>
      </div>
    </div>

    <div style="width: 100%; display: flex; flex-direction: column; align-items: center;">
      <!-- Game Container -->
      <div id="game-container" class="mobile-container">
      <div class="nav-container" style="
        position: absolute;
        top: 10px;
        left: 10px;
        display: flex;
        gap: 10px;
        align-items: center;
        z-index: 1000;
        background-color: #4a90e2;
        padding: 8px 12px;
        border-radius: 6px;
        color: white;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.3s ease !important;
        display: none; /* Hide on mobile */">
        <button id="admin-toggle-btn" style="
          background: none;
          border: none;
          cursor: pointer;
          padding: 0;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background-color: transparent;
          transition: transform 0.2s ease;
          position: absolute;
          z-index: 1000;
          display: none; /* Hide on mobile */">
          <img src="images/admin.png" alt="Nook" style="width: 40px; height: 40px; border-radius: 50%;">
        </button>
        <button id="sound-toggle" style="
          background: none;
          border: none;
          cursor: pointer;
          padding: 0;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          background-color: rgba(255, 255, 255, 0.3);
          transition: all 0.2s ease;
          position: relative;
          margin: 0 auto;
          display: none; /* Hide on mobile */
          display: flex;
          align-items: center;
          justify-content: center;">
          <img src="images/speaker.png" alt="Sound" style="width: 28px; height: 28px; transition: all 0.2s ease;">
        </button>
        <button id="logoutBtn" style="
          background: none;
          border: none;
          border-radius: 50%;
          cursor: pointer;
          width: 40px;
          height: 40px;
          padding: 0;
          background-color: rgba(255, 255, 255, 0.3);
          transition: all 0.2s ease;
          display: none; /* Hide on mobile */
          align-items: center;
          justify-content: center;
          margin-left: 10px;">
          <img src="images/home.png" alt="Home" style="width: 28px; height: 28px; transition: all 0.2s ease;">
        </button>
      </div>
      
      <h1 style="
        font-size: 1.8rem;
        margin: 10px 0 20px;
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        background: linear-gradient(90deg, 
          #ff0000 0%,
          #ff7e00 10%,
          #ffff00 20%,
          #00ff00 30%,
          #00ffff 40%,
          #0000ff 50%,
          #8b00ff 60%,
          #ff00ff 70%,
          #ff0000 80%
        );
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: rainbow 2s linear infinite;
      ">Animal Crossing: New Horizons<br>Identifier Game</h1>
      <div id="category-selector" class="category-container" style="display: flex; flex-direction: column; align-items: center; gap: 10px; margin: 10px 0; width: 100%;">
        <div style="display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 200px;">
          <label for="category" style="margin-bottom: 5px; font-size: 0.9rem; width: 100%; text-align: center;">Category</label>
          <select id="category" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #8b4513; font-size: 0.9rem; min-width: 0;">
            <option value="fish">Fish</option>
            <option value="bugs">Bugs</option>
            <option value="sea">Sea Creatures</option>
            <option value="villagers">Villagers</option>
          </select>
        </div>
        
        <div style="display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 200px;">
          <label for="difficulty" style="margin-bottom: 5px; font-size: 0.9rem; width: 100%; text-align: center;">Difficulty</label>
          <select id="difficulty" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #8b4513; font-size: 0.9rem; min-width: 0;">
            <option value="15000">Easy (15s)</option>
            <option value="10000">Medium (10s)</option>
            <option value="5000">Hard (5s)</option>
          </select>
        </div>
      </div>
      <div class="high-score-container">
        <div id="high-score">Personal Best: 0</div>
        <button id="start-game-btn" style="background-color: #4CAF50;">Start Game</button>
      </div>
      
      <div class="sound-settings" style="margin-top: 10px; display: flex; justify-content: center; align-items: center;">
      </div>
      <div class="score-container">
        <div class="mobile-timer-wrapper">
          <div class="timer-container">
            <div id="timer" class="timer">Time: 15</div>
          </div>
          <div id="score">Score: 0</div>
        </div>
      </div>
      <div class="loading-leaf"></div>
      <img id="imageDisplay" src="" alt="Loading..." />

      <div id="feedback" aria-live="polite"></div>

      <input
        type="text"
        id="guess-input"
        placeholder="Enter your guess..."
        autocomplete="off"
        disabled
        style="display: none"
      />
      <button id="submit-guess" style="display: none">Submit</button>
      <button id="next-btn" style="display: none">Next Item</button>
      <button id="try-again-btn" style="display: none">Try Again</button>
      <button id="end-game-btn" style="background-color: #ff6b6b; margin-top: 20px; display: none">End Game</button>
    </div>

    </div>
    <!-- Leaderboards-->
    <div class="leaderboards-container">
    <div class="category-leaderboard" id="fish-leaderboard">
      <h3>Fish</h3>
      <div id="fish-scores"></div>
    </div>
    <div class="category-leaderboard" id="bugs-leaderboard">
      <h3>Bugs</h3>
      <div id="bugs-scores"></div>
    </div>
    <div class="category-leaderboard" id="sea-leaderboard">
      <h3>Sea Creatures</h3>
      <div id="sea-scores"></div>
    </div>
    <div class="category-leaderboard" id="villagers-leaderboard">
      <h3>Villagers</h3>
      <div id="villagers-scores"></div>
    </div>
    </div>
    <!-- High Score Modal -->
    <div id="highScoreModal" class="modal">
      <div class="modal-content">
        <h2 style="color: #2c3e50;">New High Score!</h2>
        <p style="color: #34495e;">🎉 Congratulations! You scored <span id="finalScore" style="font-weight: bold; color: #2c3e50;"></span> points! 🎉</p>
        <div id="placementMessage"></div>
        <p style="color: #2c3e50; font-weight: 500; margin-top: 15px;">🏆 Enter your name for the leaderboard:</p>
        <input type="text" id="playerName" placeholder="Your name" maxlength="10" style="width: 150px; padding: 8px; font-size: 14px;" />
        <div class="modal-buttons">
          <button id="submitScore" class="modal-btn submit-btn">Submit</button>
          <button id="skipSubmit" class="modal-btn skip-btn">Skip</button>
        </div>
      </div>
    </div>

    <script>
      const NOOKIPEDIA_API_KEY = "8a10f688-39d6-40b8-8426-744f30542e94"; // API key
      const apiEndpoint = "https://api.nookipedia.com";
      const apiVersion = "1.0.0";
      const imageDisplay = document.getElementById("imageDisplay");
      const guessInput = document.getElementById("guess-input");
      const submitButton = document.getElementById("submit-guess");
      const nextButton = document.getElementById("next-btn");
      const feedbackElement = document.getElementById("feedback");
      const scoreElement = document.getElementById("score");
      const highScoreElement = document.getElementById("high-score");
      const categorySelector = document.getElementById("category");
      const difficultySelector = document.getElementById("difficulty");
      const logoutBtn = document.getElementById("logoutBtn");
      const adminToggleBtn = document.getElementById("admin-toggle-btn");
      const adminToolsContainer = document.getElementById("admin-tools-container");
      
      // Sound elements
      const correctSound = document.getElementById("correct-sound");
      const wrongSound = document.getElementById("wrong-sound");
      const gameOverSound = document.getElementById("game-over-sound");
      const startGameSound = document.getElementById("start-game-sound");
      const highScoreSound = document.getElementById("high-score-sound");
      
      // Sound settings
      let soundEnabled = false; // Default sound is off
      
      // Sound manager function
      function playSound(sound) {
        if (soundEnabled && sound) {
          // Reset the sound to the beginning if it's already playing
          sound.pause();
          sound.currentTime = 0;
          // Play the sound
          sound.play().catch(error => {
            console.error('Error playing sound:', error);
          });
        }
      }

    // Add event listener for admin tools toggle with secret activation pattern
    let clickCount = 0;
    let clickTimer = null;
    const requiredClicks = 5;
    const timeWindow = 3000; // 3 seconds in milliseconds
    
    adminToggleBtn.addEventListener("click", () => {
      // Increment click counter
      clickCount++;
      
      // Add a small animation effect on click
      adminToggleBtn.style.transform = 'scale(0.9)';
      setTimeout(() => {
        adminToggleBtn.style.transform = 'scale(1)';
      }, 100);
      
      // Clear existing timer if it exists
      if (clickTimer) {
        clearTimeout(clickTimer);
      }
      
      // Set new timer to reset counter after timeWindow
      clickTimer = setTimeout(() => {
        clickCount = 0;
      }, timeWindow);
      
      // Check if we've reached the required number of clicks within the time window
      if (clickCount >= requiredClicks) {
        // Reset counter
        clickCount = 0;
        
        // Toggle admin tools
        const isHidden = adminToolsContainer.style.display === "none";
        adminToolsContainer.style.display = isHidden ? "block" : "none";
        
        // Add a subtle notification that admin mode is activated/deactivated
        const notification = document.createElement('div');
        notification.textContent = isHidden ? 'Admin Mode Activated' : 'Admin Mode Deactivated';
        notification.style.position = 'fixed';
        notification.style.top = '50px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.backgroundColor = '#4a90e2';
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '5px';
        notification.style.zIndex = '9999';
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.3s ease';
        document.body.appendChild(notification);
        
        // Show and then fade out the notification
        setTimeout(() => {
          notification.style.opacity = '1';
          setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
              document.body.removeChild(notification);
            }, 300);
          }, 2000);
        }, 10);
      }
    });

    // Add event listener for sound toggle button
    const soundToggleBtn = document.getElementById('sound-toggle');
    soundToggleBtn.addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      soundToggleBtn.innerHTML = soundEnabled ? '🔊 Sound: ON' : '🔇 Sound: OFF';
      soundToggleBtn.style.backgroundColor = soundEnabled ? '#4a90e2' : '#cccccc';
      
      // Save sound preference to localStorage
      localStorage.setItem('acnh_sound_enabled', soundEnabled.toString());
    });
    
    // Load sound preference from localStorage
    const savedSoundPreference = localStorage.getItem('acnh_sound_enabled');
    if (savedSoundPreference !== null) {
      soundEnabled = savedSoundPreference === 'true';
      soundToggleBtn.innerHTML = soundEnabled ? '🔊 Sound: ON' : '🔇 Sound: OFF';
      soundToggleBtn.style.backgroundColor = soundEnabled ? '#4a90e2' : '#cccccc';
    }

      // Prevent right-click and dragging on image
      imageDisplay.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        return false;
      });

      // Prevent image dragging
      imageDisplay.addEventListener('dragstart', (e) => {
        e.preventDefault();
        return false;
      });
      imageDisplay.addEventListener('drag', (e) => {
        e.preventDefault();
        return false;
      });

      const leaderboardElement = document.getElementById("leaderboard");

      const urlParams = new URLSearchParams(window.location.search);
      const isGuest = urlParams.get("guest") === "true";

      if (isGuest) {
        logoutBtn.textContent = "Back to Home";
      }

      logoutBtn.addEventListener("click", () => {
        localStorage.removeItem("acnh_current_score");
        localStorage.removeItem("acnh_last_category");
        window.location.href = "index.html";
      });

      let score = 0;
      let highScore = localStorage.getItem("acnh_high_score") || 0;
      let currentItem = null;
      let currentCategory = null;
      let shownItems = {}; // Object to track shown items for each category
      let allItems = {}; // Store all items for each category
      let availableItems = []; // Current available items for the category
      let timerInterval = null;
      let timeLeft = 15; // Default to easy mode (15s)
      let maxTime = 15; // Will be updated based on difficulty
      let isLoadingItems = false; // Track if we're currently loading items
      let lastLoadedCategory = null; // Track the last loaded category
      let gameOver = false; // Flag to track if the game is over
      let currentlyDisplayingItem = null; // Track which item is being displayed
      let isTryingFallback = false; // Flag to prevent recursive fallback calls
      const timerDisplay = document.getElementById('timer');

      async function loadCategoryItems(category) {
        // If we've already loaded this category and have items, use them
        if (allItems[category]?.length > 0) {
          console.log(`Using cached items for ${category}`);
          return allItems[category];
        }
        
        // If we're already loading this category, wait for it to complete
        if (isLoadingItems) {
          console.log(`Already loading ${category}, waiting...`);
          // Wait with multiple retries before timing out
          for (let i = 0; i < 10; i++) { // Try up to 10 times (1 second total)
            await new Promise(resolve => setTimeout(resolve, 100));
            if (allItems[category]?.length > 0) {
              return allItems[category];
            }
          }
          // If we still don't have items after waiting, use fallback data
          console.log(`Timeout waiting for ${category} to load, using fallback data`);
          return getFallbackData(category);
        }
        
        // Set loading flag
        isLoadingItems = true;
        
        // Define the API endpoint based on the category
        let endpoint = "";
        switch (category) {
          case "fish":
            endpoint = "/nh/fish";
            break;
          case "bugs":
            endpoint = "/nh/bugs";
            break;
          case "sea":
            endpoint = "/nh/sea";
            break;
          case "villagers":
            endpoint = "/villagers";
            break;
          default:
            console.error("Invalid category:", category);
            isLoadingItems = false;
            return [];
        }
        
        // Use the Nookipedia API to get the items
        const apiKey = NOOKIPEDIA_API_KEY;
        const apiUrl = `${apiEndpoint}${endpoint}`;
        
        try {
          // Show loading leaf indicator
          const loadingLeaf = document.querySelector('.loading-leaf');
          if (loadingLeaf) loadingLeaf.style.display = 'block';
          
          // Attempt to fetch from API with a timeout to prevent long waits
          try {
            const response = await fetchWithTimeout(apiUrl, {
              headers: {
                "X-API-KEY": apiKey,
                "Accept-Version": apiVersion
              }
            });
            
            if (!response || !response.length) {
              console.log(`API returned empty data for ${category}, using fallback data`);
              throw new Error(`API request failed or returned empty data`);
            }
            
            console.log(`Loaded ${response.length} items for ${category} from API`);
            
            // Update last loaded category and clear loading flag
            lastLoadedCategory = category;
            isLoadingItems = false;
            
            // Process the data to ensure consistent format
            const processedItems = response.map(item => {
              return {
                name: item.name,
                image_url: item.image_url || null,
                // Add fallback image in case the API image fails to load
                fallback_image_url: `images/${category}/placeholder.svg`
              };
            });
            
            // Store the items in our global object
            allItems[category] = processedItems;
            
            // Initialize shown items for this category if it doesn't exist
            if (!shownItems[category]) {
              shownItems[category] = [];
            }
            
            // Hide loading indicators
            if (loadingLeaf) loadingLeaf.style.display = 'none';
            feedbackElement.textContent = "";
            
            return processedItems;
          } catch (error) {
            console.error("Error fetching from API:", error);
            throw error; // Let the outer catch block handle it
          }
          
        } catch (error) {
          console.error("Error loading items from API:", error);
          isLoadingItems = false; // Clear loading flag on error
          
          // Fallback to previously cached data if available
          if (allItems[category] && allItems[category].length > 0) {
            console.log(`Using cached items for ${category} due to API error`);
            return allItems[category];
          }
          
          // Hide loading indicators
          const loadingLeaf = document.querySelector('.loading-leaf');
          if (loadingLeaf) loadingLeaf.style.display = 'none';
          
          // Show error message
          feedbackElement.textContent = "Could not load items from API. Using local data.";
          
          // Use fallback data
          return getFallbackData(category);
        }
      }
      
      // Function to provide fallback data when API fails
      function getFallbackData(category) {
        console.log(`Using fallback data for ${category}`);
        // Store the fallback data in our global object so we don't try to fetch again
        if (!allItems[category]) {
          // Fallback to local data if API fails
          const mockData = {
          fish: [
            { name: "Sea Bass", image_url: "https://dodo.ac/np/images/d/d5/Sea_Bass_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Koi", image_url: "https://dodo.ac/np/images/7/7c/Koi_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Goldfish", image_url: "https://dodo.ac/np/images/a/a5/Goldfish_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Tuna", image_url: "https://dodo.ac/np/images/8/8c/Tuna_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" },
              { name: "Coelacanth", image_url: "https://dodo.ac/np/images/4/45/Coelacanth_NH_Icon.png", fallback_image_url: "images/fish/placeholder.svg" }
            ],
            bugs: [
              { name: "Common Butterfly", image_url: "https://dodo.ac/np/images/8/8f/Common_Butterfly_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Monarch Butterfly", image_url: "https://dodo.ac/np/images/a/a9/Monarch_Butterfly_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Scorpion", image_url: "https://dodo.ac/np/images/6/6f/Scorpion_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Tarantula", image_url: "https://dodo.ac/np/images/0/0e/Tarantula_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" },
              { name: "Stinkbug", image_url: "https://dodo.ac/np/images/b/b4/Stinkbug_NH_Icon.png", fallback_image_url: "images/bugs/placeholder.svg" }
            ],
            sea: [
              { name: "Sea Star", image_url: "https://dodo.ac/np/images/1/1d/Sea_Star_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Sea Urchin", image_url: "https://dodo.ac/np/images/b/b9/Sea_Urchin_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Seaweed", image_url: "https://dodo.ac/np/images/5/53/Seaweed_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Pearl Oyster", image_url: "https://dodo.ac/np/images/1/11/Pearl_Oyster_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" },
              { name: "Scallop", image_url: "https://dodo.ac/np/images/d/d5/Scallop_NH_Icon.png", fallback_image_url: "images/sea/placeholder.svg" }
            ],
            villagers: [
              { name: "Tom Nook", image_url: "https://dodo.ac/np/images/4/4f/Tom_Nook_NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "Isabelle", image_url: "https://dodo.ac/np/images/8/8e/Isabelle_NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "K.K. Slider", image_url: "https://dodo.ac/np/images/e/e0/K.K._NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "Blathers", image_url: "https://dodo.ac/np/images/b/b3/Blathers_NH.png", fallback_image_url: "images/villagers/placeholder.svg" },
              { name: "Celeste", image_url: "https://dodo.ac/np/images/9/93/Celeste_NH.png", fallback_image_url: "images/villagers/placeholder.svg" }
            ]
          };
          
          // Store the mock data for the selected category
          allItems[category] = mockData[category] || [];
          
          // Initialize shown items for this category if it doesn't exist
          if (!shownItems[category]) {
            shownItems[category] = [];
          }
          
          return allItems[category];
        }
      }

      function getAvailableItems(category) {
        if (!allItems[category]) {
          return [];
        }
        
        const shown = shownItems[category] || [];
        return allItems[category].filter(item => !shown.includes(item.name));
      }

      async function getRandomItem(category) {
        if (!category) return null;

        if (!allItems[category]) {
          return loadCategoryItems(category).then(() => getRandomItem(category));
        }

        const available = getAvailableItems(category);
        
        if (available.length === 0) {
          // Reset shown items when all items have been shown
          shownItems[category] = [];
          localStorage.setItem(`shown_items_${category}`, JSON.stringify([]));
          return getRandomItem(category);
        }

        // Get a random item from the available items
        const randomIndex = Math.floor(Math.random() * available.length);
        const item = available[randomIndex];

        // Add this item to the shown items list
        if (!shownItems[category]) {
          shownItems[category] = [];
        }
        shownItems[category].push(item.name);
        localStorage.setItem(`shown_items_${category}`, JSON.stringify(shownItems[category]));

        try {
          // First try to use the image URL from the item object if it exists
          if (item.image_url) {
            return {
              name: item.name,
              image_url: item.image_url
            };
          }
          
          // Otherwise try to fetch from API
          const imageUrl = `${apiEndpoint}/nh/${category}/${item.name}?api_key=${NOOKIPEDIA_API_KEY}`;
          const imageData = await fetchWithTimeout(imageUrl);
          
          if (imageData && imageData.data && imageData.data.image_url) {
            return {
              name: item.name,
              image_url: imageData.data.image_url
            };
          }
          
          // If API fetch fails, use fallback image
          return {
            name: item.name,
            image_url: item.fallback_image_url || `images/${category}/placeholder.svg`
          };
        } catch (error) {
          console.error('Error fetching image for item:', item.name, error);
          // Return the item with fallback image
          return {
            name: item.name,
            image_url: item.fallback_image_url || `images/${category}/placeholder.svg`
          };
        }
      }

      function showHighScoreModal(finalScore, category) {
        // Play high score sound if available
        const highScoreSound = document.getElementById('high-score-sound');
        if (highScoreSound) {
          highScoreSound.currentTime = 0;
          highScoreSound.play().catch(e => console.log('Could not play high score sound:', e));
        }
        
        // Set the final score in the modal
        const finalScoreElement = document.getElementById('finalScore');
        if (finalScoreElement) {
          finalScoreElement.textContent = finalScore;
        }
        
        // Show the modal
        const modal = document.getElementById('highScoreModal');
        if (modal) {
          modal.style.display = 'block';
          
          // Store category for later use
          modal.dataset.category = category;
          
          // Focus on the name input
          const playerNameInput = document.getElementById('playerName');
          if (playerNameInput) {
            playerNameInput.value = '';
            playerNameInput.focus();
            
            // Allow Enter key to submit
            playerNameInput.onkeypress = function(e) {
              if (e.key === 'Enter') {
                submitHighScore(finalScore, category);
              }
            };
          }
          
          // Add event listeners for the buttons
          const submitButton = document.getElementById('submitScore');
          if (submitButton) {
            submitButton.onclick = function() {
              submitHighScore(finalScore, category);
            };
          }
          
          const skipButton = document.getElementById('skipSubmit');
          if (skipButton) {
            skipButton.onclick = closeHighScoreModal;
          }
        }
      }
      
      function closeHighScoreModal() {
        document.getElementById('highScoreModal').style.display = 'none';
      }
      
      async function submitHighScore(finalScore, category, playerName = null) {
        // If playerName is not provided, get it from the input field
        if (playerName === null) {
          const playerNameInput = document.getElementById('playerName');
          if (playerNameInput) {
            playerName = playerNameInput.value.trim();
            if (!playerName) {
              alert('Please enter your name or click Skip');
              return;
            }
          } else {
            // If no input field is found, use a default name
            playerName = 'Player';
          }
        }
        
        // Get the current username from localStorage or sessionStorage
        const username = localStorage.getItem('username') || sessionStorage.getItem('username') || playerName;
        
        // Check if we're in standalone mode
        if (isStandaloneMode()) {
          // Always confirm before switching to standalone mode
          if (!localStorage.getItem('standalone_confirmed_this_session')) {
            if (confirm("Server connection unavailable. Your scores will be saved locally but not shared online. Continue in standalone mode?")) {
              // Set a session flag to avoid multiple prompts in the same session
              localStorage.setItem('standalone_confirmed_this_session', 'true');
              localStorage.setItem('force_standalone', 'true');
            } else {
              // User declined standalone mode, redirect to index
              window.location.href = 'index.html';
              return;
            }
          }
          console.log('Running in standalone mode, saving score to local storage only');
          saveScoreToLocalStorage(playerName, finalScore, category);
          return;
        }
        
        try {
          // Get the JWT token for authentication
          const token = localStorage.getItem('token') || sessionStorage.getItem('token');
          
          // Prepare the headers
          const headers = {
            'Content-Type': 'application/json',
            'x-guest-token': 'a7b9c2d5e8f3g6h1j4k7m2n5p8r3t6v9' // Default guest token from backend
          };
          
          // Add authorization header if token exists
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
          }
          
          // Submit the score to the server with a timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
          
          const response = await fetch('https://capstone-project-production-3cce.up.railway.app/api/v1/leaderboard/submit', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify({
              category: category,
              score: finalScore,
              playerName: playerName || 'Guest',
              gameData: {
                correctAnswers: finalScore,  // Using finalScore instead of score
                totalQuestions: 10,          // Should match your game's total questions
                timeTaken: 15,               // Using a default value, replace with actual time if available
                difficulty: 'medium'          // Default difficulty
              }
            }),
            signal: controller.signal
          }).catch(error => {
            // Mark API as unavailable for future calls
            window.apiUnavailable = true;
            throw error;
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`Failed to save score: ${response.status}`);
          }
          
          const result = await response.json();
          
          // Get the placement by fetching the updated leaderboard
          const leaderboardController = new AbortController();
          const leaderboardTimeoutId = setTimeout(() => leaderboardController.abort(), 2000);
          
          const leaderboardResponse = await fetch(`/api/leaderboard/${category}`, {
            signal: leaderboardController.signal
          }).catch(error => {
            window.apiUnavailable = true;
            throw error;
          });
          
          clearTimeout(leaderboardTimeoutId);
          
          if (!leaderboardResponse.ok) {
            throw new Error(`Failed to fetch leaderboard: ${leaderboardResponse.status}`);
          }
          
          const leaderboardData = await leaderboardResponse.json();
          
          // Find the placement of the new score
          const placement = leaderboardData.findIndex(entry => entry.username === username && entry.score === finalScore) + 1;
          
          // Show placement message
          showPlacementMessage(placement);
          
          // Close the modal
          closeHighScoreModal();
          
          // Update the displayed leaderboard
          updateLeaderboard();
          
        } catch (error) {
          console.log('Error with server, falling back to local storage');
          
          // Fall back to local storage if server request fails
          saveScoreToLocalStorage(playerName, finalScore, category);
        }
      }
      
      // Helper function to save score to localStorage and show placement
      function saveScoreToLocalStorage(playerName, finalScore, category) {
        // Get existing leaderboard data
        const savedLeaderboard = localStorage.getItem('acnh_leaderboard');
        let leaderboardData = {};
        
        if (savedLeaderboard) {
          try {
            leaderboardData = JSON.parse(savedLeaderboard);
          } catch (e) {
            console.error('Error parsing saved leaderboard:', e);
            leaderboardData = { ...DEFAULT_LEADERBOARD };
          }
        } else {
          leaderboardData = { ...DEFAULT_LEADERBOARD };
        }
        
        // Add the new score
        const newScore = {
            name: playerName,
            score: finalScore,
            date: new Date().toISOString().split('T')[0], // Format: YYYY-MM-DD
            isNew: true // Mark this as a new score for highlighting
        };
        
        // Add to the appropriate category
        if (!leaderboardData[category]) {
            leaderboardData[category] = [];
        }
        
        leaderboardData[category].push(newScore);
        
        // Sort scores in descending order
        leaderboardData[category].sort((a, b) => b.score - a.score);
        
        // Keep only top 10 scores
        leaderboardData[category] = leaderboardData[category].slice(0, 10);
        
        // Save the updated leaderboard to localStorage
        localStorage.setItem('acnh_leaderboard', JSON.stringify(leaderboardData));
        
        // Find the placement of the new score
        const placement = leaderboardData[category].findIndex(score => score.name === playerName && score.score === finalScore) + 1;
        
        // Show placement message
        showPlacementMessage(placement);
        
        // Close the modal
        closeHighScoreModal();
        
        // Update the displayed leaderboard
        updateLeaderboardUI(leaderboardData);
      }
      
      // Helper function to show placement message
      function showPlacementMessage(placement) {
        const placementMessage = document.getElementById('placementMessage');
        if (placement === 1) {
            placementMessage.innerHTML = '<p style="color: #ffd700; font-weight: bold;">You achieved 1st place! 🏆</p>';
        } else if (placement === 2) {
            placementMessage.innerHTML = '<p style="color: #c0c0c0; font-weight: bold;">You achieved 2nd place! 🥈</p>';
        } else if (placement === 3) {
            placementMessage.innerHTML = '<p style="color: #cd7f32; font-weight: bold;">You achieved 3rd place! 🥉</p>';
        }
      }
      
      function updateLeaderboardUI(data) {
        try {
          // Clear existing leaderboard items
          document.querySelectorAll('.leaderboard-list').forEach(list => {
            if (list && list.innerHTML) {
              list.innerHTML = '';
            }
          });

          // If no data, show empty state
          if (!data) {
            console.warn('No leaderboard data provided');
            if (window.DEFAULT_LEADERBOARD) {
              updateLeaderboardUI(window.DEFAULT_LEADERBOARD);
            }
            return;
          }

          // Handle case where data is an array (direct scores)
          if (Array.isArray(data)) {
            const defaultCategory = document.querySelector('.leaderboard-category');
            if (defaultCategory) {
              const scoresList = defaultCategory.querySelector('.leaderboard-list');
              if (scoresList) {
                scoresList.innerHTML = data.map((entry, index) => {
                  // Add special styling for top 3 positions
                  let scoreClass = 'leaderboard-score';
                  if (index === 0) scoreClass += ' first-place';
                  else if (index === 1) scoreClass += ' second-place';
                  else if (index === 2) scoreClass += ' third-place';
                  
                  // Create score div
                  const scoreDiv = document.createElement('div');
                  scoreDiv.className = scoreClass;
                  
                  // Create name and score spans
                  const rankSpan = document.createElement('span');
                  rankSpan.className = 'leaderboard-rank';
                  rankSpan.textContent = `${index + 1}.`;
                  
                  const nameSpan = document.createElement('span');
                  nameSpan.className = 'leaderboard-name';
                  nameSpan.textContent = entry.name || 'Unknown';
                  
                  const scoreValue = document.createElement('span');
                  scoreValue.className = 'leaderboard-score-value';
                  scoreValue.textContent = entry.score || 0;
                  
                  // Append elements to score div
                  scoreDiv.appendChild(rankSpan);
                  scoreDiv.appendChild(nameSpan);
                  scoreDiv.appendChild(scoreValue);
                  
                  // Add date if available
                  if (entry.date) {
                    const dateSpan = document.createElement('span');
                    dateSpan.className = 'leaderboard-date';
                    dateSpan.textContent = entry.date;
                    scoreDiv.appendChild(dateSpan);
                  }
                  
                  return scoreDiv.outerHTML;
                }).join('');
              }
            }
            return;
          }

          // Handle case where data is an object with category keys
          if (typeof data === 'object') {
            Object.entries(data).forEach(([category, scores]) => {
              if (!scores || !Array.isArray(scores)) {
                console.warn(`Invalid scores data for category ${category}:`, scores);
                return;
              }

              const categoryElement = document.getElementById(`${category}-leaderboard`);
              if (!categoryElement) {
                console.warn(`No element found for category: ${category}`);
                return;
              }

              const scoresList = categoryElement.querySelector('.leaderboard-list');
              if (!scoresList) {
                console.warn(`No scores list found in category: ${category}`);
                return;
              }

              // Add new items
              scoresList.innerHTML = scores.map((entry, index) => {
                let scoreClass = 'leaderboard-score';
                if (index === 0) scoreClass += ' first-place';
                else if (index === 1) scoreClass += ' second-place';
                else if (index === 2) scoreClass += ' third-place';
                
                // Create score div
                const scoreDiv = document.createElement('div');
                scoreDiv.className = scoreClass;
                
                // Create name and score spans
                const rankSpan = document.createElement('span');
                rankSpan.className = 'leaderboard-rank';
                rankSpan.textContent = `${index + 1}.`;
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'leaderboard-name';
                nameSpan.textContent = entry.name || 'Unknown';
                
                const scoreValue = document.createElement('span');
                scoreValue.className = 'leaderboard-score-value';
                scoreValue.textContent = entry.score || 0;
                
                // Append elements to score div
                scoreDiv.appendChild(rankSpan);
                scoreDiv.appendChild(nameSpan);
                scoreDiv.appendChild(scoreValue);
                
                // Add date if available
                if (entry.date) {
                  const dateSpan = document.createElement('span');
                  dateSpan.className = 'leaderboard-date';
                  dateSpan.textContent = entry.date;
                  scoreDiv.appendChild(dateSpan);
                }
                
                return scoreDiv.outerHTML;
              }).join('');
            });
            return;
          }

          // If we get here, the data format is not recognized
          console.error('Unexpected leaderboard data format:', data);
          if (window.DEFAULT_LEADERBOARD) {
            console.log('Falling back to default leaderboard data');
            updateLeaderboardUI(window.DEFAULT_LEADERBOARD);
          }
        } catch (error) {
          console.error('Error updating leaderboard UI:', error);
          if (window.DEFAULT_LEADERBOARD) {
            console.log('Falling back to default leaderboard data after error');
            updateLeaderboardUI(window.DEFAULT_LEADERBOARD);
          }
        }
      }
      
      // Default leaderboard data
      const DEFAULT_LEADERBOARD = {
        fish: [
          { name: "Kapp'n", score: 10 },
          { name: "Leif", score: 9 },
          { name: "Cyrus", score: 8 },
          { name: "Kicks", score: 7 },
          { name: "Redd", score: 6 },
          { name: "Mabel", score: 5 },
          { name: "Saharah", score: 4 },
          { name: "Gulliver", score: 3 },
          { name: "Wisp", score: 2 },
          { name: "Harvey", score: 1 }
        ],
        bugs: [
          { name: "Flick", score: 10 },
          { name: "Cube", score: 9 },
          { name: "Kapp'n", score: 8 },
          { name: "Kiki", score: 7 },
          { name: "Cyrus", score: 6 },
          { name: "Kicks", score: 5 },
          { name: "Redd", score: 4 },
          { name: "Mabel", score: 3 },
          { name: "Saharah", score: 2 },
          { name: "Wisp", score: 1 }
        ],
        sea: [
          { name: "Gulliver", score: 10 },
          { name: "JJ", score: 9 },
          { name: "Redd", score: 8 },
          { name: "Kapp'n", score: 7 },
          { name: "Flick", score: 6 },
          { name: "Cyrus", score: 5 },
          { name: "Kicks", score: 4 },
          { name: "Mabel", score: 3 },
          { name: "Saharah", score: 2 },
          { name: "Wisp", score: 1 }
        ],
        villagers: [
          { name: "K.K. Slider", score: 10 },
          { name: "Kapp'n", score: 9 },
          { name: "Tom Nook", score: 8 },
          { name: "Cyrus", score: 7 },
          { name: "Kicks", score: 6 },
          { name: "Redd", score: 5 },
          { name: "Mabel", score: 4 },
          { name: "Saharah", score: 3 },
          { name: "Gulliver", score: 2 },
          { name: "Harvey", score: 1 }
        ]
      };

      // Function to detect if we're running in standalone mode (without a server)
      function isStandaloneMode() {
        // If we have a valid backend API URL and no explicit force_standalone flag
        if (window.BACKEND_API) {
          // Check if we have a recent successful health check
          const healthData = localStorage.getItem('backendHealth');
          if (healthData) {
            try {
              const { status, timestamp } = JSON.parse(healthData);
              // Consider health check valid if it's less than 5 minutes old
              const isRecent = Date.now() - new Date(timestamp).getTime() < 5 * 60 * 1000;
              if (status === 'available' && isRecent) {
                return false; // Backend is available, don't use standalone mode
              }
            } catch (e) {
              console.warn('Error parsing backend health data', e);
            }
          }
        }
        
        // Check if running via file:// protocol
        const isFileProtocol = window.location.protocol === 'file:';
        
        // Check if API has been marked as unavailable in this session
        const apiUnavailable = window.apiUnavailable === true;
        
        // Check if force_standalone is set in localStorage
        const forceStandalone = localStorage.getItem('force_standalone') === 'true';
        
        // Check URL parameters (for testing purposes only)
        const urlParams = new URLSearchParams(window.location.search);
        const guestParam = urlParams.get('guest');
        
        // In production, ignore the guest parameter unless explicitly in file:// protocol
        if (window.location.hostname !== 'localhost' && !isFileProtocol) {
          return apiUnavailable || forceStandalone;
        }
        
        // For local development, respect the guest parameter
        return guestParam === 'true' || isFileProtocol || apiUnavailable || forceStandalone;
      }
      
      async function updateLeaderboard() {
        const category = categorySelector?.value || 'fish';
        console.log(`[Leaderboard] Fetching ${category} leaderboard from ${window.BACKEND_API}`);
        
        // Check if we're in standalone mode
        if (isStandaloneMode()) {
          console.log('[Leaderboard] Running in standalone mode, using local data');
          // Use local data if available
          try {
            const savedLeaderboard = localStorage.getItem('leaderboard');
            if (savedLeaderboard) {
              updateLeaderboardUI(JSON.parse(savedLeaderboard));
            } else {
              updateLeaderboardUI(DEFAULT_LEADERBOARD);
            }
          } catch (e) {
            console.error('Error parsing saved leaderboard:', e);
            updateLeaderboardUI(DEFAULT_LEADERBOARD);
          }
          return;
        }
        
        // If not in standalone mode, try to fetch from server
        try {
          // Fetch leaderboard data from the server with a timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
          
          const startTime = Date.now();
          const headers = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'x-guest-token': 'a7b9c2d5e8f3g6h1j4k7m2n5p8r3t6v9' // Default guest token from backend
          };
          
          // Add authorization header if user is logged in
          const token = localStorage.getItem('token') || sessionStorage.getItem('token');
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
          }
          
          const response = await fetch(`https://capstone-project-production-3cce.up.railway.app/api/v1/leaderboard/${category}`, {
            method: 'GET',
            headers: headers,
            signal: controller.signal
          }).catch(error => {
            if (error.name === 'AbortError') {
              console.warn('[Leaderboard] Request timed out');
            }
            window.apiUnavailable = true;
            throw error;
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error(`[Leaderboard] Server error: ${response.status} ${errorText}`);
            throw new Error(`Server responded with ${response.status}`);
          }
          
          const responseTime = Date.now() - startTime;
          console.log(`[Leaderboard] Fetched in ${responseTime}ms`);
          
          const responseData = await response.json();
          
          // Update backend health status
          localStorage.setItem('backendHealth', JSON.stringify({
            status: 'available',
            timestamp: new Date().toISOString(),
            responseTime
          }));
          
          // Format the data for the UI
          const formattedData = {};
          
          // Ensure we have valid leaderboard data
          if (Array.isArray(responseData)) {
            // If response is an array of entries
            formattedData[category] = responseData.map(entry => ({
              name: entry.username || 'Unknown',
              score: entry.score || 0,
              date: entry.date ? new Date(entry.date).toISOString().split('T')[0] : 'Unknown'
            }));
          } else if (responseData && typeof responseData === 'object') {
            // If response is an object with category as key
            const categoryData = responseData[category] || [];
            formattedData[category] = Array.isArray(categoryData) 
              ? categoryData.map(entry => ({
                  name: entry.username || 'Unknown',
                  score: entry.score || 0,
                  date: entry.date ? new Date(entry.date).toISOString().split('T')[0] : 'Unknown'
                }))
              : [];
          } else {
            console.error('Unexpected leaderboard data format:', responseData);
            throw new Error('Invalid leaderboard data format received');
          }
          
          // Update the UI with the fetched data
          updateLeaderboardUI(formattedData);
        } catch (error) {
          console.log('Using local leaderboard data:', error);
          // Fall back to local data if server request fails
          const savedLeaderboard = localStorage.getItem('leaderboard');
          if (savedLeaderboard) {
            try {
              const data = JSON.parse(savedLeaderboard);
              updateLeaderboardUI(data);
            } catch (e) {
              console.error('Error parsing saved leaderboard:', e);
              // If all else fails, use default data
              updateLeaderboardUI(DEFAULT_LEADERBOARD);
            }
          } else {
            updateLeaderboardUI(DEFAULT_LEADERBOARD);
          }
        }
      }


      async function initGame(isInitialLoad = false) {
        // Prevent multiple initializations
        if (isLoadingItem) {
          console.log('Game initialization already in progress, waiting...');
          return;
        }
        
        try {
          const category = categorySelector.value;
          console.log(`Initializing game for category: ${category}`);
          
          // Reset score only if changing categories
          if (currentCategory !== category) {
            console.log(`Category changed from ${currentCategory} to ${category}, resetting score`);
            score = 0;
            currentCategory = category;
          }
          
          localStorage.setItem("acnh_last_category", category);
          
          // Only show loading message if not the initial page load
          if (!isInitialLoad) {
            feedbackElement.textContent = "Loading...";
            feedbackElement.className = "";
          }
          
          // Disable input during initialization
          guessInput.disabled = true;
          submitButton.disabled = true;

          // If setupNewRound has been called recently, don't load a new item
          if (Date.now() - lastLoadTimestamp < 500 && currentItem && currentItem.name) {
            console.log(`Using recently loaded item: ${currentItem.name} instead of loading a new one in initGame`);
            // Just update the UI with the current item
            displayItem(currentItem);
            feedbackElement.textContent = '';
            scoreElement.textContent = `Score: ${score}`;
            return;
          }

          const item = await getRandomItem(category);
          
          if (item) {
            // Set the current item and display it
            currentItem = item;
            await displayItem(item);
            feedbackElement.textContent = '';
            scoreElement.textContent = `Score: ${score}`;
            
            // Re-enable input
            guessInput.disabled = false;
            submitButton.disabled = false;
          } else {
            console.error('No item returned from getRandomItem');
            feedbackElement.textContent = 'Failed to load game items. Please try again.';
            feedbackElement.className = 'wrong';
          }
        } catch (error) {
          console.error('Error in initGame:', error);
          feedbackElement.textContent = 'An error occurred while initializing the game. Please try again.';
          feedbackElement.className = 'wrong';
          
          // Try to recover by resetting the category
          try {
            const category = categorySelector.value;
            if (allItems[category]) {
              console.log('Attempting to reset category data');
              delete allItems[category];
              await loadCategoryItems(category);
              await initGame();
            }
          } catch (recoveryError) {
            console.error('Recovery failed:', recoveryError);
          }
        }
      }

      function updateHighScore() {
        const category = categorySelector.value;
        if (!category) return;

        // Get the current high score for this category
        const categoryKey = `acnh_high_score_${category}`;
        const currentHighScore = parseInt(localStorage.getItem(categoryKey) || '0', 10);

        let isNewPersonalBest = false;
        
        // Update category high score if new high
        if (score > currentHighScore) {
          localStorage.setItem(categoryKey, score);
          isNewPersonalBest = true;
          highScoreElement.textContent = `Personal Best: ${score}`;
        }

        // Update overall high score
        const overallHighScore = parseInt(localStorage.getItem('acnh_high_score') || '0', 10);
        if (score > overallHighScore) {
          localStorage.setItem('acnh_high_score', score);
        }
      }

      function updateScore(newScore) {
        score = newScore;
        localStorage.setItem('acnh_current_score', score);
        scoreElement.textContent = `Score: ${score}`;
      }

      async function fetchWithTimeout(resource, options = {}, timeout = 10000) { // Increased timeout to 10 seconds
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);

        try {
          const response = await fetch(resource, {
            ...options,
            signal: controller.signal,
          });
          clearTimeout(id);
          if (!response.ok) {
            console.error(`Fetch failed with status: ${response.status}`);
            throw new Error(`Fetch failed with status: ${response.status}`);
          }
          return await response.json();
        } catch (error) {
          clearTimeout(id);
          console.error(`Fetch error: ${error.message}`);
          return null;
        }
      }


      function startTimer() {
        // Don't start the timer if the game is over
        if (gameOver) {
          return;
        }
        
        // Clear any existing timer
        stopTimer();
        
        // Double-check game over state after stopping timer
        if (gameOver) {
          return;
        }
        
        // Get selected difficulty
        const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
        timeLeft = difficulty;
        maxTime = difficulty;
        
        timerDisplay.textContent = `Time: ${timeLeft}`;
        timerDisplay.classList.add('running');
        timerDisplay.classList.remove('warning', 'expired');
        
        // Store the start time for more accurate timing
        const startTime = Date.now();
        const endTime = startTime + (timeLeft * 1000);
        
        // Update timer immediately to avoid initial delay
        updateTimer();
        
        // Set up the timer with requestAnimationFrame for smoother updates
        function updateTimer() {
          // First check if game is over or timer should be stopped
          if (gameOver || timerInterval === null) {
            cancelAnimationFrame(timerInterval);
            timerInterval = null;
            return;
          }
          
          const now = Date.now();
          timeLeft = Math.max(0, Math.ceil((endTime - now) / 1000));
          
          timerDisplay.textContent = `Time: ${timeLeft}`;
          
          // Change color based on time remaining (warning at 30% of max time)
          const warningThreshold = Math.ceil(maxTime * 0.3);
          if (timeLeft <= warningThreshold) {
            timerDisplay.classList.add('warning');
            timerDisplay.classList.remove('running');
          }
          
          if (timeLeft <= 0) {
            // Properly stop the timer
            cancelAnimationFrame(timerInterval);
            timerInterval = null;
            
            // Update timer display
            timerDisplay.classList.add('expired');
            timerDisplay.classList.remove('warning', 'running');
            
            // Set game over flag
            gameOver = true;
            
            // Check if the score is a leaderboard high score
            const category = categorySelector.value;
            
            // Check for high scores regardless of the score value
            isHighScore(score, category).then(isHighEnough => {
              if (isHighEnough) {
                // Play high score sound first
                playSound(highScoreSound);
                showHighScoreModal(score, category);
              } else {
                // Play game over sound if not a high score
                playSound(gameOverSound);
              }
            });
            
            // Show game over message
            feedbackElement.textContent = `Game Over! Time's up! The answer was ${currentItem.name}. Final Score: ${score}`;
            feedbackElement.className = 'wrong';
            scoreElement.textContent = `Score: ${score}`;
            
            // Disable input and show try again button
            guessInput.disabled = true;
            submitButton.disabled = true;
            document.getElementById('try-again-btn').style.display = 'inline-block';
            
            // Update personal best scores in localStorage
            updateHighScore();
            
            return; // Exit the update loop
          }
          
          // Double-check game over state before scheduling next update
          if (!gameOver) {
            // Schedule the next update only if game is not over
            timerInterval = requestAnimationFrame(updateTimer);
          } else {
            timerInterval = null;
          }
        }
        
        // Start the timer loop
        timerInterval = requestAnimationFrame(updateTimer);
      }

      function stopTimer() {
        // Force cancel any existing animation frame
        if (timerInterval) {
          cancelAnimationFrame(timerInterval);
          timerInterval = null;
        }
        
        // Double check - use a direct global variable reference to ensure we're truly stopping all timers
        window.cancelAnimationFrame(timerInterval);
        timerInterval = null;
        
        // Reset timer display classes
        timerDisplay.classList.remove('running', 'warning');
        
        // Don't remove 'expired' class if the timer ran out or game is over (to keep the red color)
        if (timeLeft > 0 && !gameOver) {
          timerDisplay.classList.remove('expired');
        }
        
        // If game is over, make sure the timer stays stopped and update visual state
        if (gameOver) {
          timerInterval = null;
          timerDisplay.classList.add('expired');
        }
      }

      // Track the current loading state to prevent multiple simultaneous operations
      let isLoadingItem = false;
      let lastLoadTimestamp = 0;
      
      async function displayItem(item) {
        return new Promise(async (resolve, reject) => {
          try {
            if (!item || !item.name) {
              showPlaceholder('Invalid item data');
              resolve(false);
              return;
            }
            
            // Check if we're already displaying this item to prevent duplicate calls
            if (currentlyDisplayingItem === item.name) {
              return resolve(true);
            }
            
            // Set the currently displaying item to prevent race conditions
            currentlyDisplayingItem = item.name;
            
            // Get UI elements
            const loadingLeaf = document.querySelector('.loading-leaf');
            const placeholder = document.querySelector(".image-placeholder");
            
            // Hide any existing placeholder
            if (placeholder) {
              placeholder.style.display = "none";
            }
            
            // Reset image display
            imageDisplay.src = '';
            imageDisplay.style.display = "none";
            imageDisplay.classList.remove('loaded');
            
            // Show loading indicator
            if (loadingLeaf) {
              loadingLeaf.style.display = 'block';
            }
            
            // Helper function to load an image with a timeout
            const loadImage = (url, timeout = 5000) => {
              return new Promise((resolveImg, rejectImg) => {
                if (!url) {
                  return rejectImg(new Error('No image URL provided'));
                }
                
                const img = new Image();
                const timer = setTimeout(() => {
                  img.onload = img.onerror = null;
                  rejectImg(new Error(`Image load timed out: ${url}`));
                }, timeout);
                
                img.onload = () => {
                  clearTimeout(timer);
                  resolveImg(url);
                };
                
                img.onerror = () => {
                  clearTimeout(timer);
                  rejectImg(new Error(`Failed to load image: ${url}`));
                };
                
                img.src = url;
              });
            };
            
            // Track if we're already trying the fallback image to prevent infinite loops
            let isTryingFallback = false;
            
            // Function to try the fallback image
            const tryFallbackImage = async () => {
              // Prevent recursive calls that could cause infinite loops
              if (isTryingFallback) {
                // Show text placeholder as last resort
                imageDisplay.style.display = 'none';
                showPlaceholder(`${item.name} (Image unavailable)`);
                if (loadingLeaf) loadingLeaf.style.display = 'none';
                resolve(false);
                return;
              }
              
              // Set the flag to prevent recursive calls
              isTryingFallback = true;
              
              const fallbackUrl = item.fallback_image_url || 
                               (currentCategory ? `images/${currentCategory}/placeholder.svg` : null);
              
              if (fallbackUrl) {
                try {
                  await loadImage(fallbackUrl);
                  
                  // Set the fallback image source and wait for it to load
                  imageDisplay.onload = () => {
                    imageDisplay.style.display = 'block';
                    imageDisplay.classList.add('loaded');
                    if (loadingLeaf) loadingLeaf.style.display = 'none';
                    console.log(`Successfully displayed fallback image for ${item.name}`);
                    
                    // Start the timer now that the fallback image is successfully loaded
                    if (!gameOver) {
                      // Reset timer with current difficulty
                      const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
                      timeLeft = difficulty;
                      maxTime = difficulty;
                      timerDisplay.textContent = `Time: ${timeLeft}`;
                      timerDisplay.classList.remove('warning', 'expired');
                      
                      // Start the timer
                      startTimer();
                    }
                    
                    resolve(true);
                  };
                  
                  imageDisplay.onerror = () => {
                    console.error(`Error displaying fallback image for ${item.name}`);
                    // Show text placeholder as last resort
                    imageDisplay.style.display = 'none';
                    showPlaceholder(`${item.name} (Image unavailable)`);
                    if (loadingLeaf) loadingLeaf.style.display = 'none';
                    resolve(false);
                  };
                  
                  imageDisplay.src = fallbackUrl;
                } catch (error) {
                  console.error(`All image attempts failed for ${item.name}`);
                  // Show text placeholder if all image attempts fail
                  imageDisplay.style.display = 'none';
                  showPlaceholder(`${item.name} (Image unavailable)`);
                  if (loadingLeaf) loadingLeaf.style.display = 'none';
                  resolve(false);
                }
              } else {
                // No fallback URL available
                imageDisplay.style.display = 'none';
                showPlaceholder(`${item.name} (Image unavailable)`);
                if (loadingLeaf) loadingLeaf.style.display = 'none';
                resolve(false);
              }
            };
            
            // Try primary image first
            if (item.image_url) {
              try {
                await loadImage(item.image_url);
                
                // Set timeout to handle cases where onload/onerror might not fire
                const imageTimeout = setTimeout(() => {
                  // Check if this is still the current item we want to display
                  if (currentlyDisplayingItem !== item.name) {
                    return;
                  }
                  
                  // Remove the event handlers to prevent them from firing again
                  imageDisplay.onload = null;
                  imageDisplay.onerror = null;
                  
                  // Try the fallback image instead, but only if we haven't already
                  if (!isTryingFallback) {
                    tryFallbackImage();
                  } else {
                    // If we're already trying the fallback, just show a placeholder
                    imageDisplay.style.display = 'none';
                    showPlaceholder(`${item.name} (Image unavailable)`);
                    if (loadingLeaf) loadingLeaf.style.display = 'none';
                    resolve(false);
                  }
                }, 5000);
                
                // Set the image source and wait for it to load
                imageDisplay.onload = () => {
                  // Check if this is still the current item we want to display
                  if (currentlyDisplayingItem !== item.name) {
                    return;
                  }
                  
                  // Clear the timeout to prevent it from triggering
                  clearTimeout(imageTimeout);
                  
                  imageDisplay.style.display = 'block';
                  imageDisplay.classList.add('loaded');
                  if (loadingLeaf) loadingLeaf.style.display = 'none';
                  
                  // Start the timer now that the image is successfully loaded
                  if (!gameOver) {
                    // Reset timer with current difficulty
                    const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
                    timeLeft = difficulty;
                    maxTime = difficulty;
                    timerDisplay.textContent = `Time: ${timeLeft}`;
                    timerDisplay.classList.remove('warning', 'expired');
                    
                    // Start the timer
                    startTimer();
                  }
                  
                  resolve(true);
                };
                
                imageDisplay.onerror = () => {
                  // Check if this is still the current item we want to display
                  if (currentlyDisplayingItem !== item.name) {
                    return;
                  }
                  
                  // Clear the timeout to prevent it from triggering
                  clearTimeout(imageTimeout);
                  
                  // Remove the event handlers to prevent them from firing again
                  imageDisplay.onload = null;
                  imageDisplay.onerror = null;
                  
                  // Clear the image source
                  imageDisplay.src = '';
                  
                  // Try the fallback image instead, but only if we haven't already
                  if (!isTryingFallback) {
                    tryFallbackImage();
                  } else {
                    // If we're already trying the fallback, just show a placeholder
                    imageDisplay.style.display = 'none';
                    showPlaceholder(`${item.name} (Image unavailable)`);
                    if (loadingLeaf) loadingLeaf.style.display = 'none';
                    resolve(false);
                  }
                };
                
                imageDisplay.src = item.image_url;
              } catch (error) {
                console.warn(`Primary image failed for ${item.name}, trying fallback`);
                // Continue to fallback if primary image fails
                tryFallbackImage();
              }
            } else {
              // No primary image URL, try fallback directly
              tryFallbackImage();
            }
            
          } catch (error) {
            console.error('Unexpected error in displayItem:', error);
            
            // Clean up and show error message
            imageDisplay.style.display = 'none';
            showPlaceholder(`Error loading image`);
            
            const loadingLeaf = document.querySelector('.loading-leaf');
            if (loadingLeaf) loadingLeaf.style.display = 'none';
            
            // Reset the currently displaying item
            currentlyDisplayingItem = null;
            
            // Resolve with false instead of rejecting to prevent unhandled promise rejections
            resolve(false);
          } finally {
            // Make sure we release any locks if needed
            // We don't reset currentlyDisplayingItem here because we want to keep track of what's displayed
          }
        });
      }

      function showPlaceholder(text) {
        // Hide the image display
        imageDisplay.style.display = "none";
        
        // Create or find the placeholder element
        let placeholder = document.querySelector(".image-placeholder");
        if (!placeholder) {
          placeholder = document.createElement("div");
          placeholder.className = "image-placeholder";
          // Insert the placeholder before the image display
          imageDisplay.parentNode.insertBefore(placeholder, imageDisplay);
        }
        
        // Set the placeholder text and display it
        placeholder.textContent = text || "Image not available";
        placeholder.style.display = "block";
        
        console.log('Showing placeholder with text:', text);
      }

      async function setupNewRound() {
        // Reduced delay to 50ms to make next image load faster
        await new Promise(resolve => setTimeout(resolve, 50));
        
        // Check if we're already loading an item to prevent race conditions
        if (isLoadingItem) {
          // Force reset loading state if it's been stuck for too long (over 2 seconds)
          if (Date.now() - lastLoadTimestamp > 2000) {
            isLoadingItem = false;
          } else {
            return;
          }
        }
        
        try {
          // Set the loading flag to prevent concurrent operations
          isLoadingItem = true;
          
          // Disable input while loading to prevent race conditions
          guessInput.disabled = true;
          submitButton.disabled = true;
          
          // Clear previous state
          guessInput.value = "";
          feedbackElement.textContent = "Loading...";
          feedbackElement.className = "";
          nextButton.style.display = "none";
          
          // First, remove any existing event handlers from the image display to prevent stale events
          imageDisplay.onload = null;
          imageDisplay.onerror = null;
          
          // Reset the image display
          imageDisplay.src = '';
          imageDisplay.style.display = 'none';
          imageDisplay.classList.remove('loaded');
          
          // Reset the currently displaying item
          currentlyDisplayingItem = null;
          
          // Reset the trying fallback flag
          isTryingFallback = false;
          
          // Hide any existing placeholder
          const placeholder = document.querySelector(".image-placeholder");
          if (placeholder) {
            placeholder.style.display = "none";
          }
          
          // Show loading indicator
          const loadingLeaf = document.querySelector('.loading-leaf');
          if (loadingLeaf) {
            loadingLeaf.style.display = 'block';
          }

          // Get the current category
          const category = categorySelector.value;
          if (!category) {
            console.error('No category selected');
            feedbackElement.textContent = 'Error: No category selected';
            isLoadingItem = false; // Release the lock
            return;
          }
          
          console.log(`Setting up new round for category: ${category}`);
          
          try {
            // Get a random item from the current category - await to ensure synchronization
            const item = await getRandomItem(category);
            
            if (item && item.name) {
              console.log(`Got item for display: ${item.name}`);
              
              // Set the current item BEFORE displaying it to ensure consistency
              currentItem = item;
              currentCategory = category;
              
              // Wait for the item to be displayed before enabling input
              await displayItem(item);
              
              // Update UI
              feedbackElement.textContent = '';
              scoreElement.textContent = `Score: ${score}`;
              
              // Re-enable input after everything is loaded
              guessInput.disabled = false;
              submitButton.disabled = false;
              guessInput.focus();
              
              console.log(`Ready for guessing. Current item is: ${currentItem.name}`);
            } else {
              console.error('Invalid or missing item data');
              feedbackElement.textContent = 'Error loading item. Please try again.';
            }
          } catch (error) {
            console.error('Error getting or displaying item:', error);
            feedbackElement.textContent = 'Error loading item. Please try again.';
          } finally {
            // Hide loading indicator
            if (loadingLeaf) {
              loadingLeaf.style.display = 'none';
            }
            
            // Always release the lock
            isLoadingItem = false;
          }

          // Timer will be started after image is successfully loaded - see displayItem function

        } catch (error) {
          console.error('Error setting up new round:', error);
          feedbackElement.textContent = 'Error setting up new round. Please try again.';
        }
      }

      // Reset function for when categories are changed or Try Again is pressed
      async function resetGame() {
        console.log('Resetting game...');
        
        // Stop any current timer
        stopTimer();
        
        // Reset timer display based on current difficulty setting
        const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
        timeLeft = difficulty;
        maxTime = difficulty;
        timerDisplay.textContent = `Time: ${timeLeft}`;
        timerDisplay.className = 'timer';
        
        // Reset score
        score = 0;
        scoreElement.textContent = `Score: ${score}`;
        
        // Reset image display state
        imageDisplay.onload = null;
        imageDisplay.onerror = null;
        imageDisplay.src = '';
        imageDisplay.style.display = 'none';
        imageDisplay.classList.remove('loaded');
        
        // Reset state variables
        currentlyDisplayingItem = null;
        isTryingFallback = false;
        gameOver = false;
        
        // Reset loading state - IMPORTANT to prevent the game from getting stuck
        isLoadingItem = false;
        
        // Hide any existing placeholder
        const placeholder = document.querySelector(".image-placeholder");
        if (placeholder) {
          placeholder.style.display = "none";
        }
        
        // Show loading indicator
        const loadingLeaf = document.querySelector('.loading-leaf');
        if (loadingLeaf) {
          loadingLeaf.style.display = 'block';
        }
        
        // Hide next button if visible
        nextButton.style.display = 'none';
        
        // Reset feedback
        feedbackElement.textContent = "Loading...";
        feedbackElement.className = "";
        
        // Enable input and buttons
        guessInput.disabled = false;
        submitButton.disabled = false;
        guessInput.value = "";
        
        // Load a new item
        try {
          // Initialize the game with a new item
          await initGame();
          
          // Timer will be started after the image is successfully loaded in displayItem
          
          // Make sure the timer display shows the correct class
          timerDisplay.classList.remove('warning', 'expired');
          timerDisplay.classList.add('running');
        } catch (error) {
          console.error('Error resetting game:', error);
          feedbackElement.textContent = 'Error resetting game. Please try again.';
        }
      }

      function checkGuess() {
        if (submitButton.disabled) return; // Prevent multiple submissions
        
        // Stop the timer when an answer is submitted
        stopTimer();
        
        const guess = guessInput.value.trim().toLowerCase();
        const correctAnswer = currentItem.name.toLowerCase();
        
        // Initialize points earned for this guess
        let pointsEarned = 10; // Base points for correct answer

        if (guess === correctAnswer) {
          // Update score
          score += 10;
          scoreElement.textContent = score;
          
          // Play correct sound
          const correctSound = document.getElementById('correct-sound');
          if (correctSound) {
            correctSound.currentTime = 0;
            correctSound.play().catch(e => console.log('Could not play sound:', e));
            multiplier = 3;
          }
          
          // Calculate final points with multiplier
          const totalPoints = pointsEarned * multiplier;
          score += totalPoints;
          
          scoreElement.textContent = `Score: ${score}`;
          const multiplierText = multiplier > 1 ? ` x${multiplier}!` : '';
          feedbackElement.textContent = `Correct! +${totalPoints} points${multiplierText}`;
          feedbackElement.className = "correct";
          
          // Update personal best score after each correct answer
          updateHighScore();
          
          // Stop the timer after a correct guess
          stopTimer();
          
          // Reset image display state to prepare for the next round
          // First, remove any existing event handlers from the image display to prevent stale events
          imageDisplay.onload = null;
          imageDisplay.onerror = null;
          
          // Reset state variables
          currentlyDisplayingItem = null;
          isTryingFallback = false;
          
          // Show next button
          nextButton.style.display = 'block';
          
          // Disable input until next round
          guessInput.disabled = true;
          submitButton.disabled = true;
          
          // Make sure we release any loading locks before setting up a new round
          isLoadingItem = false;
          console.log('Setting isLoadingItem to false in checkGuess before timeout');
          
          // Automatically load next item with reduced delay for faster image loading
          // Reduced from 1000ms to 500ms for faster transitions between rounds
          setTimeout(async () => {
            // Make sure we're not in a loading state before setting up a new round
            if (isLoadingItem) {
              console.log('Resetting isLoadingItem flag before setting up new round');
              isLoadingItem = false;
            }
            
            // Reduced delay to 50ms to make next image load faster
            await new Promise(resolve => setTimeout(resolve, 50));
            
            // Double-check we're not in a loading state
            if (isLoadingItem) {
              console.warn('Still in loading state after delay, forcing reset');
              isLoadingItem = false;
            }
            
            // Set up new round (this will reset the timer values)
            setupNewRound();
            
            // Don't start the timer here - it will be started after the image loads in displayItem
            
            // Re-enable input for the next round
            guessInput.disabled = false;
            submitButton.disabled = false;
            submitButton.style.display = 'inline-block';
          }, 500); // Reduced from 1000ms to 500ms for faster transitions
        } else {
          // Stop the timer
          stopTimer();
          
          // Play wrong answer sound
          playSound(gameOverSound);
          
          // Incorrect guess - game over
          feedbackElement.textContent = `Game Over! The answer was ${currentItem.name}. Final Score: ${score}`;
          feedbackElement.className = "wrong";
          scoreElement.textContent = `Score: ${score}`;
          
          // Set game over flag BEFORE stopping timer
          gameOver = true;
          console.log('Game over set to true');
          
          // Make sure timer is completely stopped - call this AFTER setting gameOver flag
          stopTimer();
          
          // Force timer display to stop and cancel any pending animation frames
          if (timerInterval) {
            cancelAnimationFrame(timerInterval);
            timerInterval = null;
          }
          
          // Freeze the timer display to show the final time
          timerDisplay.classList.remove('running', 'warning');
          timerDisplay.classList.add('expired');
          
          // Disable input and replace submit button with try again button
          guessInput.disabled = true;
          submitButton.style.display = 'none';
          const tryAgainButton = document.getElementById('try-again-btn');
          tryAgainButton.style.display = 'inline-block';
          guessInput.focus(); // Keep focus on input for keyboard users
          
          // Update personal best scores in localStorage
          updateHighScore();
          
          // Check if the score is a leaderboard high score
          const category = categorySelector.value;
          
          // Only check for high scores if the score is at least 3
          if (score >= 3) {
            isHighScore(score, category).then(isHighEnough => {
              if (isHighEnough) {
                showHighScoreModal(score, category);
              }
            });
          }
          
          // Reset shown items when game is over
          shownItems = {};
        }
        guessInput.value = '';
      }
      
      function resetLeaderboardCategory(category) {
        if (!confirm(`Are you sure you want to reset the ${category} leaderboard? This cannot be undone.`)) {
          return; // User canceled
        }
        
        // Get current leaderboard data or create empty if not exists
        let leaderboardData = JSON.parse(localStorage.getItem('acnh_leaderboard') || '{}');
        
        // If leaderboard exists, reset the selected category
        if (leaderboardData) {
          try {
            // Reset the category to an empty array
            leaderboardData[category] = [];
            
            // Save updated leaderboard to localStorage
            localStorage.setItem('acnh_leaderboard', JSON.stringify(leaderboardData));
            
            // Update UI
            updateLeaderboardUI(leaderboardData);
            alert(`${category.charAt(0).toUpperCase() + category.slice(1)} leaderboard has been reset.`);
          } catch (e) {
            console.error('Error resetting leaderboard category:', e);
            alert('An error occurred while resetting the leaderboard.');
          }
        } else {
          // If no leaderboard exists yet, create an empty one
          leaderboardData = { fish: [], bugs: [], sea: [], villagers: [] };
          localStorage.setItem('acnh_leaderboard', JSON.stringify(leaderboardData));
          updateLeaderboardUI(leaderboardData);
          alert(`${category.charAt(0).toUpperCase() + category.slice(1)} leaderboard has been reset.`);
        }
      }

      function resetAllLeaderboards() {
        if (!confirm('Are you sure you want to reset ALL leaderboards? This cannot be undone.')) {
          return; // User canceled
        }
        
        // Create empty leaderboard data
        const emptyLeaderboard = { fish: [], bugs: [], sea: [], villagers: [] };
        
        // Save to localStorage
        localStorage.setItem('acnh_leaderboard', JSON.stringify(emptyLeaderboard));
        
        // Update the UI
        updateLeaderboardUI(emptyLeaderboard);
        
        alert('All leaderboards have been reset.');
      }
      
      function resetToDefaults() {
        if (!confirm('Are you sure you want to reset the leaderboards to default values from leaderboard.json?')) {
          return; // User canceled
        }
        
        // Fetch the default leaderboard data from leaderboard.json
        fetch('leaderboard.json')
          .then(response => {
            if (!response.ok) {
              throw new Error('Failed to load default leaderboard data');
            }
            return response.json();
          })
          .then(defaultData => {
            // Save the default data to localStorage
            localStorage.setItem('acnh_leaderboard', JSON.stringify(defaultData));
            
            // Update the UI
            updateLeaderboardUI(defaultData);
            
            alert('Leaderboards have been reset to default values.');
          })
          .catch(error => {
            console.error('Error loading default leaderboard data:', error);
            alert('Error loading default leaderboard data. Please try again.');
          });
      }

      async function isHighScore(score, category) {
        try {
          // First check local storage for any existing scores
          const savedLeaderboard = localStorage.getItem('acnh_leaderboard');
          if (savedLeaderboard) {
            const data = JSON.parse(savedLeaderboard);
            const scores = data[category] || [];
            
            // If there are fewer than 10 scores, any score is a high score
            if (scores.length < 10) return true;
            
            // Find the lowest score in the top 10
            const lowestScore = scores.reduce((min, entry) => 
              entry.score < min ? entry.score : min, scores[0].score);
            
            return score > lowestScore;
          }
          
          // If no local data, check the server
          const response = await fetch('leaderboard.json');
          const data = await response.json();
          const scores = data[category] || [];
          
          // If there are fewer than 10 scores, any score is a high score
          if (scores.length < 10) return true;
          
          // Find the lowest score in the top 10
          const lowestScore = scores.reduce((min, entry) => 
            entry.score < min ? entry.score : min, scores[0].score);
          
          return score > lowestScore;
          
        } catch (error) {
          console.error('Error checking high score:', error);
          // Default to true if there's an error (to be safe)
          return true;
        }
      }

      window.addEventListener("DOMContentLoaded", () => {
        // Add reset button event listener
        const resetButton = document.getElementById('reset-high-score');
        if (resetButton) {
          resetButton.addEventListener('click', () => {
            // Reset all high scores
            localStorage.removeItem('acnh_high_score');
            const category = categorySelector.value;
            localStorage.removeItem(`acnh_high_score_${category}`);
            
            // Reset shown items
            localStorage.removeItem(`shown_items_${category}`);
            
            // Reset current score
            score = 0;
            scoreElement.textContent = `Score: ${score}`;
            
            // Update high score display
            highScoreElement.textContent = `Personal Best: 0`;
            
            // Don't load a new image when resetting high score
            // Show the Start Game button instead
            const startGameButton = document.getElementById('start-game-btn');
            if (startGameButton) {
              startGameButton.style.display = 'inline-block';
            }
          });
        }

        // Flag to prevent duplicate category change handling
        let isHandlingCategoryChange = false;
        
        // Event listener for category change
        categorySelector.addEventListener('change', async function(e) {
          if (isHandlingCategoryChange) return; // Prevent multiple simultaneous category changes
          
          isHandlingCategoryChange = true;
          const category = e.target.value;
          
          try {
            // Don't reset the game state with resetGame() as it loads images
            // Instead, just stop the timer and reset the score
            stopTimer();
            
            // Make sure the timer is completely stopped
            if (timerInterval) {
              cancelAnimationFrame(timerInterval);
              timerInterval = null;
            }
            
            // Reset game over flag to ensure timer can start again
            gameOver = false;
            
            // Reset timer display
            const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
            timeLeft = difficulty;
            maxTime = difficulty;
            timerDisplay.textContent = `Time: ${timeLeft}`;
            timerDisplay.classList.remove('warning', 'expired', 'running');
            
            score = 0;
            scoreElement.textContent = `Score: ${score}`;
            
            // Update high score for the selected category
            const categoryKey = `acnh_high_score_${category}`;
            const currentHighScore = parseInt(localStorage.getItem(categoryKey) || '0', 10);
            highScoreElement.textContent = `Personal Best: ${currentHighScore}`;
            
            // Save selected category to localStorage
            localStorage.setItem("acnh_last_category", category);
            
            // Load new category items but don't start the game yet
            if (!isLoadingItems) {
              // Wait for items to load before continuing
              await loadCategoryItems(category);
            } else {
              console.log('Waiting for previous category load to complete...');
              // Wait for loading to complete and then try again
              await new Promise(resolve => {
                const checkLoading = setInterval(() => {
                  if (!isLoadingItems) {
                    clearInterval(checkLoading);
                    resolve();
                  }
                }, 100);
              });
              await loadCategoryItems(category);
            }
            
            // Show the Start Game button
            const startGameButton = document.getElementById('start-game-btn');
            if (startGameButton) {
              startGameButton.style.display = 'inline-block';
            }
          } catch (error) {
            console.error('Error changing category:', error);
            feedbackElement.textContent = 'Error loading category. Please try again.';
          } finally {
            isHandlingCategoryChange = false; // Reset the flag when done
          }
        });
        
        // Event listener for difficulty change
        difficultySelector.addEventListener('change', function() {
          // Stop the current timer when difficulty changes
          stopTimer();
          
          // Update timer values based on the new difficulty
          const difficulty = parseInt(document.getElementById('difficulty').value) / 1000;
          timeLeft = difficulty;
          maxTime = difficulty;
          timerDisplay.textContent = `Time: ${timeLeft}`;
          timerDisplay.classList.remove('warning', 'expired');
          
          // Don't load a new image when difficulty changes, only update the timer values
          // setupNewRound will be called when Start Game is pressed
        });

        // Restore score and category from previous session
        const savedScore = localStorage.getItem("acnh_current_score");
        if (savedScore) {
          score = parseInt(savedScore, 10);
          scoreElement.textContent = `Score: ${score}`;
        }

        const savedCategory = localStorage.getItem("acnh_last_category");
        if (savedCategory) {
          categorySelector.value = savedCategory;
          
          // Update high score for the selected category
          const categoryKey = `acnh_high_score_${savedCategory}`;
          const currentHighScore = parseInt(localStorage.getItem(categoryKey) || '0', 10);
          highScoreElement.textContent = `Personal Best: ${currentHighScore}`;
        }

        updateLeaderboard();
        
        // Don't load any images until the game starts
        
        // Add event listener for the Start Game button
        const startGameButton = document.getElementById('start-game-btn');
        if (startGameButton) {
          startGameButton.addEventListener('click', function() {
            // Hide the start game button
            startGameButton.style.display = 'none';
            
            // Enable the input field and focus it
            guessInput.disabled = false;
            guessInput.style.display = 'inline-block';
            guessInput.focus();
            
            // Show the submit button
            submitButton.style.display = 'inline-block';
            
            // Initialize the game (this will load the first image)
            initGame(true);
            
            // Start the game round - the timer will be started after the image loads
            setupNewRound();
            
            // Play new round sound
            playSound(startGameSound);
          });
        }
        
        // Add event listener for the sound toggle button
        const soundToggleBtn = document.getElementById('sound-toggle');
        if (soundToggleBtn) {
          soundToggleBtn.addEventListener('click', function() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('acnh_sound_enabled', soundEnabled);
            
            // Update button text
            soundToggleBtn.innerHTML = soundEnabled ? '🔊 Sound: ON' : '🔇 Sound: OFF';
            
            // Add a small animation effect on click
            soundToggleBtn.style.transform = 'scale(0.9)';
            setTimeout(() => {
              soundToggleBtn.style.transform = 'scale(1)';
            }, 100);
          });
        }
        
        // Add event listeners for the reset buttons - safely with null checks
        const resetFishBtn = document.getElementById('reset-fish-btn');
        if (resetFishBtn) resetFishBtn.addEventListener('click', () => resetLeaderboardCategory('fish'));
        
        // Add event listeners for admin buttons
        document.getElementById('simulate-score-btn').addEventListener('click', () => {
          const categories = ['fish', 'bugs', 'sea', 'villagers'];
          const randomCategory = categories[Math.floor(Math.random() * categories.length)];
          const testScore = Math.floor(Math.random() * 371) + 130; // Random score between 130-500
          
          // Directly show the high score modal for the test score
          showHighScoreModal(testScore, randomCategory);
        });
        
        const resetBugsBtn = document.getElementById('reset-bugs-btn');
        if (resetBugsBtn) resetBugsBtn.addEventListener('click', () => resetLeaderboardCategory('bugs'));
        
        const resetSeaBtn = document.getElementById('reset-sea-btn');
        if (resetSeaBtn) resetSeaBtn.addEventListener('click', () => resetLeaderboardCategory('sea'));
        
        const resetVillagersBtn = document.getElementById('reset-villagers-btn');
        if (resetVillagersBtn) resetVillagersBtn.addEventListener('click', () => resetLeaderboardCategory('villagers'));
        
        const resetAllBtn = document.getElementById('reset-all-btn');
        if (resetAllBtn) resetAllBtn.addEventListener('click', resetAllLeaderboards);
        
        const resetToDefaultsBtn = document.getElementById('reset-to-defaults-btn');
        if (resetToDefaultsBtn) resetToDefaultsBtn.addEventListener('click', resetToDefaults);

        submitButton.addEventListener("click", checkGuess);
        guessInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            e.preventDefault(); // Prevent form submission if any
            const tryAgainButton = document.getElementById("try-again-btn");
            if (tryAgainButton && window.getComputedStyle(tryAgainButton).display !== 'none') {
              // If Try Again button is visible, trigger it
              tryAgainButton.click();
            } else {
              // Otherwise, check the guess as normal
              checkGuess();
            }
          }
        });

        // Handle keyboard visibility on mobile devices
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
          // Set fixed position for game container to prevent automatic scrolling
          const gameContainer = document.getElementById('game-container');
          if (gameContainer) {
            // Add CSS to allow manual scrolling but prevent automatic repositioning
            gameContainer.style.position = 'relative';
            gameContainer.style.overflowY = 'auto';
            gameContainer.style.maxHeight = '90vh'; // Set maximum height to allow scrolling
          }
          
          // Prevent default focus behavior that would scroll the screen
          guessInput.addEventListener('focus', function(e) {
            // Prevent automatic scrolling
            e.preventDefault();
            // Keep focus on input field
            setTimeout(function() {
              guessInput.focus();
            }, 50);
          });

          // Handle orientation changes without repositioning
          window.addEventListener('resize', function() {
            // No automatic scrolling on resize
          });
        }
        // Custom handler for next button to avoid playing start-game sound
        nextButton.addEventListener("click", () => {
          // Hide the next button
          nextButton.style.display = 'none';
          
          // Set up a new round without playing the start-game sound
          setupNewRound();
          
          // Re-enable input
          guessInput.disabled = false;
          submitButton.disabled = false;
          submitButton.style.display = 'inline-block';
          guessInput.focus();
        });
        const tryAgainButton = document.getElementById("try-again-btn");
        tryAgainButton.addEventListener("click", async () => {
          // Reset game state
          gameOver = false;
          
          // Hide the try again button
          tryAgainButton.style.display = 'none';
          
          // Show the submit button
          submitButton.style.display = 'inline-block';
          
          // Play new round sound
          playSound(startGameSound);
          
          // Use our improved resetGame function to properly reset everything
          await resetGame();
          
          // Focus the input field
          guessInput.focus();
        });
        
        // Add event listener for the End Game button
        const endGameButton = document.getElementById("end-game-btn");
        endGameButton.addEventListener("click", () => {
          // Stop the timer
          stopTimer();
          
          // Disable game controls
          guessInput.disabled = true;
          submitButton.disabled = true;
          
          // Set game over flag
          gameOver = true;
          
          // Show feedback and Try Again button
          feedbackElement.textContent = `Game Over! Final Score: ${score}`;
          feedbackElement.className = "";
          
          // Show the Try Again button
          const tryAgainButton = document.getElementById("try-again-btn");
          tryAgainButton.style.display = 'inline-block';
          
          // Hide the End Game button
          endGameButton.style.display = 'none';
          
          // Update personal best scores in localStorage
          updateHighScore();
          
          // Check if the score is a leaderboard high score
          const category = categorySelector.value;
          
          // Check for high scores regardless of the score value
          isHighScore(score, category).then(isHighEnough => {
            if (isHighEnough) {
              showHighScoreModal(score, category);
            } else {
              playSound(gameOverSound);
            }
          });
        });
        
        function startGame() {
         
          // Add event listener for sound toggle
          soundToggleBtn.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggleBtn.style.backgroundColor = soundEnabled ? '#4a90e2' : '#cccccc';
          });
          
          const startGameBtn = document.getElementById('start-game-btn');
          startGameBtn.addEventListener('click', () => {
            // Hide the start button
            startGameBtn.style.display = 'none';
            
            // Show the end game button
            document.getElementById('end-game-btn').style.display = 'inline-block';
            
            // Enable the guess input and submit button
            guessInput.disabled = false;
            guessInput.style.display = 'inline-block';
            submitButton.style.display = 'inline-block';
            submitButton.disabled = false;
            
            // Focus on the input
            guessInput.focus();
            
            // Reset score
            score = 0;
            scoreElement.textContent = `Score: ${score}`;
            
            // Clear any feedback
            feedbackElement.textContent = '';
            feedbackElement.className = '';
            
            // Play new round sound
            playSound(startGameSound);
            
            // Start the timer after a short delay to ensure UI is ready
            setTimeout(() => {
              stopTimer(); // Clear any existing timer first
              startTimer();
              setupNewRound();
            }, 100);
          });  
        }
        
        // Store the current category change promise to prevent race conditions
      let categoryChangePromise = null;
      let isCategoryLoading = false;
      
      categorySelector.addEventListener("change", async (e) => {
        const category = e.target.value;
        
        // If we're already changing categories, wait for that to complete
        if (isCategoryLoading) {
          console.log('Category change already in progress, waiting...');
          return;
        }
        
        isCategoryLoading = true;
        feedbackElement.textContent = "Loading...";
        feedbackElement.className = "";
        
        try {
          // Stop the current timer if it's running
          stopTimer();
          
          // Reset timer variables
          timeLeft = 15;
          timerDisplay.textContent = `Time: ${timeLeft}`;
          timerDisplay.className = 'timer';
          
          console.log(`Loading category: ${category}`);
          
          // Always load items for the category to ensure we have fresh data
          await loadCategoryItems(category);
          
          // Only update the category and score, but don't load images yet
          if (currentCategory !== category) {
            console.log(`Category changed from ${currentCategory} to ${category}, resetting score`);
            score = 0;
            currentCategory = category;
            // Don't call initGame() here, wait for Start Game button
            
            // Show the Start Game button
            const startGameButton = document.getElementById('start-game-btn');
            if (startGameButton) {
              startGameButton.style.display = 'inline-block';
            }
          }
          
          // Update high score when category changes
          const categoryKey = `acnh_high_score_${category}`;
          const currentHighScore = parseInt(localStorage.getItem(categoryKey) || '0', 10);
          highScoreElement.textContent = `Personal Best: ${currentHighScore}`;
          
        } catch (error) {
          console.error('Error changing category:', error);
          feedbackElement.textContent = 'Error changing category. Please try again.';
          feedbackElement.className = 'wrong';
        } finally {
          isCategoryLoading = false;
          feedbackElement.textContent = '';
        }
      });
      });
    </script>
  </body>
</html>